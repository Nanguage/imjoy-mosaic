(function(){const j=document.createElement("link").relList;if(j&&j.supports&&j.supports("modulepreload"))return;for(const et of document.querySelectorAll('link[rel="modulepreload"]'))_e(et);new MutationObserver(et=>{for(const tt of et)if(tt.type==="childList")for(const nt of tt.addedNodes)nt.tagName==="LINK"&&nt.rel==="modulepreload"&&_e(nt)}).observe(document,{childList:!0,subtree:!0});function $(et){const tt={};return et.integrity&&(tt.integrity=et.integrity),et.referrerPolicy&&(tt.referrerPolicy=et.referrerPolicy),et.crossOrigin==="use-credentials"?tt.credentials="include":et.crossOrigin==="anonymous"?tt.credentials="omit":tt.credentials="same-origin",tt}function _e(et){if(et.ep)return;et.ep=!0;const tt=$(et);fetch(et.href,tt)}})();var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(_){return _&&_.__esModule&&Object.prototype.hasOwnProperty.call(_,"default")?_.default:_}function getAugmentedNamespace(_){if(_.__esModule)return _;var j=_.default;if(typeof j=="function"){var $=function _e(){return this instanceof _e?Reflect.construct(j,arguments,this.constructor):j.apply(this,arguments)};$.prototype=j.prototype}else $={};return Object.defineProperty($,"__esModule",{value:!0}),Object.keys(_).forEach(function(_e){var et=Object.getOwnPropertyDescriptor(_,_e);Object.defineProperty($,_e,et.get?et:{enumerable:!0,get:function(){return _[_e]}})}),$}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$5=Symbol.for("react.element"),n$4=Symbol.for("react.portal"),p$8=Symbol.for("react.fragment"),q$4=Symbol.for("react.strict_mode"),r$3=Symbol.for("react.profiler"),t$4=Symbol.for("react.provider"),u$5=Symbol.for("react.context"),v$3=Symbol.for("react.forward_ref"),w$2=Symbol.for("react.suspense"),x$2=Symbol.for("react.memo"),y$1=Symbol.for("react.lazy"),z$1=Symbol.iterator;function A$1(_){return _===null||typeof _!="object"?null:(_=z$1&&_[z$1]||_["@@iterator"],typeof _=="function"?_:null)}var B$1={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$2=Object.assign,D$2={};function E$3(_,j,$){this.props=_,this.context=j,this.refs=D$2,this.updater=$||B$1}E$3.prototype.isReactComponent={};E$3.prototype.setState=function(_,j){if(typeof _!="object"&&typeof _!="function"&&_!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,_,j,"setState")};E$3.prototype.forceUpdate=function(_){this.updater.enqueueForceUpdate(this,_,"forceUpdate")};function F(){}F.prototype=E$3.prototype;function G$1(_,j,$){this.props=_,this.context=j,this.refs=D$2,this.updater=$||B$1}var H$1=G$1.prototype=new F;H$1.constructor=G$1;C$2(H$1,E$3.prototype);H$1.isPureReactComponent=!0;var I$1=Array.isArray,J=Object.prototype.hasOwnProperty,K$1={current:null},L$2={key:!0,ref:!0,__self:!0,__source:!0};function M$2(_,j,$){var _e,et={},tt=null,nt=null;if(j!=null)for(_e in j.ref!==void 0&&(nt=j.ref),j.key!==void 0&&(tt=""+j.key),j)J.call(j,_e)&&!L$2.hasOwnProperty(_e)&&(et[_e]=j[_e]);var rt=arguments.length-2;if(rt===1)et.children=$;else if(1<rt){for(var at=Array(rt),it=0;it<rt;it++)at[it]=arguments[it+2];et.children=at}if(_&&_.defaultProps)for(_e in rt=_.defaultProps,rt)et[_e]===void 0&&(et[_e]=rt[_e]);return{$$typeof:l$5,type:_,key:tt,ref:nt,props:et,_owner:K$1.current}}function N$1(_,j){return{$$typeof:l$5,type:_.type,key:j,ref:_.ref,props:_.props,_owner:_._owner}}function O$2(_){return typeof _=="object"&&_!==null&&_.$$typeof===l$5}function escape(_){var j={"=":"=0",":":"=2"};return"$"+_.replace(/[=:]/g,function($){return j[$]})}var P$2=/\/+/g;function Q$1(_,j){return typeof _=="object"&&_!==null&&_.key!=null?escape(""+_.key):j.toString(36)}function R$2(_,j,$,_e,et){var tt=typeof _;(tt==="undefined"||tt==="boolean")&&(_=null);var nt=!1;if(_===null)nt=!0;else switch(tt){case"string":case"number":nt=!0;break;case"object":switch(_.$$typeof){case l$5:case n$4:nt=!0}}if(nt)return nt=_,et=et(nt),_=_e===""?"."+Q$1(nt,0):_e,I$1(et)?($="",_!=null&&($=_.replace(P$2,"$&/")+"/"),R$2(et,j,$,"",function(it){return it})):et!=null&&(O$2(et)&&(et=N$1(et,$+(!et.key||nt&&nt.key===et.key?"":(""+et.key).replace(P$2,"$&/")+"/")+_)),j.push(et)),1;if(nt=0,_e=_e===""?".":_e+":",I$1(_))for(var rt=0;rt<_.length;rt++){tt=_[rt];var at=_e+Q$1(tt,rt);nt+=R$2(tt,j,$,at,et)}else if(at=A$1(_),typeof at=="function")for(_=at.call(_),rt=0;!(tt=_.next()).done;)tt=tt.value,at=_e+Q$1(tt,rt++),nt+=R$2(tt,j,$,at,et);else if(tt==="object")throw j=String(_),Error("Objects are not valid as a React child (found: "+(j==="[object Object]"?"object with keys {"+Object.keys(_).join(", ")+"}":j)+"). If you meant to render a collection of children, use an array instead.");return nt}function S$2(_,j,$){if(_==null)return _;var _e=[],et=0;return R$2(_,_e,"","",function(tt){return j.call($,tt,et++)}),_e}function T$2(_){if(_._status===-1){var j=_._result;j=j(),j.then(function($){(_._status===0||_._status===-1)&&(_._status=1,_._result=$)},function($){(_._status===0||_._status===-1)&&(_._status=2,_._result=$)}),_._status===-1&&(_._status=0,_._result=j)}if(_._status===1)return _._result.default;throw _._result}var U$1={current:null},V$1={transition:null},W$1={ReactCurrentDispatcher:U$1,ReactCurrentBatchConfig:V$1,ReactCurrentOwner:K$1};function X$1(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$2,forEach:function(_,j,$){S$2(_,function(){j.apply(this,arguments)},$)},count:function(_){var j=0;return S$2(_,function(){j++}),j},toArray:function(_){return S$2(_,function(j){return j})||[]},only:function(_){if(!O$2(_))throw Error("React.Children.only expected to receive a single React element child.");return _}};react_production_min.Component=E$3;react_production_min.Fragment=p$8;react_production_min.Profiler=r$3;react_production_min.PureComponent=G$1;react_production_min.StrictMode=q$4;react_production_min.Suspense=w$2;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$1;react_production_min.act=X$1;react_production_min.cloneElement=function(_,j,$){if(_==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+_+".");var _e=C$2({},_.props),et=_.key,tt=_.ref,nt=_._owner;if(j!=null){if(j.ref!==void 0&&(tt=j.ref,nt=K$1.current),j.key!==void 0&&(et=""+j.key),_.type&&_.type.defaultProps)var rt=_.type.defaultProps;for(at in j)J.call(j,at)&&!L$2.hasOwnProperty(at)&&(_e[at]=j[at]===void 0&&rt!==void 0?rt[at]:j[at])}var at=arguments.length-2;if(at===1)_e.children=$;else if(1<at){rt=Array(at);for(var it=0;it<at;it++)rt[it]=arguments[it+2];_e.children=rt}return{$$typeof:l$5,type:_.type,key:et,ref:tt,props:_e,_owner:nt}};react_production_min.createContext=function(_){return _={$$typeof:u$5,_currentValue:_,_currentValue2:_,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},_.Provider={$$typeof:t$4,_context:_},_.Consumer=_};react_production_min.createElement=M$2;react_production_min.createFactory=function(_){var j=M$2.bind(null,_);return j.type=_,j};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(_){return{$$typeof:v$3,render:_}};react_production_min.isValidElement=O$2;react_production_min.lazy=function(_){return{$$typeof:y$1,_payload:{_status:-1,_result:_},_init:T$2}};react_production_min.memo=function(_,j){return{$$typeof:x$2,type:_,compare:j===void 0?null:j}};react_production_min.startTransition=function(_){var j=V$1.transition;V$1.transition={};try{_()}finally{V$1.transition=j}};react_production_min.unstable_act=X$1;react_production_min.useCallback=function(_,j){return U$1.current.useCallback(_,j)};react_production_min.useContext=function(_){return U$1.current.useContext(_)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(_){return U$1.current.useDeferredValue(_)};react_production_min.useEffect=function(_,j){return U$1.current.useEffect(_,j)};react_production_min.useId=function(){return U$1.current.useId()};react_production_min.useImperativeHandle=function(_,j,$){return U$1.current.useImperativeHandle(_,j,$)};react_production_min.useInsertionEffect=function(_,j){return U$1.current.useInsertionEffect(_,j)};react_production_min.useLayoutEffect=function(_,j){return U$1.current.useLayoutEffect(_,j)};react_production_min.useMemo=function(_,j){return U$1.current.useMemo(_,j)};react_production_min.useReducer=function(_,j,$){return U$1.current.useReducer(_,j,$)};react_production_min.useRef=function(_){return U$1.current.useRef(_)};react_production_min.useState=function(_){return U$1.current.useState(_)};react_production_min.useSyncExternalStore=function(_,j,$){return U$1.current.useSyncExternalStore(_,j,$)};react_production_min.useTransition=function(){return U$1.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs(reactExports);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f$2=reactExports,k$2=Symbol.for("react.element"),l$4=Symbol.for("react.fragment"),m$4=Object.prototype.hasOwnProperty,n$3=f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$7={key:!0,ref:!0,__self:!0,__source:!0};function q$3(_,j,$){var _e,et={},tt=null,nt=null;$!==void 0&&(tt=""+$),j.key!==void 0&&(tt=""+j.key),j.ref!==void 0&&(nt=j.ref);for(_e in j)m$4.call(j,_e)&&!p$7.hasOwnProperty(_e)&&(et[_e]=j[_e]);if(_&&_.defaultProps)for(_e in j=_.defaultProps,j)et[_e]===void 0&&(et[_e]=j[_e]);return{$$typeof:k$2,type:_,key:tt,ref:nt,props:et,_owner:n$3.current}}reactJsxRuntime_production_min.Fragment=l$4;reactJsxRuntime_production_min.jsx=q$3;reactJsxRuntime_production_min.jsxs=q$3;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,client={},reactDom={exports:{}},reactDom_production_min={},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(_){function j(kt,Ot){var Dt=kt.length;kt.push(Ot);e:for(;0<Dt;){var $t=Dt-1>>>1,Pt=kt[$t];if(0<et(Pt,Ot))kt[$t]=Ot,kt[Dt]=Pt,Dt=$t;else break e}}function $(kt){return kt.length===0?null:kt[0]}function _e(kt){if(kt.length===0)return null;var Ot=kt[0],Dt=kt.pop();if(Dt!==Ot){kt[0]=Dt;e:for(var $t=0,Pt=kt.length,zt=Pt>>>1;$t<zt;){var Mt=2*($t+1)-1,It=kt[Mt],Lt=Mt+1,Ut=kt[Lt];if(0>et(It,Dt))Lt<Pt&&0>et(Ut,It)?(kt[$t]=Ut,kt[Lt]=Dt,$t=Lt):(kt[$t]=It,kt[Mt]=Dt,$t=Mt);else if(Lt<Pt&&0>et(Ut,Dt))kt[$t]=Ut,kt[Lt]=Dt,$t=Lt;else break e}}return Ot}function et(kt,Ot){var Dt=kt.sortIndex-Ot.sortIndex;return Dt!==0?Dt:kt.id-Ot.id}if(typeof performance=="object"&&typeof performance.now=="function"){var tt=performance;_.unstable_now=function(){return tt.now()}}else{var nt=Date,rt=nt.now();_.unstable_now=function(){return nt.now()-rt}}var at=[],it=[],ot=1,st=null,ct=3,pt=!1,dt=!1,ft=!1,gt=typeof setTimeout=="function"?setTimeout:null,ut=typeof clearTimeout=="function"?clearTimeout:null,lt=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function ht(kt){for(var Ot=$(it);Ot!==null;){if(Ot.callback===null)_e(it);else if(Ot.startTime<=kt)_e(it),Ot.sortIndex=Ot.expirationTime,j(at,Ot);else break;Ot=$(it)}}function yt(kt){if(ft=!1,ht(kt),!dt)if($(at)!==null)dt=!0,Ft(vt);else{var Ot=$(it);Ot!==null&&Vt(yt,Ot.startTime-kt)}}function vt(kt,Ot){dt=!1,ft&&(ft=!1,ut(_t),_t=-1),pt=!0;var Dt=ct;try{for(ht(Ot),st=$(at);st!==null&&(!(st.expirationTime>Ot)||kt&&!St());){var $t=st.callback;if(typeof $t=="function"){st.callback=null,ct=st.priorityLevel;var Pt=$t(st.expirationTime<=Ot);Ot=_.unstable_now(),typeof Pt=="function"?st.callback=Pt:st===$(at)&&_e(at),ht(Ot)}else _e(at);st=$(at)}if(st!==null)var zt=!0;else{var Mt=$(it);Mt!==null&&Vt(yt,Mt.startTime-Ot),zt=!1}return zt}finally{st=null,ct=Dt,pt=!1}}var bt=!1,mt=null,_t=-1,Et=5,wt=-1;function St(){return!(_.unstable_now()-wt<Et)}function Tt(){if(mt!==null){var kt=_.unstable_now();wt=kt;var Ot=!0;try{Ot=mt(!0,kt)}finally{Ot?At():(bt=!1,mt=null)}}else bt=!1}var At;if(typeof lt=="function")At=function(){lt(Tt)};else if(typeof MessageChannel<"u"){var Ht=new MessageChannel,Rt=Ht.port2;Ht.port1.onmessage=Tt,At=function(){Rt.postMessage(null)}}else At=function(){gt(Tt,0)};function Ft(kt){mt=kt,bt||(bt=!0,At())}function Vt(kt,Ot){_t=gt(function(){kt(_.unstable_now())},Ot)}_.unstable_IdlePriority=5,_.unstable_ImmediatePriority=1,_.unstable_LowPriority=4,_.unstable_NormalPriority=3,_.unstable_Profiling=null,_.unstable_UserBlockingPriority=2,_.unstable_cancelCallback=function(kt){kt.callback=null},_.unstable_continueExecution=function(){dt||pt||(dt=!0,Ft(vt))},_.unstable_forceFrameRate=function(kt){0>kt||125<kt?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Et=0<kt?Math.floor(1e3/kt):5},_.unstable_getCurrentPriorityLevel=function(){return ct},_.unstable_getFirstCallbackNode=function(){return $(at)},_.unstable_next=function(kt){switch(ct){case 1:case 2:case 3:var Ot=3;break;default:Ot=ct}var Dt=ct;ct=Ot;try{return kt()}finally{ct=Dt}},_.unstable_pauseExecution=function(){},_.unstable_requestPaint=function(){},_.unstable_runWithPriority=function(kt,Ot){switch(kt){case 1:case 2:case 3:case 4:case 5:break;default:kt=3}var Dt=ct;ct=kt;try{return Ot()}finally{ct=Dt}},_.unstable_scheduleCallback=function(kt,Ot,Dt){var $t=_.unstable_now();switch(typeof Dt=="object"&&Dt!==null?(Dt=Dt.delay,Dt=typeof Dt=="number"&&0<Dt?$t+Dt:$t):Dt=$t,kt){case 1:var Pt=-1;break;case 2:Pt=250;break;case 5:Pt=1073741823;break;case 4:Pt=1e4;break;default:Pt=5e3}return Pt=Dt+Pt,kt={id:ot++,callback:Ot,priorityLevel:kt,startTime:Dt,expirationTime:Pt,sortIndex:-1},Dt>$t?(kt.sortIndex=Dt,j(it,kt),$(at)===null&&kt===$(it)&&(ft?(ut(_t),_t=-1):ft=!0,Vt(yt,Dt-$t))):(kt.sortIndex=Pt,j(at,kt),dt||pt||(dt=!0,Ft(vt))),kt},_.unstable_shouldYield=St,_.unstable_wrapCallback=function(kt){var Ot=ct;return function(){var Dt=ct;ct=Ot;try{return kt.apply(this,arguments)}finally{ct=Dt}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa=reactExports,ca=schedulerExports;function p$6(_){for(var j="https://reactjs.org/docs/error-decoder.html?invariant="+_,$=1;$<arguments.length;$++)j+="&args[]="+encodeURIComponent(arguments[$]);return"Minified React error #"+_+"; visit "+j+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(_,j){ha(_,j),ha(_+"Capture",j)}function ha(_,j){for(ea[_]=j,_=0;_<j.length;_++)da.add(j[_])}var ia=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la={},ma={};function oa(_){return ja.call(ma,_)?!0:ja.call(la,_)?!1:ka.test(_)?ma[_]=!0:(la[_]=!0,!1)}function pa(_,j,$,_e){if($!==null&&$.type===0)return!1;switch(typeof j){case"function":case"symbol":return!0;case"boolean":return _e?!1:$!==null?!$.acceptsBooleans:(_=_.toLowerCase().slice(0,5),_!=="data-"&&_!=="aria-");default:return!1}}function qa(_,j,$,_e){if(j===null||typeof j>"u"||pa(_,j,$,_e))return!0;if(_e)return!1;if($!==null)switch($.type){case 3:return!j;case 4:return j===!1;case 5:return isNaN(j);case 6:return isNaN(j)||1>j}return!1}function v$2(_,j,$,_e,et,tt,nt){this.acceptsBooleans=j===2||j===3||j===4,this.attributeName=_e,this.attributeNamespace=et,this.mustUseProperty=$,this.propertyName=_,this.type=j,this.sanitizeURL=tt,this.removeEmptyString=nt}var z={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(_){z[_]=new v$2(_,0,!1,_,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(_){var j=_[0];z[j]=new v$2(j,1,!1,_[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(_){z[_]=new v$2(_,2,!1,_.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(_){z[_]=new v$2(_,2,!1,_,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(_){z[_]=new v$2(_,3,!1,_.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(_){z[_]=new v$2(_,3,!0,_,null,!1,!1)});["capture","download"].forEach(function(_){z[_]=new v$2(_,4,!1,_,null,!1,!1)});["cols","rows","size","span"].forEach(function(_){z[_]=new v$2(_,6,!1,_,null,!1,!1)});["rowSpan","start"].forEach(function(_){z[_]=new v$2(_,5,!1,_.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(_){return _[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(_){var j=_.replace(ra,sa);z[j]=new v$2(j,1,!1,_,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(_){var j=_.replace(ra,sa);z[j]=new v$2(j,1,!1,_,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(_){var j=_.replace(ra,sa);z[j]=new v$2(j,1,!1,_,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(_){z[_]=new v$2(_,1,!1,_.toLowerCase(),null,!1,!1)});z.xlinkHref=new v$2("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(_){z[_]=new v$2(_,1,!1,_.toLowerCase(),null,!0,!0)});function ta(_,j,$,_e){var et=z.hasOwnProperty(j)?z[j]:null;(et!==null?et.type!==0:_e||!(2<j.length)||j[0]!=="o"&&j[0]!=="O"||j[1]!=="n"&&j[1]!=="N")&&(qa(j,$,et,_e)&&($=null),_e||et===null?oa(j)&&($===null?_.removeAttribute(j):_.setAttribute(j,""+$)):et.mustUseProperty?_[et.propertyName]=$===null?et.type===3?!1:"":$:(j=et.attributeName,_e=et.attributeNamespace,$===null?_.removeAttribute(j):(et=et.type,$=et===3||et===4&&$===!0?"":""+$,_e?_.setAttributeNS(_e,j,$):_.setAttribute(j,$))))}var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy"),Ia=Symbol.for("react.offscreen"),Ja=Symbol.iterator;function Ka(_){return _===null||typeof _!="object"?null:(_=Ja&&_[Ja]||_["@@iterator"],typeof _=="function"?_:null)}var A=Object.assign,La;function Ma(_){if(La===void 0)try{throw Error()}catch($){var j=$.stack.trim().match(/\n( *(at )?)/);La=j&&j[1]||""}return`
`+La+_}var Na=!1;function Oa(_,j){if(!_||Na)return"";Na=!0;var $=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(j)if(j=function(){throw Error()},Object.defineProperty(j.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(j,[])}catch(it){var _e=it}Reflect.construct(_,[],j)}else{try{j.call()}catch(it){_e=it}_.call(j.prototype)}else{try{throw Error()}catch(it){_e=it}_()}}catch(it){if(it&&_e&&typeof it.stack=="string"){for(var et=it.stack.split(`
`),tt=_e.stack.split(`
`),nt=et.length-1,rt=tt.length-1;1<=nt&&0<=rt&&et[nt]!==tt[rt];)rt--;for(;1<=nt&&0<=rt;nt--,rt--)if(et[nt]!==tt[rt]){if(nt!==1||rt!==1)do if(nt--,rt--,0>rt||et[nt]!==tt[rt]){var at=`
`+et[nt].replace(" at new "," at ");return _.displayName&&at.includes("<anonymous>")&&(at=at.replace("<anonymous>",_.displayName)),at}while(1<=nt&&0<=rt);break}}}finally{Na=!1,Error.prepareStackTrace=$}return(_=_?_.displayName||_.name:"")?Ma(_):""}function Pa(_){switch(_.tag){case 5:return Ma(_.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return _=Oa(_.type,!1),_;case 11:return _=Oa(_.type.render,!1),_;case 1:return _=Oa(_.type,!0),_;default:return""}}function Qa(_){if(_==null)return null;if(typeof _=="function")return _.displayName||_.name||null;if(typeof _=="string")return _;switch(_){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if(typeof _=="object")switch(_.$$typeof){case Ca:return(_.displayName||"Context")+".Consumer";case Ba:return(_._context.displayName||"Context")+".Provider";case Da:var j=_.render;return _=_.displayName,_||(_=j.displayName||j.name||"",_=_!==""?"ForwardRef("+_+")":"ForwardRef"),_;case Ga:return j=_.displayName||null,j!==null?j:Qa(_.type)||"Memo";case Ha:j=_._payload,_=_._init;try{return Qa(_(j))}catch{}}return null}function Ra(_){var j=_.type;switch(_.tag){case 24:return"Cache";case 9:return(j.displayName||"Context")+".Consumer";case 10:return(j._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return _=j.render,_=_.displayName||_.name||"",j.displayName||(_!==""?"ForwardRef("+_+")":"ForwardRef");case 7:return"Fragment";case 5:return j;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(j);case 8:return j===za?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof j=="function")return j.displayName||j.name||null;if(typeof j=="string")return j}return null}function Sa(_){switch(typeof _){case"boolean":case"number":case"string":case"undefined":return _;case"object":return _;default:return""}}function Ta(_){var j=_.type;return(_=_.nodeName)&&_.toLowerCase()==="input"&&(j==="checkbox"||j==="radio")}function Ua(_){var j=Ta(_)?"checked":"value",$=Object.getOwnPropertyDescriptor(_.constructor.prototype,j),_e=""+_[j];if(!_.hasOwnProperty(j)&&typeof $<"u"&&typeof $.get=="function"&&typeof $.set=="function"){var et=$.get,tt=$.set;return Object.defineProperty(_,j,{configurable:!0,get:function(){return et.call(this)},set:function(nt){_e=""+nt,tt.call(this,nt)}}),Object.defineProperty(_,j,{enumerable:$.enumerable}),{getValue:function(){return _e},setValue:function(nt){_e=""+nt},stopTracking:function(){_._valueTracker=null,delete _[j]}}}}function Va(_){_._valueTracker||(_._valueTracker=Ua(_))}function Wa(_){if(!_)return!1;var j=_._valueTracker;if(!j)return!0;var $=j.getValue(),_e="";return _&&(_e=Ta(_)?_.checked?"true":"false":_.value),_=_e,_!==$?(j.setValue(_),!0):!1}function Xa(_){if(_=_||(typeof document<"u"?document:void 0),typeof _>"u")return null;try{return _.activeElement||_.body}catch{return _.body}}function Ya(_,j){var $=j.checked;return A({},j,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:$??_._wrapperState.initialChecked})}function Za(_,j){var $=j.defaultValue==null?"":j.defaultValue,_e=j.checked!=null?j.checked:j.defaultChecked;$=Sa(j.value!=null?j.value:$),_._wrapperState={initialChecked:_e,initialValue:$,controlled:j.type==="checkbox"||j.type==="radio"?j.checked!=null:j.value!=null}}function ab(_,j){j=j.checked,j!=null&&ta(_,"checked",j,!1)}function bb(_,j){ab(_,j);var $=Sa(j.value),_e=j.type;if($!=null)_e==="number"?($===0&&_.value===""||_.value!=$)&&(_.value=""+$):_.value!==""+$&&(_.value=""+$);else if(_e==="submit"||_e==="reset"){_.removeAttribute("value");return}j.hasOwnProperty("value")?cb(_,j.type,$):j.hasOwnProperty("defaultValue")&&cb(_,j.type,Sa(j.defaultValue)),j.checked==null&&j.defaultChecked!=null&&(_.defaultChecked=!!j.defaultChecked)}function db(_,j,$){if(j.hasOwnProperty("value")||j.hasOwnProperty("defaultValue")){var _e=j.type;if(!(_e!=="submit"&&_e!=="reset"||j.value!==void 0&&j.value!==null))return;j=""+_._wrapperState.initialValue,$||j===_.value||(_.value=j),_.defaultValue=j}$=_.name,$!==""&&(_.name=""),_.defaultChecked=!!_._wrapperState.initialChecked,$!==""&&(_.name=$)}function cb(_,j,$){(j!=="number"||Xa(_.ownerDocument)!==_)&&($==null?_.defaultValue=""+_._wrapperState.initialValue:_.defaultValue!==""+$&&(_.defaultValue=""+$))}var eb=Array.isArray;function fb(_,j,$,_e){if(_=_.options,j){j={};for(var et=0;et<$.length;et++)j["$"+$[et]]=!0;for($=0;$<_.length;$++)et=j.hasOwnProperty("$"+_[$].value),_[$].selected!==et&&(_[$].selected=et),et&&_e&&(_[$].defaultSelected=!0)}else{for($=""+Sa($),j=null,et=0;et<_.length;et++){if(_[et].value===$){_[et].selected=!0,_e&&(_[et].defaultSelected=!0);return}j!==null||_[et].disabled||(j=_[et])}j!==null&&(j.selected=!0)}}function gb(_,j){if(j.dangerouslySetInnerHTML!=null)throw Error(p$6(91));return A({},j,{value:void 0,defaultValue:void 0,children:""+_._wrapperState.initialValue})}function hb(_,j){var $=j.value;if($==null){if($=j.children,j=j.defaultValue,$!=null){if(j!=null)throw Error(p$6(92));if(eb($)){if(1<$.length)throw Error(p$6(93));$=$[0]}j=$}j==null&&(j=""),$=j}_._wrapperState={initialValue:Sa($)}}function ib(_,j){var $=Sa(j.value),_e=Sa(j.defaultValue);$!=null&&($=""+$,$!==_.value&&(_.value=$),j.defaultValue==null&&_.defaultValue!==$&&(_.defaultValue=$)),_e!=null&&(_.defaultValue=""+_e)}function jb(_){var j=_.textContent;j===_._wrapperState.initialValue&&j!==""&&j!==null&&(_.value=j)}function kb(_){switch(_){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb(_,j){return _==null||_==="http://www.w3.org/1999/xhtml"?kb(j):_==="http://www.w3.org/2000/svg"&&j==="foreignObject"?"http://www.w3.org/1999/xhtml":_}var mb,nb=function(_){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(j,$,_e,et){MSApp.execUnsafeLocalFunction(function(){return _(j,$,_e,et)})}:_}(function(_,j){if(_.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in _)_.innerHTML=j;else{for(mb=mb||document.createElement("div"),mb.innerHTML="<svg>"+j.valueOf().toString()+"</svg>",j=mb.firstChild;_.firstChild;)_.removeChild(_.firstChild);for(;j.firstChild;)_.appendChild(j.firstChild)}});function ob(_,j){if(j){var $=_.firstChild;if($&&$===_.lastChild&&$.nodeType===3){$.nodeValue=j;return}}_.textContent=j}var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(_){qb.forEach(function(j){j=j+_.charAt(0).toUpperCase()+_.substring(1),pb[j]=pb[_]})});function rb(_,j,$){return j==null||typeof j=="boolean"||j===""?"":$||typeof j!="number"||j===0||pb.hasOwnProperty(_)&&pb[_]?(""+j).trim():j+"px"}function sb(_,j){_=_.style;for(var $ in j)if(j.hasOwnProperty($)){var _e=$.indexOf("--")===0,et=rb($,j[$],_e);$==="float"&&($="cssFloat"),_e?_.setProperty($,et):_[$]=et}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub(_,j){if(j){if(tb[_]&&(j.children!=null||j.dangerouslySetInnerHTML!=null))throw Error(p$6(137,_));if(j.dangerouslySetInnerHTML!=null){if(j.children!=null)throw Error(p$6(60));if(typeof j.dangerouslySetInnerHTML!="object"||!("__html"in j.dangerouslySetInnerHTML))throw Error(p$6(61))}if(j.style!=null&&typeof j.style!="object")throw Error(p$6(62))}}function vb(_,j){if(_.indexOf("-")===-1)return typeof j.is=="string";switch(_){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb=null;function xb(_){return _=_.target||_.srcElement||window,_.correspondingUseElement&&(_=_.correspondingUseElement),_.nodeType===3?_.parentNode:_}var yb=null,zb=null,Ab=null;function Bb(_){if(_=Cb(_)){if(typeof yb!="function")throw Error(p$6(280));var j=_.stateNode;j&&(j=Db(j),yb(_.stateNode,_.type,j))}}function Eb(_){zb?Ab?Ab.push(_):Ab=[_]:zb=_}function Fb(){if(zb){var _=zb,j=Ab;if(Ab=zb=null,Bb(_),j)for(_=0;_<j.length;_++)Bb(j[_])}}function Gb(_,j){return _(j)}function Hb(){}var Ib=!1;function Jb(_,j,$){if(Ib)return _(j,$);Ib=!0;try{return Gb(_,j,$)}finally{Ib=!1,(zb!==null||Ab!==null)&&(Hb(),Fb())}}function Kb(_,j){var $=_.stateNode;if($===null)return null;var _e=Db($);if(_e===null)return null;$=_e[j];e:switch(j){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(_e=!_e.disabled)||(_=_.type,_e=!(_==="button"||_==="input"||_==="select"||_==="textarea")),_=!_e;break e;default:_=!1}if(_)return null;if($&&typeof $!="function")throw Error(p$6(231,j,typeof $));return $}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}}),window.addEventListener("test",Mb,Mb),window.removeEventListener("test",Mb,Mb)}catch{Lb=!1}function Nb(_,j,$,_e,et,tt,nt,rt,at){var it=Array.prototype.slice.call(arguments,3);try{j.apply($,it)}catch(ot){this.onError(ot)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(_){Ob=!0,Pb=_}};function Tb(_,j,$,_e,et,tt,nt,rt,at){Ob=!1,Pb=null,Nb.apply(Sb,arguments)}function Ub(_,j,$,_e,et,tt,nt,rt,at){if(Tb.apply(this,arguments),Ob){if(Ob){var it=Pb;Ob=!1,Pb=null}else throw Error(p$6(198));Qb||(Qb=!0,Rb=it)}}function Vb(_){var j=_,$=_;if(_.alternate)for(;j.return;)j=j.return;else{_=j;do j=_,j.flags&4098&&($=j.return),_=j.return;while(_)}return j.tag===3?$:null}function Wb(_){if(_.tag===13){var j=_.memoizedState;if(j===null&&(_=_.alternate,_!==null&&(j=_.memoizedState)),j!==null)return j.dehydrated}return null}function Xb(_){if(Vb(_)!==_)throw Error(p$6(188))}function Yb(_){var j=_.alternate;if(!j){if(j=Vb(_),j===null)throw Error(p$6(188));return j!==_?null:_}for(var $=_,_e=j;;){var et=$.return;if(et===null)break;var tt=et.alternate;if(tt===null){if(_e=et.return,_e!==null){$=_e;continue}break}if(et.child===tt.child){for(tt=et.child;tt;){if(tt===$)return Xb(et),_;if(tt===_e)return Xb(et),j;tt=tt.sibling}throw Error(p$6(188))}if($.return!==_e.return)$=et,_e=tt;else{for(var nt=!1,rt=et.child;rt;){if(rt===$){nt=!0,$=et,_e=tt;break}if(rt===_e){nt=!0,_e=et,$=tt;break}rt=rt.sibling}if(!nt){for(rt=tt.child;rt;){if(rt===$){nt=!0,$=tt,_e=et;break}if(rt===_e){nt=!0,_e=tt,$=et;break}rt=rt.sibling}if(!nt)throw Error(p$6(189))}}if($.alternate!==_e)throw Error(p$6(190))}if($.tag!==3)throw Error(p$6(188));return $.stateNode.current===$?_:j}function Zb(_){return _=Yb(_),_!==null?$b(_):null}function $b(_){if(_.tag===5||_.tag===6)return _;for(_=_.child;_!==null;){var j=$b(_);if(j!==null)return j;_=_.sibling}return null}var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(_){if(lc&&typeof lc.onCommitFiberRoot=="function")try{lc.onCommitFiberRoot(kc,_,void 0,(_.current.flags&128)===128)}catch{}}var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(_){return _>>>=0,_===0?32:31-(pc(_)/qc|0)|0}var rc=64,sc=4194304;function tc(_){switch(_&-_){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return _&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return _&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return _}}function uc(_,j){var $=_.pendingLanes;if($===0)return 0;var _e=0,et=_.suspendedLanes,tt=_.pingedLanes,nt=$&268435455;if(nt!==0){var rt=nt&~et;rt!==0?_e=tc(rt):(tt&=nt,tt!==0&&(_e=tc(tt)))}else nt=$&~et,nt!==0?_e=tc(nt):tt!==0&&(_e=tc(tt));if(_e===0)return 0;if(j!==0&&j!==_e&&!(j&et)&&(et=_e&-_e,tt=j&-j,et>=tt||et===16&&(tt&4194240)!==0))return j;if(_e&4&&(_e|=$&16),j=_.entangledLanes,j!==0)for(_=_.entanglements,j&=_e;0<j;)$=31-oc(j),et=1<<$,_e|=_[$],j&=~et;return _e}function vc(_,j){switch(_){case 1:case 2:case 4:return j+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return j+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc(_,j){for(var $=_.suspendedLanes,_e=_.pingedLanes,et=_.expirationTimes,tt=_.pendingLanes;0<tt;){var nt=31-oc(tt),rt=1<<nt,at=et[nt];at===-1?(!(rt&$)||rt&_e)&&(et[nt]=vc(rt,j)):at<=j&&(_.expiredLanes|=rt),tt&=~rt}}function xc(_){return _=_.pendingLanes&-1073741825,_!==0?_:_&1073741824?1073741824:0}function yc(){var _=rc;return rc<<=1,!(rc&4194240)&&(rc=64),_}function zc(_){for(var j=[],$=0;31>$;$++)j.push(_);return j}function Ac(_,j,$){_.pendingLanes|=j,j!==536870912&&(_.suspendedLanes=0,_.pingedLanes=0),_=_.eventTimes,j=31-oc(j),_[j]=$}function Bc(_,j){var $=_.pendingLanes&~j;_.pendingLanes=j,_.suspendedLanes=0,_.pingedLanes=0,_.expiredLanes&=j,_.mutableReadLanes&=j,_.entangledLanes&=j,j=_.entanglements;var _e=_.eventTimes;for(_=_.expirationTimes;0<$;){var et=31-oc($),tt=1<<et;j[et]=0,_e[et]=-1,_[et]=-1,$&=~tt}}function Cc(_,j){var $=_.entangledLanes|=j;for(_=_.entanglements;$;){var _e=31-oc($),et=1<<_e;et&j|_[_e]&j&&(_[_e]|=j),$&=~et}}var C$1=0;function Dc(_){return _&=-_,1<_?4<_?_&268435455?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc(_,j){switch(_){case"focusin":case"focusout":Lc=null;break;case"dragenter":case"dragleave":Mc=null;break;case"mouseover":case"mouseout":Nc=null;break;case"pointerover":case"pointerout":Oc.delete(j.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc.delete(j.pointerId)}}function Tc(_,j,$,_e,et,tt){return _===null||_.nativeEvent!==tt?(_={blockedOn:j,domEventName:$,eventSystemFlags:_e,nativeEvent:tt,targetContainers:[et]},j!==null&&(j=Cb(j),j!==null&&Fc(j)),_):(_.eventSystemFlags|=_e,j=_.targetContainers,et!==null&&j.indexOf(et)===-1&&j.push(et),_)}function Uc(_,j,$,_e,et){switch(j){case"focusin":return Lc=Tc(Lc,_,j,$,_e,et),!0;case"dragenter":return Mc=Tc(Mc,_,j,$,_e,et),!0;case"mouseover":return Nc=Tc(Nc,_,j,$,_e,et),!0;case"pointerover":var tt=et.pointerId;return Oc.set(tt,Tc(Oc.get(tt)||null,_,j,$,_e,et)),!0;case"gotpointercapture":return tt=et.pointerId,Pc.set(tt,Tc(Pc.get(tt)||null,_,j,$,_e,et)),!0}return!1}function Vc(_){var j=Wc(_.target);if(j!==null){var $=Vb(j);if($!==null){if(j=$.tag,j===13){if(j=Wb($),j!==null){_.blockedOn=j,Ic(_.priority,function(){Gc($)});return}}else if(j===3&&$.stateNode.current.memoizedState.isDehydrated){_.blockedOn=$.tag===3?$.stateNode.containerInfo:null;return}}}_.blockedOn=null}function Xc(_){if(_.blockedOn!==null)return!1;for(var j=_.targetContainers;0<j.length;){var $=Yc(_.domEventName,_.eventSystemFlags,j[0],_.nativeEvent);if($===null){$=_.nativeEvent;var _e=new $.constructor($.type,$);wb=_e,$.target.dispatchEvent(_e),wb=null}else return j=Cb($),j!==null&&Fc(j),_.blockedOn=$,!1;j.shift()}return!0}function Zc(_,j,$){Xc(_)&&$.delete(j)}function $c(){Jc=!1,Lc!==null&&Xc(Lc)&&(Lc=null),Mc!==null&&Xc(Mc)&&(Mc=null),Nc!==null&&Xc(Nc)&&(Nc=null),Oc.forEach(Zc),Pc.forEach(Zc)}function ad(_,j){_.blockedOn===j&&(_.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}function bd(_){function j(et){return ad(et,_)}if(0<Kc.length){ad(Kc[0],_);for(var $=1;$<Kc.length;$++){var _e=Kc[$];_e.blockedOn===_&&(_e.blockedOn=null)}}for(Lc!==null&&ad(Lc,_),Mc!==null&&ad(Mc,_),Nc!==null&&ad(Nc,_),Oc.forEach(j),Pc.forEach(j),$=0;$<Qc.length;$++)_e=Qc[$],_e.blockedOn===_&&(_e.blockedOn=null);for(;0<Qc.length&&($=Qc[0],$.blockedOn===null);)Vc($),$.blockedOn===null&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;function ed(_,j,$,_e){var et=C$1,tt=cd.transition;cd.transition=null;try{C$1=1,fd(_,j,$,_e)}finally{C$1=et,cd.transition=tt}}function gd(_,j,$,_e){var et=C$1,tt=cd.transition;cd.transition=null;try{C$1=4,fd(_,j,$,_e)}finally{C$1=et,cd.transition=tt}}function fd(_,j,$,_e){if(dd){var et=Yc(_,j,$,_e);if(et===null)hd(_,j,_e,id,$),Sc(_,_e);else if(Uc(et,_,j,$,_e))_e.stopPropagation();else if(Sc(_,_e),j&4&&-1<Rc.indexOf(_)){for(;et!==null;){var tt=Cb(et);if(tt!==null&&Ec(tt),tt=Yc(_,j,$,_e),tt===null&&hd(_,j,_e,id,$),tt===et)break;et=tt}et!==null&&_e.stopPropagation()}else hd(_,j,_e,null,$)}}var id=null;function Yc(_,j,$,_e){if(id=null,_=xb(_e),_=Wc(_),_!==null)if(j=Vb(_),j===null)_=null;else if($=j.tag,$===13){if(_=Wb(j),_!==null)return _;_=null}else if($===3){if(j.stateNode.current.memoizedState.isDehydrated)return j.tag===3?j.stateNode.containerInfo:null;_=null}else j!==_&&(_=null);return id=_,null}function jd(_){switch(_){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var _,j=ld,$=j.length,_e,et="value"in kd?kd.value:kd.textContent,tt=et.length;for(_=0;_<$&&j[_]===et[_];_++);var nt=$-_;for(_e=1;_e<=nt&&j[$-_e]===et[tt-_e];_e++);return md=et.slice(_,1<_e?1-_e:void 0)}function od(_){var j=_.keyCode;return"charCode"in _?(_=_.charCode,_===0&&j===13&&(_=13)):_=j,_===10&&(_=13),32<=_||_===13?_:0}function pd(){return!0}function qd(){return!1}function rd(_){function j($,_e,et,tt,nt){this._reactName=$,this._targetInst=et,this.type=_e,this.nativeEvent=tt,this.target=nt,this.currentTarget=null;for(var rt in _)_.hasOwnProperty(rt)&&($=_[rt],this[rt]=$?$(tt):tt[rt]);return this.isDefaultPrevented=(tt.defaultPrevented!=null?tt.defaultPrevented:tt.returnValue===!1)?pd:qd,this.isPropagationStopped=qd,this}return A(j.prototype,{preventDefault:function(){this.defaultPrevented=!0;var $=this.nativeEvent;$&&($.preventDefault?$.preventDefault():typeof $.returnValue!="unknown"&&($.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var $=this.nativeEvent;$&&($.stopPropagation?$.stopPropagation():typeof $.cancelBubble!="unknown"&&($.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd}),j}var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(_){return _.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(_){return _.relatedTarget===void 0?_.fromElement===_.srcElement?_.toElement:_.fromElement:_.relatedTarget},movementX:function(_){return"movementX"in _?_.movementX:(_!==yd&&(yd&&_.type==="mousemove"?(wd=_.screenX-yd.screenX,xd=_.screenY-yd.screenY):xd=wd=0,yd=_),wd)},movementY:function(_){return"movementY"in _?_.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(_){return"clipboardData"in _?_.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(_){var j=this.nativeEvent;return j.getModifierState?j.getModifierState(_):(_=Od[_])?!!j[_]:!1}function zd(){return Pd}var Qd=A({},ud,{key:function(_){if(_.key){var j=Md[_.key]||_.key;if(j!=="Unidentified")return j}return _.type==="keypress"?(_=od(_),_===13?"Enter":String.fromCharCode(_)):_.type==="keydown"||_.type==="keyup"?Nd[_.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(_){return _.type==="keypress"?od(_):0},keyCode:function(_){return _.type==="keydown"||_.type==="keyup"?_.keyCode:0},which:function(_){return _.type==="keypress"?od(_):_.type==="keydown"||_.type==="keyup"?_.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(_){return"deltaX"in _?_.deltaX:"wheelDeltaX"in _?-_.wheelDeltaX:0},deltaY:function(_){return"deltaY"in _?_.deltaY:"wheelDeltaY"in _?-_.wheelDeltaY:"wheelDelta"in _?-_.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=" ",fe=!1;function ge(_,j){switch(_){case"keyup":return $d.indexOf(j.keyCode)!==-1;case"keydown":return j.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he(_){return _=_.detail,typeof _=="object"&&"data"in _?_.data:null}var ie=!1;function je(_,j){switch(_){case"compositionend":return he(j);case"keypress":return j.which!==32?null:(fe=!0,ee);case"textInput":return _=j.data,_===ee&&fe?null:_;default:return null}}function ke(_,j){if(ie)return _==="compositionend"||!ae&&ge(_,j)?(_=nd(),md=ld=kd=null,ie=!1,_):null;switch(_){case"paste":return null;case"keypress":if(!(j.ctrlKey||j.altKey||j.metaKey)||j.ctrlKey&&j.altKey){if(j.char&&1<j.char.length)return j.char;if(j.which)return String.fromCharCode(j.which)}return null;case"compositionend":return de&&j.locale!=="ko"?null:j.data;default:return null}}var le$1={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(_){var j=_&&_.nodeName&&_.nodeName.toLowerCase();return j==="input"?!!le$1[_.type]:j==="textarea"}function ne(_,j,$,_e){Eb(_e),j=oe(j,"onChange"),0<j.length&&($=new td("onChange","change",null,$,_e),_.push({event:$,listeners:j}))}var pe$1=null,qe=null;function re(_){se(_,0)}function te(_){var j=ue(_);if(Wa(j))return _}function ve(_,j){if(_==="change")return j}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;"),ye=typeof ze.oninput=="function"}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe$1&&(pe$1.detachEvent("onpropertychange",Be),qe=pe$1=null)}function Be(_){if(_.propertyName==="value"&&te(qe)){var j=[];ne(j,qe,_,xb(_)),Jb(re,j)}}function Ce(_,j,$){_==="focusin"?(Ae(),pe$1=j,qe=$,pe$1.attachEvent("onpropertychange",Be)):_==="focusout"&&Ae()}function De(_){if(_==="selectionchange"||_==="keyup"||_==="keydown")return te(qe)}function Ee(_,j){if(_==="click")return te(j)}function Fe(_,j){if(_==="input"||_==="change")return te(j)}function Ge(_,j){return _===j&&(_!==0||1/_===1/j)||_!==_&&j!==j}var He=typeof Object.is=="function"?Object.is:Ge;function Ie(_,j){if(He(_,j))return!0;if(typeof _!="object"||_===null||typeof j!="object"||j===null)return!1;var $=Object.keys(_),_e=Object.keys(j);if($.length!==_e.length)return!1;for(_e=0;_e<$.length;_e++){var et=$[_e];if(!ja.call(j,et)||!He(_[et],j[et]))return!1}return!0}function Je(_){for(;_&&_.firstChild;)_=_.firstChild;return _}function Ke(_,j){var $=Je(_);_=0;for(var _e;$;){if($.nodeType===3){if(_e=_+$.textContent.length,_<=j&&_e>=j)return{node:$,offset:j-_};_=_e}e:{for(;$;){if($.nextSibling){$=$.nextSibling;break e}$=$.parentNode}$=void 0}$=Je($)}}function Le(_,j){return _&&j?_===j?!0:_&&_.nodeType===3?!1:j&&j.nodeType===3?Le(_,j.parentNode):"contains"in _?_.contains(j):_.compareDocumentPosition?!!(_.compareDocumentPosition(j)&16):!1:!1}function Me(){for(var _=window,j=Xa();j instanceof _.HTMLIFrameElement;){try{var $=typeof j.contentWindow.location.href=="string"}catch{$=!1}if($)_=j.contentWindow;else break;j=Xa(_.document)}return j}function Ne(_){var j=_&&_.nodeName&&_.nodeName.toLowerCase();return j&&(j==="input"&&(_.type==="text"||_.type==="search"||_.type==="tel"||_.type==="url"||_.type==="password")||j==="textarea"||_.contentEditable==="true")}function Oe(_){var j=Me(),$=_.focusedElem,_e=_.selectionRange;if(j!==$&&$&&$.ownerDocument&&Le($.ownerDocument.documentElement,$)){if(_e!==null&&Ne($)){if(j=_e.start,_=_e.end,_===void 0&&(_=j),"selectionStart"in $)$.selectionStart=j,$.selectionEnd=Math.min(_,$.value.length);else if(_=(j=$.ownerDocument||document)&&j.defaultView||window,_.getSelection){_=_.getSelection();var et=$.textContent.length,tt=Math.min(_e.start,et);_e=_e.end===void 0?tt:Math.min(_e.end,et),!_.extend&&tt>_e&&(et=_e,_e=tt,tt=et),et=Ke($,tt);var nt=Ke($,_e);et&&nt&&(_.rangeCount!==1||_.anchorNode!==et.node||_.anchorOffset!==et.offset||_.focusNode!==nt.node||_.focusOffset!==nt.offset)&&(j=j.createRange(),j.setStart(et.node,et.offset),_.removeAllRanges(),tt>_e?(_.addRange(j),_.extend(nt.node,nt.offset)):(j.setEnd(nt.node,nt.offset),_.addRange(j)))}}for(j=[],_=$;_=_.parentNode;)_.nodeType===1&&j.push({element:_,left:_.scrollLeft,top:_.scrollTop});for(typeof $.focus=="function"&&$.focus(),$=0;$<j.length;$++)_=j[$],_.element.scrollLeft=_.left,_.element.scrollTop=_.top}}var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se$1=null,Te=!1;function Ue(_,j,$){var _e=$.window===$?$.document:$.nodeType===9?$:$.ownerDocument;Te||Qe==null||Qe!==Xa(_e)||(_e=Qe,"selectionStart"in _e&&Ne(_e)?_e={start:_e.selectionStart,end:_e.selectionEnd}:(_e=(_e.ownerDocument&&_e.ownerDocument.defaultView||window).getSelection(),_e={anchorNode:_e.anchorNode,anchorOffset:_e.anchorOffset,focusNode:_e.focusNode,focusOffset:_e.focusOffset}),Se$1&&Ie(Se$1,_e)||(Se$1=_e,_e=oe(Re,"onSelect"),0<_e.length&&(j=new td("onSelect","select",null,j,$),_.push({event:j,listeners:_e}),j.target=Qe)))}function Ve(_,j){var $={};return $[_.toLowerCase()]=j.toLowerCase(),$["Webkit"+_]="webkit"+j,$["Moz"+_]="moz"+j,$}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(_){if(Xe[_])return Xe[_];if(!We[_])return _;var j=We[_],$;for($ in j)if(j.hasOwnProperty($)&&$ in Ye)return Xe[_]=j[$];return _}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff(_,j){df.set(_,j),fa(j,[_])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));function nf(_,j,$){var _e=_.type||"unknown-event";_.currentTarget=$,Ub(_e,j,void 0,_),_.currentTarget=null}function se(_,j){j=(j&4)!==0;for(var $=0;$<_.length;$++){var _e=_[$],et=_e.event;_e=_e.listeners;e:{var tt=void 0;if(j)for(var nt=_e.length-1;0<=nt;nt--){var rt=_e[nt],at=rt.instance,it=rt.currentTarget;if(rt=rt.listener,at!==tt&&et.isPropagationStopped())break e;nf(et,rt,it),tt=at}else for(nt=0;nt<_e.length;nt++){if(rt=_e[nt],at=rt.instance,it=rt.currentTarget,rt=rt.listener,at!==tt&&et.isPropagationStopped())break e;nf(et,rt,it),tt=at}}}if(Qb)throw _=Rb,Qb=!1,Rb=null,_}function D$1(_,j){var $=j[of];$===void 0&&($=j[of]=new Set);var _e=_+"__bubble";$.has(_e)||(pf(j,_,2,!1),$.add(_e))}function qf(_,j,$){var _e=0;j&&(_e|=4),pf($,_,_e,j)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(_){if(!_[rf]){_[rf]=!0,da.forEach(function($){$!=="selectionchange"&&(mf.has($)||qf($,!1,_),qf($,!0,_))});var j=_.nodeType===9?_:_.ownerDocument;j===null||j[rf]||(j[rf]=!0,qf("selectionchange",!1,j))}}function pf(_,j,$,_e){switch(jd(j)){case 1:var et=ed;break;case 4:et=gd;break;default:et=fd}$=et.bind(null,j,$,_),et=void 0,!Lb||j!=="touchstart"&&j!=="touchmove"&&j!=="wheel"||(et=!0),_e?et!==void 0?_.addEventListener(j,$,{capture:!0,passive:et}):_.addEventListener(j,$,!0):et!==void 0?_.addEventListener(j,$,{passive:et}):_.addEventListener(j,$,!1)}function hd(_,j,$,_e,et){var tt=_e;if(!(j&1)&&!(j&2)&&_e!==null)e:for(;;){if(_e===null)return;var nt=_e.tag;if(nt===3||nt===4){var rt=_e.stateNode.containerInfo;if(rt===et||rt.nodeType===8&&rt.parentNode===et)break;if(nt===4)for(nt=_e.return;nt!==null;){var at=nt.tag;if((at===3||at===4)&&(at=nt.stateNode.containerInfo,at===et||at.nodeType===8&&at.parentNode===et))return;nt=nt.return}for(;rt!==null;){if(nt=Wc(rt),nt===null)return;if(at=nt.tag,at===5||at===6){_e=tt=nt;continue e}rt=rt.parentNode}}_e=_e.return}Jb(function(){var it=tt,ot=xb($),st=[];e:{var ct=df.get(_);if(ct!==void 0){var pt=td,dt=_;switch(_){case"keypress":if(od($)===0)break e;case"keydown":case"keyup":pt=Rd;break;case"focusin":dt="focus",pt=Fd;break;case"focusout":dt="blur",pt=Fd;break;case"beforeblur":case"afterblur":pt=Fd;break;case"click":if($.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":pt=Bd;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":pt=Dd;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":pt=Vd;break;case $e:case af:case bf:pt=Hd;break;case cf:pt=Xd;break;case"scroll":pt=vd;break;case"wheel":pt=Zd;break;case"copy":case"cut":case"paste":pt=Jd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":pt=Td}var ft=(j&4)!==0,gt=!ft&&_==="scroll",ut=ft?ct!==null?ct+"Capture":null:ct;ft=[];for(var lt=it,ht;lt!==null;){ht=lt;var yt=ht.stateNode;if(ht.tag===5&&yt!==null&&(ht=yt,ut!==null&&(yt=Kb(lt,ut),yt!=null&&ft.push(tf(lt,yt,ht)))),gt)break;lt=lt.return}0<ft.length&&(ct=new pt(ct,dt,null,$,ot),st.push({event:ct,listeners:ft}))}}if(!(j&7)){e:{if(ct=_==="mouseover"||_==="pointerover",pt=_==="mouseout"||_==="pointerout",ct&&$!==wb&&(dt=$.relatedTarget||$.fromElement)&&(Wc(dt)||dt[uf]))break e;if((pt||ct)&&(ct=ot.window===ot?ot:(ct=ot.ownerDocument)?ct.defaultView||ct.parentWindow:window,pt?(dt=$.relatedTarget||$.toElement,pt=it,dt=dt?Wc(dt):null,dt!==null&&(gt=Vb(dt),dt!==gt||dt.tag!==5&&dt.tag!==6)&&(dt=null)):(pt=null,dt=it),pt!==dt)){if(ft=Bd,yt="onMouseLeave",ut="onMouseEnter",lt="mouse",(_==="pointerout"||_==="pointerover")&&(ft=Td,yt="onPointerLeave",ut="onPointerEnter",lt="pointer"),gt=pt==null?ct:ue(pt),ht=dt==null?ct:ue(dt),ct=new ft(yt,lt+"leave",pt,$,ot),ct.target=gt,ct.relatedTarget=ht,yt=null,Wc(ot)===it&&(ft=new ft(ut,lt+"enter",dt,$,ot),ft.target=ht,ft.relatedTarget=gt,yt=ft),gt=yt,pt&&dt)t:{for(ft=pt,ut=dt,lt=0,ht=ft;ht;ht=vf(ht))lt++;for(ht=0,yt=ut;yt;yt=vf(yt))ht++;for(;0<lt-ht;)ft=vf(ft),lt--;for(;0<ht-lt;)ut=vf(ut),ht--;for(;lt--;){if(ft===ut||ut!==null&&ft===ut.alternate)break t;ft=vf(ft),ut=vf(ut)}ft=null}else ft=null;pt!==null&&wf(st,ct,pt,ft,!1),dt!==null&&gt!==null&&wf(st,gt,dt,ft,!0)}}e:{if(ct=it?ue(it):window,pt=ct.nodeName&&ct.nodeName.toLowerCase(),pt==="select"||pt==="input"&&ct.type==="file")var vt=ve;else if(me(ct))if(we)vt=Fe;else{vt=De;var bt=Ce}else(pt=ct.nodeName)&&pt.toLowerCase()==="input"&&(ct.type==="checkbox"||ct.type==="radio")&&(vt=Ee);if(vt&&(vt=vt(_,it))){ne(st,vt,$,ot);break e}bt&&bt(_,ct,it),_==="focusout"&&(bt=ct._wrapperState)&&bt.controlled&&ct.type==="number"&&cb(ct,"number",ct.value)}switch(bt=it?ue(it):window,_){case"focusin":(me(bt)||bt.contentEditable==="true")&&(Qe=bt,Re=it,Se$1=null);break;case"focusout":Se$1=Re=Qe=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue(st,$,ot);break;case"selectionchange":if(Pe)break;case"keydown":case"keyup":Ue(st,$,ot)}var mt;if(ae)e:{switch(_){case"compositionstart":var _t="onCompositionStart";break e;case"compositionend":_t="onCompositionEnd";break e;case"compositionupdate":_t="onCompositionUpdate";break e}_t=void 0}else ie?ge(_,$)&&(_t="onCompositionEnd"):_==="keydown"&&$.keyCode===229&&(_t="onCompositionStart");_t&&(de&&$.locale!=="ko"&&(ie||_t!=="onCompositionStart"?_t==="onCompositionEnd"&&ie&&(mt=nd()):(kd=ot,ld="value"in kd?kd.value:kd.textContent,ie=!0)),bt=oe(it,_t),0<bt.length&&(_t=new Ld(_t,_,null,$,ot),st.push({event:_t,listeners:bt}),mt?_t.data=mt:(mt=he($),mt!==null&&(_t.data=mt)))),(mt=ce?je(_,$):ke(_,$))&&(it=oe(it,"onBeforeInput"),0<it.length&&(ot=new Ld("onBeforeInput","beforeinput",null,$,ot),st.push({event:ot,listeners:it}),ot.data=mt))}se(st,j)})}function tf(_,j,$){return{instance:_,listener:j,currentTarget:$}}function oe(_,j){for(var $=j+"Capture",_e=[];_!==null;){var et=_,tt=et.stateNode;et.tag===5&&tt!==null&&(et=tt,tt=Kb(_,$),tt!=null&&_e.unshift(tf(_,tt,et)),tt=Kb(_,j),tt!=null&&_e.push(tf(_,tt,et))),_=_.return}return _e}function vf(_){if(_===null)return null;do _=_.return;while(_&&_.tag!==5);return _||null}function wf(_,j,$,_e,et){for(var tt=j._reactName,nt=[];$!==null&&$!==_e;){var rt=$,at=rt.alternate,it=rt.stateNode;if(at!==null&&at===_e)break;rt.tag===5&&it!==null&&(rt=it,et?(at=Kb($,tt),at!=null&&nt.unshift(tf($,at,rt))):et||(at=Kb($,tt),at!=null&&nt.push(tf($,at,rt)))),$=$.return}nt.length!==0&&_.push({event:j,listeners:nt})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(_){return(typeof _=="string"?_:""+_).replace(xf,`
`).replace(yf,"")}function Af(_,j,$){if(j=zf(j),zf(_)!==j&&$)throw Error(p$6(425))}function Bf(){}var Cf=null,Df=null;function Ef(_,j){return _==="textarea"||_==="noscript"||typeof j.children=="string"||typeof j.children=="number"||typeof j.dangerouslySetInnerHTML=="object"&&j.dangerouslySetInnerHTML!==null&&j.dangerouslySetInnerHTML.__html!=null}var Ff=typeof setTimeout=="function"?setTimeout:void 0,Gf=typeof clearTimeout=="function"?clearTimeout:void 0,Hf=typeof Promise=="function"?Promise:void 0,Jf=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf<"u"?function(_){return Hf.resolve(null).then(_).catch(If)}:Ff;function If(_){setTimeout(function(){throw _})}function Kf(_,j){var $=j,_e=0;do{var et=$.nextSibling;if(_.removeChild($),et&&et.nodeType===8)if($=et.data,$==="/$"){if(_e===0){_.removeChild(et),bd(j);return}_e--}else $!=="$"&&$!=="$?"&&$!=="$!"||_e++;$=et}while($);bd(j)}function Lf(_){for(;_!=null;_=_.nextSibling){var j=_.nodeType;if(j===1||j===3)break;if(j===8){if(j=_.data,j==="$"||j==="$!"||j==="$?")break;if(j==="/$")return null}}return _}function Mf(_){_=_.previousSibling;for(var j=0;_;){if(_.nodeType===8){var $=_.data;if($==="$"||$==="$!"||$==="$?"){if(j===0)return _;j--}else $==="/$"&&j++}_=_.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;function Wc(_){var j=_[Of];if(j)return j;for(var $=_.parentNode;$;){if(j=$[uf]||$[Of]){if($=j.alternate,j.child!==null||$!==null&&$.child!==null)for(_=Mf(_);_!==null;){if($=_[Of])return $;_=Mf(_)}return j}_=$,$=_.parentNode}return null}function Cb(_){return _=_[Of]||_[uf],!_||_.tag!==5&&_.tag!==6&&_.tag!==13&&_.tag!==3?null:_}function ue(_){if(_.tag===5||_.tag===6)return _.stateNode;throw Error(p$6(33))}function Db(_){return _[Pf]||null}var Sf=[],Tf=-1;function Uf(_){return{current:_}}function E$2(_){0>Tf||(_.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(_,j){Tf++,Sf[Tf]=_.current,_.current=j}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(_,j){var $=_.type.contextTypes;if(!$)return Vf;var _e=_.stateNode;if(_e&&_e.__reactInternalMemoizedUnmaskedChildContext===j)return _e.__reactInternalMemoizedMaskedChildContext;var et={},tt;for(tt in $)et[tt]=j[tt];return _e&&(_=_.stateNode,_.__reactInternalMemoizedUnmaskedChildContext=j,_.__reactInternalMemoizedMaskedChildContext=et),et}function Zf(_){return _=_.childContextTypes,_!=null}function $f(){E$2(Wf),E$2(H)}function ag(_,j,$){if(H.current!==Vf)throw Error(p$6(168));G(H,j),G(Wf,$)}function bg(_,j,$){var _e=_.stateNode;if(j=j.childContextTypes,typeof _e.getChildContext!="function")return $;_e=_e.getChildContext();for(var et in _e)if(!(et in j))throw Error(p$6(108,Ra(_)||"Unknown",et));return A({},$,_e)}function cg(_){return _=(_=_.stateNode)&&_.__reactInternalMemoizedMergedChildContext||Vf,Xf=H.current,G(H,_),G(Wf,Wf.current),!0}function dg(_,j,$){var _e=_.stateNode;if(!_e)throw Error(p$6(169));$?(_=bg(_,j,Xf),_e.__reactInternalMemoizedMergedChildContext=_,E$2(Wf),E$2(H),G(H,_)):E$2(Wf),G(Wf,$)}var eg=null,fg=!1,gg=!1;function hg(_){eg===null?eg=[_]:eg.push(_)}function ig(_){fg=!0,hg(_)}function jg(){if(!gg&&eg!==null){gg=!0;var _=0,j=C$1;try{var $=eg;for(C$1=1;_<$.length;_++){var _e=$[_];do _e=_e(!0);while(_e!==null)}eg=null,fg=!1}catch(et){throw eg!==null&&(eg=eg.slice(_+1)),ac(fc,jg),et}finally{C$1=j,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(_,j){kg[lg++]=ng,kg[lg++]=mg,mg=_,ng=j}function ug(_,j,$){og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,qg=_;var _e=rg;_=sg;var et=32-oc(_e)-1;_e&=~(1<<et),$+=1;var tt=32-oc(j)+et;if(30<tt){var nt=et-et%5;tt=(_e&(1<<nt)-1).toString(32),_e>>=nt,et-=nt,rg=1<<32-oc(j)+et|$<<et|_e,sg=tt+_}else rg=1<<tt|$<<et|_e,sg=_}function vg(_){_.return!==null&&(tg(_,1),ug(_,1,0))}function wg(_){for(;_===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;_===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;function Ag(_,j){var $=Bg(5,null,null,0);$.elementType="DELETED",$.stateNode=j,$.return=_,j=_.deletions,j===null?(_.deletions=[$],_.flags|=16):j.push($)}function Cg(_,j){switch(_.tag){case 5:var $=_.type;return j=j.nodeType!==1||$.toLowerCase()!==j.nodeName.toLowerCase()?null:j,j!==null?(_.stateNode=j,xg=_,yg=Lf(j.firstChild),!0):!1;case 6:return j=_.pendingProps===""||j.nodeType!==3?null:j,j!==null?(_.stateNode=j,xg=_,yg=null,!0):!1;case 13:return j=j.nodeType!==8?null:j,j!==null?($=qg!==null?{id:rg,overflow:sg}:null,_.memoizedState={dehydrated:j,treeContext:$,retryLane:1073741824},$=Bg(18,null,null,0),$.stateNode=j,$.return=_,_.child=$,xg=_,yg=null,!0):!1;default:return!1}}function Dg(_){return(_.mode&1)!==0&&(_.flags&128)===0}function Eg(_){if(I){var j=yg;if(j){var $=j;if(!Cg(_,j)){if(Dg(_))throw Error(p$6(418));j=Lf($.nextSibling);var _e=xg;j&&Cg(_,j)?Ag(_e,$):(_.flags=_.flags&-4097|2,I=!1,xg=_)}}else{if(Dg(_))throw Error(p$6(418));_.flags=_.flags&-4097|2,I=!1,xg=_}}}function Fg(_){for(_=_.return;_!==null&&_.tag!==5&&_.tag!==3&&_.tag!==13;)_=_.return;xg=_}function Gg(_){if(_!==xg)return!1;if(!I)return Fg(_),I=!0,!1;var j;if((j=_.tag!==3)&&!(j=_.tag!==5)&&(j=_.type,j=j!=="head"&&j!=="body"&&!Ef(_.type,_.memoizedProps)),j&&(j=yg)){if(Dg(_))throw Hg(),Error(p$6(418));for(;j;)Ag(_,j),j=Lf(j.nextSibling)}if(Fg(_),_.tag===13){if(_=_.memoizedState,_=_!==null?_.dehydrated:null,!_)throw Error(p$6(317));e:{for(_=_.nextSibling,j=0;_;){if(_.nodeType===8){var $=_.data;if($==="/$"){if(j===0){yg=Lf(_.nextSibling);break e}j--}else $!=="$"&&$!=="$!"&&$!=="$?"||j++}_=_.nextSibling}yg=null}}else yg=xg?Lf(_.stateNode.nextSibling):null;return!0}function Hg(){for(var _=yg;_;)_=Lf(_.nextSibling)}function Ig(){yg=xg=null,I=!1}function Jg(_){zg===null?zg=[_]:zg.push(_)}var Kg=ua.ReactCurrentBatchConfig;function Lg(_,j,$){if(_=$.ref,_!==null&&typeof _!="function"&&typeof _!="object"){if($._owner){if($=$._owner,$){if($.tag!==1)throw Error(p$6(309));var _e=$.stateNode}if(!_e)throw Error(p$6(147,_));var et=_e,tt=""+_;return j!==null&&j.ref!==null&&typeof j.ref=="function"&&j.ref._stringRef===tt?j.ref:(j=function(nt){var rt=et.refs;nt===null?delete rt[tt]:rt[tt]=nt},j._stringRef=tt,j)}if(typeof _!="string")throw Error(p$6(284));if(!$._owner)throw Error(p$6(290,_))}return _}function Mg(_,j){throw _=Object.prototype.toString.call(j),Error(p$6(31,_==="[object Object]"?"object with keys {"+Object.keys(j).join(", ")+"}":_))}function Ng(_){var j=_._init;return j(_._payload)}function Og(_){function j(ut,lt){if(_){var ht=ut.deletions;ht===null?(ut.deletions=[lt],ut.flags|=16):ht.push(lt)}}function $(ut,lt){if(!_)return null;for(;lt!==null;)j(ut,lt),lt=lt.sibling;return null}function _e(ut,lt){for(ut=new Map;lt!==null;)lt.key!==null?ut.set(lt.key,lt):ut.set(lt.index,lt),lt=lt.sibling;return ut}function et(ut,lt){return ut=Pg(ut,lt),ut.index=0,ut.sibling=null,ut}function tt(ut,lt,ht){return ut.index=ht,_?(ht=ut.alternate,ht!==null?(ht=ht.index,ht<lt?(ut.flags|=2,lt):ht):(ut.flags|=2,lt)):(ut.flags|=1048576,lt)}function nt(ut){return _&&ut.alternate===null&&(ut.flags|=2),ut}function rt(ut,lt,ht,yt){return lt===null||lt.tag!==6?(lt=Qg(ht,ut.mode,yt),lt.return=ut,lt):(lt=et(lt,ht),lt.return=ut,lt)}function at(ut,lt,ht,yt){var vt=ht.type;return vt===ya?ot(ut,lt,ht.props.children,yt,ht.key):lt!==null&&(lt.elementType===vt||typeof vt=="object"&&vt!==null&&vt.$$typeof===Ha&&Ng(vt)===lt.type)?(yt=et(lt,ht.props),yt.ref=Lg(ut,lt,ht),yt.return=ut,yt):(yt=Rg(ht.type,ht.key,ht.props,null,ut.mode,yt),yt.ref=Lg(ut,lt,ht),yt.return=ut,yt)}function it(ut,lt,ht,yt){return lt===null||lt.tag!==4||lt.stateNode.containerInfo!==ht.containerInfo||lt.stateNode.implementation!==ht.implementation?(lt=Sg(ht,ut.mode,yt),lt.return=ut,lt):(lt=et(lt,ht.children||[]),lt.return=ut,lt)}function ot(ut,lt,ht,yt,vt){return lt===null||lt.tag!==7?(lt=Tg(ht,ut.mode,yt,vt),lt.return=ut,lt):(lt=et(lt,ht),lt.return=ut,lt)}function st(ut,lt,ht){if(typeof lt=="string"&&lt!==""||typeof lt=="number")return lt=Qg(""+lt,ut.mode,ht),lt.return=ut,lt;if(typeof lt=="object"&&lt!==null){switch(lt.$$typeof){case va:return ht=Rg(lt.type,lt.key,lt.props,null,ut.mode,ht),ht.ref=Lg(ut,null,lt),ht.return=ut,ht;case wa:return lt=Sg(lt,ut.mode,ht),lt.return=ut,lt;case Ha:var yt=lt._init;return st(ut,yt(lt._payload),ht)}if(eb(lt)||Ka(lt))return lt=Tg(lt,ut.mode,ht,null),lt.return=ut,lt;Mg(ut,lt)}return null}function ct(ut,lt,ht,yt){var vt=lt!==null?lt.key:null;if(typeof ht=="string"&&ht!==""||typeof ht=="number")return vt!==null?null:rt(ut,lt,""+ht,yt);if(typeof ht=="object"&&ht!==null){switch(ht.$$typeof){case va:return ht.key===vt?at(ut,lt,ht,yt):null;case wa:return ht.key===vt?it(ut,lt,ht,yt):null;case Ha:return vt=ht._init,ct(ut,lt,vt(ht._payload),yt)}if(eb(ht)||Ka(ht))return vt!==null?null:ot(ut,lt,ht,yt,null);Mg(ut,ht)}return null}function pt(ut,lt,ht,yt,vt){if(typeof yt=="string"&&yt!==""||typeof yt=="number")return ut=ut.get(ht)||null,rt(lt,ut,""+yt,vt);if(typeof yt=="object"&&yt!==null){switch(yt.$$typeof){case va:return ut=ut.get(yt.key===null?ht:yt.key)||null,at(lt,ut,yt,vt);case wa:return ut=ut.get(yt.key===null?ht:yt.key)||null,it(lt,ut,yt,vt);case Ha:var bt=yt._init;return pt(ut,lt,ht,bt(yt._payload),vt)}if(eb(yt)||Ka(yt))return ut=ut.get(ht)||null,ot(lt,ut,yt,vt,null);Mg(lt,yt)}return null}function dt(ut,lt,ht,yt){for(var vt=null,bt=null,mt=lt,_t=lt=0,Et=null;mt!==null&&_t<ht.length;_t++){mt.index>_t?(Et=mt,mt=null):Et=mt.sibling;var wt=ct(ut,mt,ht[_t],yt);if(wt===null){mt===null&&(mt=Et);break}_&&mt&&wt.alternate===null&&j(ut,mt),lt=tt(wt,lt,_t),bt===null?vt=wt:bt.sibling=wt,bt=wt,mt=Et}if(_t===ht.length)return $(ut,mt),I&&tg(ut,_t),vt;if(mt===null){for(;_t<ht.length;_t++)mt=st(ut,ht[_t],yt),mt!==null&&(lt=tt(mt,lt,_t),bt===null?vt=mt:bt.sibling=mt,bt=mt);return I&&tg(ut,_t),vt}for(mt=_e(ut,mt);_t<ht.length;_t++)Et=pt(mt,ut,_t,ht[_t],yt),Et!==null&&(_&&Et.alternate!==null&&mt.delete(Et.key===null?_t:Et.key),lt=tt(Et,lt,_t),bt===null?vt=Et:bt.sibling=Et,bt=Et);return _&&mt.forEach(function(St){return j(ut,St)}),I&&tg(ut,_t),vt}function ft(ut,lt,ht,yt){var vt=Ka(ht);if(typeof vt!="function")throw Error(p$6(150));if(ht=vt.call(ht),ht==null)throw Error(p$6(151));for(var bt=vt=null,mt=lt,_t=lt=0,Et=null,wt=ht.next();mt!==null&&!wt.done;_t++,wt=ht.next()){mt.index>_t?(Et=mt,mt=null):Et=mt.sibling;var St=ct(ut,mt,wt.value,yt);if(St===null){mt===null&&(mt=Et);break}_&&mt&&St.alternate===null&&j(ut,mt),lt=tt(St,lt,_t),bt===null?vt=St:bt.sibling=St,bt=St,mt=Et}if(wt.done)return $(ut,mt),I&&tg(ut,_t),vt;if(mt===null){for(;!wt.done;_t++,wt=ht.next())wt=st(ut,wt.value,yt),wt!==null&&(lt=tt(wt,lt,_t),bt===null?vt=wt:bt.sibling=wt,bt=wt);return I&&tg(ut,_t),vt}for(mt=_e(ut,mt);!wt.done;_t++,wt=ht.next())wt=pt(mt,ut,_t,wt.value,yt),wt!==null&&(_&&wt.alternate!==null&&mt.delete(wt.key===null?_t:wt.key),lt=tt(wt,lt,_t),bt===null?vt=wt:bt.sibling=wt,bt=wt);return _&&mt.forEach(function(Tt){return j(ut,Tt)}),I&&tg(ut,_t),vt}function gt(ut,lt,ht,yt){if(typeof ht=="object"&&ht!==null&&ht.type===ya&&ht.key===null&&(ht=ht.props.children),typeof ht=="object"&&ht!==null){switch(ht.$$typeof){case va:e:{for(var vt=ht.key,bt=lt;bt!==null;){if(bt.key===vt){if(vt=ht.type,vt===ya){if(bt.tag===7){$(ut,bt.sibling),lt=et(bt,ht.props.children),lt.return=ut,ut=lt;break e}}else if(bt.elementType===vt||typeof vt=="object"&&vt!==null&&vt.$$typeof===Ha&&Ng(vt)===bt.type){$(ut,bt.sibling),lt=et(bt,ht.props),lt.ref=Lg(ut,bt,ht),lt.return=ut,ut=lt;break e}$(ut,bt);break}else j(ut,bt);bt=bt.sibling}ht.type===ya?(lt=Tg(ht.props.children,ut.mode,yt,ht.key),lt.return=ut,ut=lt):(yt=Rg(ht.type,ht.key,ht.props,null,ut.mode,yt),yt.ref=Lg(ut,lt,ht),yt.return=ut,ut=yt)}return nt(ut);case wa:e:{for(bt=ht.key;lt!==null;){if(lt.key===bt)if(lt.tag===4&&lt.stateNode.containerInfo===ht.containerInfo&&lt.stateNode.implementation===ht.implementation){$(ut,lt.sibling),lt=et(lt,ht.children||[]),lt.return=ut,ut=lt;break e}else{$(ut,lt);break}else j(ut,lt);lt=lt.sibling}lt=Sg(ht,ut.mode,yt),lt.return=ut,ut=lt}return nt(ut);case Ha:return bt=ht._init,gt(ut,lt,bt(ht._payload),yt)}if(eb(ht))return dt(ut,lt,ht,yt);if(Ka(ht))return ft(ut,lt,ht,yt);Mg(ut,ht)}return typeof ht=="string"&&ht!==""||typeof ht=="number"?(ht=""+ht,lt!==null&&lt.tag===6?($(ut,lt.sibling),lt=et(lt,ht),lt.return=ut,ut=lt):($(ut,lt),lt=Qg(ht,ut.mode,yt),lt.return=ut,ut=lt),nt(ut)):$(ut,lt)}return gt}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(_){var j=Wg.current;E$2(Wg),_._currentValue=j}function bh(_,j,$){for(;_!==null;){var _e=_.alternate;if((_.childLanes&j)!==j?(_.childLanes|=j,_e!==null&&(_e.childLanes|=j)):_e!==null&&(_e.childLanes&j)!==j&&(_e.childLanes|=j),_===$)break;_=_.return}}function ch(_,j){Xg=_,Zg=Yg=null,_=_.dependencies,_!==null&&_.firstContext!==null&&(_.lanes&j&&(dh=!0),_.firstContext=null)}function eh(_){var j=_._currentValue;if(Zg!==_)if(_={context:_,memoizedValue:j,next:null},Yg===null){if(Xg===null)throw Error(p$6(308));Yg=_,Xg.dependencies={lanes:0,firstContext:_}}else Yg=Yg.next=_;return j}var fh=null;function gh(_){fh===null?fh=[_]:fh.push(_)}function hh(_,j,$,_e){var et=j.interleaved;return et===null?($.next=$,gh(j)):($.next=et.next,et.next=$),j.interleaved=$,ih(_,_e)}function ih(_,j){_.lanes|=j;var $=_.alternate;for($!==null&&($.lanes|=j),$=_,_=_.return;_!==null;)_.childLanes|=j,$=_.alternate,$!==null&&($.childLanes|=j),$=_,_=_.return;return $.tag===3?$.stateNode:null}var jh=!1;function kh(_){_.updateQueue={baseState:_.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh(_,j){_=_.updateQueue,j.updateQueue===_&&(j.updateQueue={baseState:_.baseState,firstBaseUpdate:_.firstBaseUpdate,lastBaseUpdate:_.lastBaseUpdate,shared:_.shared,effects:_.effects})}function mh(_,j){return{eventTime:_,lane:j,tag:0,payload:null,callback:null,next:null}}function nh(_,j,$){var _e=_.updateQueue;if(_e===null)return null;if(_e=_e.shared,K&2){var et=_e.pending;return et===null?j.next=j:(j.next=et.next,et.next=j),_e.pending=j,ih(_,$)}return et=_e.interleaved,et===null?(j.next=j,gh(_e)):(j.next=et.next,et.next=j),_e.interleaved=j,ih(_,$)}function oh(_,j,$){if(j=j.updateQueue,j!==null&&(j=j.shared,($&4194240)!==0)){var _e=j.lanes;_e&=_.pendingLanes,$|=_e,j.lanes=$,Cc(_,$)}}function ph(_,j){var $=_.updateQueue,_e=_.alternate;if(_e!==null&&(_e=_e.updateQueue,$===_e)){var et=null,tt=null;if($=$.firstBaseUpdate,$!==null){do{var nt={eventTime:$.eventTime,lane:$.lane,tag:$.tag,payload:$.payload,callback:$.callback,next:null};tt===null?et=tt=nt:tt=tt.next=nt,$=$.next}while($!==null);tt===null?et=tt=j:tt=tt.next=j}else et=tt=j;$={baseState:_e.baseState,firstBaseUpdate:et,lastBaseUpdate:tt,shared:_e.shared,effects:_e.effects},_.updateQueue=$;return}_=$.lastBaseUpdate,_===null?$.firstBaseUpdate=j:_.next=j,$.lastBaseUpdate=j}function qh(_,j,$,_e){var et=_.updateQueue;jh=!1;var tt=et.firstBaseUpdate,nt=et.lastBaseUpdate,rt=et.shared.pending;if(rt!==null){et.shared.pending=null;var at=rt,it=at.next;at.next=null,nt===null?tt=it:nt.next=it,nt=at;var ot=_.alternate;ot!==null&&(ot=ot.updateQueue,rt=ot.lastBaseUpdate,rt!==nt&&(rt===null?ot.firstBaseUpdate=it:rt.next=it,ot.lastBaseUpdate=at))}if(tt!==null){var st=et.baseState;nt=0,ot=it=at=null,rt=tt;do{var ct=rt.lane,pt=rt.eventTime;if((_e&ct)===ct){ot!==null&&(ot=ot.next={eventTime:pt,lane:0,tag:rt.tag,payload:rt.payload,callback:rt.callback,next:null});e:{var dt=_,ft=rt;switch(ct=j,pt=$,ft.tag){case 1:if(dt=ft.payload,typeof dt=="function"){st=dt.call(pt,st,ct);break e}st=dt;break e;case 3:dt.flags=dt.flags&-65537|128;case 0:if(dt=ft.payload,ct=typeof dt=="function"?dt.call(pt,st,ct):dt,ct==null)break e;st=A({},st,ct);break e;case 2:jh=!0}}rt.callback!==null&&rt.lane!==0&&(_.flags|=64,ct=et.effects,ct===null?et.effects=[rt]:ct.push(rt))}else pt={eventTime:pt,lane:ct,tag:rt.tag,payload:rt.payload,callback:rt.callback,next:null},ot===null?(it=ot=pt,at=st):ot=ot.next=pt,nt|=ct;if(rt=rt.next,rt===null){if(rt=et.shared.pending,rt===null)break;ct=rt,rt=ct.next,ct.next=null,et.lastBaseUpdate=ct,et.shared.pending=null}}while(!0);if(ot===null&&(at=st),et.baseState=at,et.firstBaseUpdate=it,et.lastBaseUpdate=ot,j=et.shared.interleaved,j!==null){et=j;do nt|=et.lane,et=et.next;while(et!==j)}else tt===null&&(et.shared.lanes=0);rh|=nt,_.lanes=nt,_.memoizedState=st}}function sh(_,j,$){if(_=j.effects,j.effects=null,_!==null)for(j=0;j<_.length;j++){var _e=_[j],et=_e.callback;if(et!==null){if(_e.callback=null,_e=$,typeof et!="function")throw Error(p$6(191,et));et.call(_e)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(_){if(_===th)throw Error(p$6(174));return _}function yh(_,j){switch(G(wh,j),G(vh,_),G(uh,th),_=j.nodeType,_){case 9:case 11:j=(j=j.documentElement)?j.namespaceURI:lb(null,"");break;default:_=_===8?j.parentNode:j,j=_.namespaceURI||null,_=_.tagName,j=lb(j,_)}E$2(uh),G(uh,j)}function zh(){E$2(uh),E$2(vh),E$2(wh)}function Ah(_){xh(wh.current);var j=xh(uh.current),$=lb(j,_.type);j!==$&&(G(vh,_),G(uh,$))}function Bh(_){vh.current===_&&(E$2(uh),E$2(vh))}var L$1=Uf(0);function Ch(_){for(var j=_;j!==null;){if(j.tag===13){var $=j.memoizedState;if($!==null&&($=$.dehydrated,$===null||$.data==="$?"||$.data==="$!"))return j}else if(j.tag===19&&j.memoizedProps.revealOrder!==void 0){if(j.flags&128)return j}else if(j.child!==null){j.child.return=j,j=j.child;continue}if(j===_)break;for(;j.sibling===null;){if(j.return===null||j.return===_)return null;j=j.return}j.sibling.return=j.return,j=j.sibling}return null}var Dh=[];function Eh(){for(var _=0;_<Dh.length;_++)Dh[_]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M$1=null,N=null,O$1=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P$1(){throw Error(p$6(321))}function Mh(_,j){if(j===null)return!1;for(var $=0;$<j.length&&$<_.length;$++)if(!He(_[$],j[$]))return!1;return!0}function Nh(_,j,$,_e,et,tt){if(Hh=tt,M$1=j,j.memoizedState=null,j.updateQueue=null,j.lanes=0,Fh.current=_===null||_.memoizedState===null?Oh:Ph,_=$(_e,et),Jh){tt=0;do{if(Jh=!1,Kh=0,25<=tt)throw Error(p$6(301));tt+=1,O$1=N=null,j.updateQueue=null,Fh.current=Qh,_=$(_e,et)}while(Jh)}if(Fh.current=Rh,j=N!==null&&N.next!==null,Hh=0,O$1=N=M$1=null,Ih=!1,j)throw Error(p$6(300));return _}function Sh(){var _=Kh!==0;return Kh=0,_}function Th(){var _={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O$1===null?M$1.memoizedState=O$1=_:O$1=O$1.next=_,O$1}function Uh(){if(N===null){var _=M$1.alternate;_=_!==null?_.memoizedState:null}else _=N.next;var j=O$1===null?M$1.memoizedState:O$1.next;if(j!==null)O$1=j,N=_;else{if(_===null)throw Error(p$6(310));N=_,_={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null},O$1===null?M$1.memoizedState=O$1=_:O$1=O$1.next=_}return O$1}function Vh(_,j){return typeof j=="function"?j(_):j}function Wh(_){var j=Uh(),$=j.queue;if($===null)throw Error(p$6(311));$.lastRenderedReducer=_;var _e=N,et=_e.baseQueue,tt=$.pending;if(tt!==null){if(et!==null){var nt=et.next;et.next=tt.next,tt.next=nt}_e.baseQueue=et=tt,$.pending=null}if(et!==null){tt=et.next,_e=_e.baseState;var rt=nt=null,at=null,it=tt;do{var ot=it.lane;if((Hh&ot)===ot)at!==null&&(at=at.next={lane:0,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null}),_e=it.hasEagerState?it.eagerState:_(_e,it.action);else{var st={lane:ot,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null};at===null?(rt=at=st,nt=_e):at=at.next=st,M$1.lanes|=ot,rh|=ot}it=it.next}while(it!==null&&it!==tt);at===null?nt=_e:at.next=rt,He(_e,j.memoizedState)||(dh=!0),j.memoizedState=_e,j.baseState=nt,j.baseQueue=at,$.lastRenderedState=_e}if(_=$.interleaved,_!==null){et=_;do tt=et.lane,M$1.lanes|=tt,rh|=tt,et=et.next;while(et!==_)}else et===null&&($.lanes=0);return[j.memoizedState,$.dispatch]}function Xh(_){var j=Uh(),$=j.queue;if($===null)throw Error(p$6(311));$.lastRenderedReducer=_;var _e=$.dispatch,et=$.pending,tt=j.memoizedState;if(et!==null){$.pending=null;var nt=et=et.next;do tt=_(tt,nt.action),nt=nt.next;while(nt!==et);He(tt,j.memoizedState)||(dh=!0),j.memoizedState=tt,j.baseQueue===null&&(j.baseState=tt),$.lastRenderedState=tt}return[tt,_e]}function Yh(){}function Zh(_,j){var $=M$1,_e=Uh(),et=j(),tt=!He(_e.memoizedState,et);if(tt&&(_e.memoizedState=et,dh=!0),_e=_e.queue,$h(ai.bind(null,$,_e,_),[_]),_e.getSnapshot!==j||tt||O$1!==null&&O$1.memoizedState.tag&1){if($.flags|=2048,bi(9,ci.bind(null,$,_e,et,j),void 0,null),Q===null)throw Error(p$6(349));Hh&30||di($,j,et)}return et}function di(_,j,$){_.flags|=16384,_={getSnapshot:j,value:$},j=M$1.updateQueue,j===null?(j={lastEffect:null,stores:null},M$1.updateQueue=j,j.stores=[_]):($=j.stores,$===null?j.stores=[_]:$.push(_))}function ci(_,j,$,_e){j.value=$,j.getSnapshot=_e,ei(j)&&fi(_)}function ai(_,j,$){return $(function(){ei(j)&&fi(_)})}function ei(_){var j=_.getSnapshot;_=_.value;try{var $=j();return!He(_,$)}catch{return!0}}function fi(_){var j=ih(_,1);j!==null&&gi(j,_,1,-1)}function hi(_){var j=Th();return typeof _=="function"&&(_=_()),j.memoizedState=j.baseState=_,_={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:_},j.queue=_,_=_.dispatch=ii.bind(null,M$1,_),[j.memoizedState,_]}function bi(_,j,$,_e){return _={tag:_,create:j,destroy:$,deps:_e,next:null},j=M$1.updateQueue,j===null?(j={lastEffect:null,stores:null},M$1.updateQueue=j,j.lastEffect=_.next=_):($=j.lastEffect,$===null?j.lastEffect=_.next=_:(_e=$.next,$.next=_,_.next=_e,j.lastEffect=_)),_}function ji(){return Uh().memoizedState}function ki(_,j,$,_e){var et=Th();M$1.flags|=_,et.memoizedState=bi(1|j,$,void 0,_e===void 0?null:_e)}function li(_,j,$,_e){var et=Uh();_e=_e===void 0?null:_e;var tt=void 0;if(N!==null){var nt=N.memoizedState;if(tt=nt.destroy,_e!==null&&Mh(_e,nt.deps)){et.memoizedState=bi(j,$,tt,_e);return}}M$1.flags|=_,et.memoizedState=bi(1|j,$,tt,_e)}function mi(_,j){return ki(8390656,8,_,j)}function $h(_,j){return li(2048,8,_,j)}function ni(_,j){return li(4,2,_,j)}function oi(_,j){return li(4,4,_,j)}function pi(_,j){if(typeof j=="function")return _=_(),j(_),function(){j(null)};if(j!=null)return _=_(),j.current=_,function(){j.current=null}}function qi(_,j,$){return $=$!=null?$.concat([_]):null,li(4,4,pi.bind(null,j,_),$)}function ri(){}function si(_,j){var $=Uh();j=j===void 0?null:j;var _e=$.memoizedState;return _e!==null&&j!==null&&Mh(j,_e[1])?_e[0]:($.memoizedState=[_,j],_)}function ti(_,j){var $=Uh();j=j===void 0?null:j;var _e=$.memoizedState;return _e!==null&&j!==null&&Mh(j,_e[1])?_e[0]:(_=_(),$.memoizedState=[_,j],_)}function ui(_,j,$){return Hh&21?(He($,j)||($=yc(),M$1.lanes|=$,rh|=$,_.baseState=!0),j):(_.baseState&&(_.baseState=!1,dh=!0),_.memoizedState=$)}function vi(_,j){var $=C$1;C$1=$!==0&&4>$?$:4,_(!0);var _e=Gh.transition;Gh.transition={};try{_(!1),j()}finally{C$1=$,Gh.transition=_e}}function wi(){return Uh().memoizedState}function xi(_,j,$){var _e=yi(_);if($={lane:_e,action:$,hasEagerState:!1,eagerState:null,next:null},zi(_))Ai(j,$);else if($=hh(_,j,$,_e),$!==null){var et=R$1();gi($,_,_e,et),Bi($,j,_e)}}function ii(_,j,$){var _e=yi(_),et={lane:_e,action:$,hasEagerState:!1,eagerState:null,next:null};if(zi(_))Ai(j,et);else{var tt=_.alternate;if(_.lanes===0&&(tt===null||tt.lanes===0)&&(tt=j.lastRenderedReducer,tt!==null))try{var nt=j.lastRenderedState,rt=tt(nt,$);if(et.hasEagerState=!0,et.eagerState=rt,He(rt,nt)){var at=j.interleaved;at===null?(et.next=et,gh(j)):(et.next=at.next,at.next=et),j.interleaved=et;return}}catch{}finally{}$=hh(_,j,et,_e),$!==null&&(et=R$1(),gi($,_,_e,et),Bi($,j,_e))}}function zi(_){var j=_.alternate;return _===M$1||j!==null&&j===M$1}function Ai(_,j){Jh=Ih=!0;var $=_.pending;$===null?j.next=j:(j.next=$.next,$.next=j),_.pending=j}function Bi(_,j,$){if($&4194240){var _e=j.lanes;_e&=_.pendingLanes,$|=_e,j.lanes=$,Cc(_,$)}}var Rh={readContext:eh,useCallback:P$1,useContext:P$1,useEffect:P$1,useImperativeHandle:P$1,useInsertionEffect:P$1,useLayoutEffect:P$1,useMemo:P$1,useReducer:P$1,useRef:P$1,useState:P$1,useDebugValue:P$1,useDeferredValue:P$1,useTransition:P$1,useMutableSource:P$1,useSyncExternalStore:P$1,useId:P$1,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(_,j){return Th().memoizedState=[_,j===void 0?null:j],_},useContext:eh,useEffect:mi,useImperativeHandle:function(_,j,$){return $=$!=null?$.concat([_]):null,ki(4194308,4,pi.bind(null,j,_),$)},useLayoutEffect:function(_,j){return ki(4194308,4,_,j)},useInsertionEffect:function(_,j){return ki(4,2,_,j)},useMemo:function(_,j){var $=Th();return j=j===void 0?null:j,_=_(),$.memoizedState=[_,j],_},useReducer:function(_,j,$){var _e=Th();return j=$!==void 0?$(j):j,_e.memoizedState=_e.baseState=j,_={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:_,lastRenderedState:j},_e.queue=_,_=_.dispatch=xi.bind(null,M$1,_),[_e.memoizedState,_]},useRef:function(_){var j=Th();return _={current:_},j.memoizedState=_},useState:hi,useDebugValue:ri,useDeferredValue:function(_){return Th().memoizedState=_},useTransition:function(){var _=hi(!1),j=_[0];return _=vi.bind(null,_[1]),Th().memoizedState=_,[j,_]},useMutableSource:function(){},useSyncExternalStore:function(_,j,$){var _e=M$1,et=Th();if(I){if($===void 0)throw Error(p$6(407));$=$()}else{if($=j(),Q===null)throw Error(p$6(349));Hh&30||di(_e,j,$)}et.memoizedState=$;var tt={value:$,getSnapshot:j};return et.queue=tt,mi(ai.bind(null,_e,tt,_),[_]),_e.flags|=2048,bi(9,ci.bind(null,_e,tt,$,j),void 0,null),$},useId:function(){var _=Th(),j=Q.identifierPrefix;if(I){var $=sg,_e=rg;$=(_e&~(1<<32-oc(_e)-1)).toString(32)+$,j=":"+j+"R"+$,$=Kh++,0<$&&(j+="H"+$.toString(32)),j+=":"}else $=Lh++,j=":"+j+"r"+$.toString(32)+":";return _.memoizedState=j},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},useDebugValue:ri,useDeferredValue:function(_){var j=Uh();return ui(j,N.memoizedState,_)},useTransition:function(){var _=Wh(Vh)[0],j=Uh().memoizedState;return[_,j]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(_){var j=Uh();return N===null?j.memoizedState=_:ui(j,N.memoizedState,_)},useTransition:function(){var _=Xh(Vh)[0],j=Uh().memoizedState;return[_,j]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(_,j){if(_&&_.defaultProps){j=A({},j),_=_.defaultProps;for(var $ in _)j[$]===void 0&&(j[$]=_[$]);return j}return j}function Di(_,j,$,_e){j=_.memoizedState,$=$(_e,j),$=$==null?j:A({},j,$),_.memoizedState=$,_.lanes===0&&(_.updateQueue.baseState=$)}var Ei={isMounted:function(_){return(_=_._reactInternals)?Vb(_)===_:!1},enqueueSetState:function(_,j,$){_=_._reactInternals;var _e=R$1(),et=yi(_),tt=mh(_e,et);tt.payload=j,$!=null&&(tt.callback=$),j=nh(_,tt,et),j!==null&&(gi(j,_,et,_e),oh(j,_,et))},enqueueReplaceState:function(_,j,$){_=_._reactInternals;var _e=R$1(),et=yi(_),tt=mh(_e,et);tt.tag=1,tt.payload=j,$!=null&&(tt.callback=$),j=nh(_,tt,et),j!==null&&(gi(j,_,et,_e),oh(j,_,et))},enqueueForceUpdate:function(_,j){_=_._reactInternals;var $=R$1(),_e=yi(_),et=mh($,_e);et.tag=2,j!=null&&(et.callback=j),j=nh(_,et,_e),j!==null&&(gi(j,_,_e,$),oh(j,_,_e))}};function Fi(_,j,$,_e,et,tt,nt){return _=_.stateNode,typeof _.shouldComponentUpdate=="function"?_.shouldComponentUpdate(_e,tt,nt):j.prototype&&j.prototype.isPureReactComponent?!Ie($,_e)||!Ie(et,tt):!0}function Gi(_,j,$){var _e=!1,et=Vf,tt=j.contextType;return typeof tt=="object"&&tt!==null?tt=eh(tt):(et=Zf(j)?Xf:H.current,_e=j.contextTypes,tt=(_e=_e!=null)?Yf(_,et):Vf),j=new j($,tt),_.memoizedState=j.state!==null&&j.state!==void 0?j.state:null,j.updater=Ei,_.stateNode=j,j._reactInternals=_,_e&&(_=_.stateNode,_.__reactInternalMemoizedUnmaskedChildContext=et,_.__reactInternalMemoizedMaskedChildContext=tt),j}function Hi(_,j,$,_e){_=j.state,typeof j.componentWillReceiveProps=="function"&&j.componentWillReceiveProps($,_e),typeof j.UNSAFE_componentWillReceiveProps=="function"&&j.UNSAFE_componentWillReceiveProps($,_e),j.state!==_&&Ei.enqueueReplaceState(j,j.state,null)}function Ii(_,j,$,_e){var et=_.stateNode;et.props=$,et.state=_.memoizedState,et.refs={},kh(_);var tt=j.contextType;typeof tt=="object"&&tt!==null?et.context=eh(tt):(tt=Zf(j)?Xf:H.current,et.context=Yf(_,tt)),et.state=_.memoizedState,tt=j.getDerivedStateFromProps,typeof tt=="function"&&(Di(_,j,tt,$),et.state=_.memoizedState),typeof j.getDerivedStateFromProps=="function"||typeof et.getSnapshotBeforeUpdate=="function"||typeof et.UNSAFE_componentWillMount!="function"&&typeof et.componentWillMount!="function"||(j=et.state,typeof et.componentWillMount=="function"&&et.componentWillMount(),typeof et.UNSAFE_componentWillMount=="function"&&et.UNSAFE_componentWillMount(),j!==et.state&&Ei.enqueueReplaceState(et,et.state,null),qh(_,$,et,_e),et.state=_.memoizedState),typeof et.componentDidMount=="function"&&(_.flags|=4194308)}function Ji(_,j){try{var $="",_e=j;do $+=Pa(_e),_e=_e.return;while(_e);var et=$}catch(tt){et=`
Error generating stack: `+tt.message+`
`+tt.stack}return{value:_,source:j,stack:et,digest:null}}function Ki(_,j,$){return{value:_,source:null,stack:$??null,digest:j??null}}function Li(_,j){try{console.error(j.value)}catch($){setTimeout(function(){throw $})}}var Mi=typeof WeakMap=="function"?WeakMap:Map;function Ni(_,j,$){$=mh(-1,$),$.tag=3,$.payload={element:null};var _e=j.value;return $.callback=function(){Oi||(Oi=!0,Pi=_e),Li(_,j)},$}function Qi(_,j,$){$=mh(-1,$),$.tag=3;var _e=_.type.getDerivedStateFromError;if(typeof _e=="function"){var et=j.value;$.payload=function(){return _e(et)},$.callback=function(){Li(_,j)}}var tt=_.stateNode;return tt!==null&&typeof tt.componentDidCatch=="function"&&($.callback=function(){Li(_,j),typeof _e!="function"&&(Ri===null?Ri=new Set([this]):Ri.add(this));var nt=j.stack;this.componentDidCatch(j.value,{componentStack:nt!==null?nt:""})}),$}function Si(_,j,$){var _e=_.pingCache;if(_e===null){_e=_.pingCache=new Mi;var et=new Set;_e.set(j,et)}else et=_e.get(j),et===void 0&&(et=new Set,_e.set(j,et));et.has($)||(et.add($),_=Ti.bind(null,_,j,$),j.then(_,_))}function Ui(_){do{var j;if((j=_.tag===13)&&(j=_.memoizedState,j=j!==null?j.dehydrated!==null:!0),j)return _;_=_.return}while(_!==null);return null}function Vi(_,j,$,_e,et){return _.mode&1?(_.flags|=65536,_.lanes=et,_):(_===j?_.flags|=65536:(_.flags|=128,$.flags|=131072,$.flags&=-52805,$.tag===1&&($.alternate===null?$.tag=17:(j=mh(-1,1),j.tag=2,nh($,j,1))),$.lanes|=1),_)}var Wi=ua.ReactCurrentOwner,dh=!1;function Xi(_,j,$,_e){j.child=_===null?Vg(j,null,$,_e):Ug(j,_.child,$,_e)}function Yi(_,j,$,_e,et){$=$.render;var tt=j.ref;return ch(j,et),_e=Nh(_,j,$,_e,tt,et),$=Sh(),_!==null&&!dh?(j.updateQueue=_.updateQueue,j.flags&=-2053,_.lanes&=~et,Zi(_,j,et)):(I&&$&&vg(j),j.flags|=1,Xi(_,j,_e,et),j.child)}function $i(_,j,$,_e,et){if(_===null){var tt=$.type;return typeof tt=="function"&&!aj(tt)&&tt.defaultProps===void 0&&$.compare===null&&$.defaultProps===void 0?(j.tag=15,j.type=tt,bj(_,j,tt,_e,et)):(_=Rg($.type,null,_e,j,j.mode,et),_.ref=j.ref,_.return=j,j.child=_)}if(tt=_.child,!(_.lanes&et)){var nt=tt.memoizedProps;if($=$.compare,$=$!==null?$:Ie,$(nt,_e)&&_.ref===j.ref)return Zi(_,j,et)}return j.flags|=1,_=Pg(tt,_e),_.ref=j.ref,_.return=j,j.child=_}function bj(_,j,$,_e,et){if(_!==null){var tt=_.memoizedProps;if(Ie(tt,_e)&&_.ref===j.ref)if(dh=!1,j.pendingProps=_e=tt,(_.lanes&et)!==0)_.flags&131072&&(dh=!0);else return j.lanes=_.lanes,Zi(_,j,et)}return cj(_,j,$,_e,et)}function dj(_,j,$){var _e=j.pendingProps,et=_e.children,tt=_!==null?_.memoizedState:null;if(_e.mode==="hidden")if(!(j.mode&1))j.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=$;else{if(!($&1073741824))return _=tt!==null?tt.baseLanes|$:$,j.lanes=j.childLanes=1073741824,j.memoizedState={baseLanes:_,cachePool:null,transitions:null},j.updateQueue=null,G(ej,fj),fj|=_,null;j.memoizedState={baseLanes:0,cachePool:null,transitions:null},_e=tt!==null?tt.baseLanes:$,G(ej,fj),fj|=_e}else tt!==null?(_e=tt.baseLanes|$,j.memoizedState=null):_e=$,G(ej,fj),fj|=_e;return Xi(_,j,et,$),j.child}function gj(_,j){var $=j.ref;(_===null&&$!==null||_!==null&&_.ref!==$)&&(j.flags|=512,j.flags|=2097152)}function cj(_,j,$,_e,et){var tt=Zf($)?Xf:H.current;return tt=Yf(j,tt),ch(j,et),$=Nh(_,j,$,_e,tt,et),_e=Sh(),_!==null&&!dh?(j.updateQueue=_.updateQueue,j.flags&=-2053,_.lanes&=~et,Zi(_,j,et)):(I&&_e&&vg(j),j.flags|=1,Xi(_,j,$,et),j.child)}function hj(_,j,$,_e,et){if(Zf($)){var tt=!0;cg(j)}else tt=!1;if(ch(j,et),j.stateNode===null)ij(_,j),Gi(j,$,_e),Ii(j,$,_e,et),_e=!0;else if(_===null){var nt=j.stateNode,rt=j.memoizedProps;nt.props=rt;var at=nt.context,it=$.contextType;typeof it=="object"&&it!==null?it=eh(it):(it=Zf($)?Xf:H.current,it=Yf(j,it));var ot=$.getDerivedStateFromProps,st=typeof ot=="function"||typeof nt.getSnapshotBeforeUpdate=="function";st||typeof nt.UNSAFE_componentWillReceiveProps!="function"&&typeof nt.componentWillReceiveProps!="function"||(rt!==_e||at!==it)&&Hi(j,nt,_e,it),jh=!1;var ct=j.memoizedState;nt.state=ct,qh(j,_e,nt,et),at=j.memoizedState,rt!==_e||ct!==at||Wf.current||jh?(typeof ot=="function"&&(Di(j,$,ot,_e),at=j.memoizedState),(rt=jh||Fi(j,$,rt,_e,ct,at,it))?(st||typeof nt.UNSAFE_componentWillMount!="function"&&typeof nt.componentWillMount!="function"||(typeof nt.componentWillMount=="function"&&nt.componentWillMount(),typeof nt.UNSAFE_componentWillMount=="function"&&nt.UNSAFE_componentWillMount()),typeof nt.componentDidMount=="function"&&(j.flags|=4194308)):(typeof nt.componentDidMount=="function"&&(j.flags|=4194308),j.memoizedProps=_e,j.memoizedState=at),nt.props=_e,nt.state=at,nt.context=it,_e=rt):(typeof nt.componentDidMount=="function"&&(j.flags|=4194308),_e=!1)}else{nt=j.stateNode,lh(_,j),rt=j.memoizedProps,it=j.type===j.elementType?rt:Ci(j.type,rt),nt.props=it,st=j.pendingProps,ct=nt.context,at=$.contextType,typeof at=="object"&&at!==null?at=eh(at):(at=Zf($)?Xf:H.current,at=Yf(j,at));var pt=$.getDerivedStateFromProps;(ot=typeof pt=="function"||typeof nt.getSnapshotBeforeUpdate=="function")||typeof nt.UNSAFE_componentWillReceiveProps!="function"&&typeof nt.componentWillReceiveProps!="function"||(rt!==st||ct!==at)&&Hi(j,nt,_e,at),jh=!1,ct=j.memoizedState,nt.state=ct,qh(j,_e,nt,et);var dt=j.memoizedState;rt!==st||ct!==dt||Wf.current||jh?(typeof pt=="function"&&(Di(j,$,pt,_e),dt=j.memoizedState),(it=jh||Fi(j,$,it,_e,ct,dt,at)||!1)?(ot||typeof nt.UNSAFE_componentWillUpdate!="function"&&typeof nt.componentWillUpdate!="function"||(typeof nt.componentWillUpdate=="function"&&nt.componentWillUpdate(_e,dt,at),typeof nt.UNSAFE_componentWillUpdate=="function"&&nt.UNSAFE_componentWillUpdate(_e,dt,at)),typeof nt.componentDidUpdate=="function"&&(j.flags|=4),typeof nt.getSnapshotBeforeUpdate=="function"&&(j.flags|=1024)):(typeof nt.componentDidUpdate!="function"||rt===_.memoizedProps&&ct===_.memoizedState||(j.flags|=4),typeof nt.getSnapshotBeforeUpdate!="function"||rt===_.memoizedProps&&ct===_.memoizedState||(j.flags|=1024),j.memoizedProps=_e,j.memoizedState=dt),nt.props=_e,nt.state=dt,nt.context=at,_e=it):(typeof nt.componentDidUpdate!="function"||rt===_.memoizedProps&&ct===_.memoizedState||(j.flags|=4),typeof nt.getSnapshotBeforeUpdate!="function"||rt===_.memoizedProps&&ct===_.memoizedState||(j.flags|=1024),_e=!1)}return jj(_,j,$,_e,tt,et)}function jj(_,j,$,_e,et,tt){gj(_,j);var nt=(j.flags&128)!==0;if(!_e&&!nt)return et&&dg(j,$,!1),Zi(_,j,tt);_e=j.stateNode,Wi.current=j;var rt=nt&&typeof $.getDerivedStateFromError!="function"?null:_e.render();return j.flags|=1,_!==null&&nt?(j.child=Ug(j,_.child,null,tt),j.child=Ug(j,null,rt,tt)):Xi(_,j,rt,tt),j.memoizedState=_e.state,et&&dg(j,$,!0),j.child}function kj(_){var j=_.stateNode;j.pendingContext?ag(_,j.pendingContext,j.pendingContext!==j.context):j.context&&ag(_,j.context,!1),yh(_,j.containerInfo)}function lj(_,j,$,_e,et){return Ig(),Jg(et),j.flags|=256,Xi(_,j,$,_e),j.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(_){return{baseLanes:_,cachePool:null,transitions:null}}function oj(_,j,$){var _e=j.pendingProps,et=L$1.current,tt=!1,nt=(j.flags&128)!==0,rt;if((rt=nt)||(rt=_!==null&&_.memoizedState===null?!1:(et&2)!==0),rt?(tt=!0,j.flags&=-129):(_===null||_.memoizedState!==null)&&(et|=1),G(L$1,et&1),_===null)return Eg(j),_=j.memoizedState,_!==null&&(_=_.dehydrated,_!==null)?(j.mode&1?_.data==="$!"?j.lanes=8:j.lanes=1073741824:j.lanes=1,null):(nt=_e.children,_=_e.fallback,tt?(_e=j.mode,tt=j.child,nt={mode:"hidden",children:nt},!(_e&1)&&tt!==null?(tt.childLanes=0,tt.pendingProps=nt):tt=pj(nt,_e,0,null),_=Tg(_,_e,$,null),tt.return=j,_.return=j,tt.sibling=_,j.child=tt,j.child.memoizedState=nj($),j.memoizedState=mj,_):qj(j,nt));if(et=_.memoizedState,et!==null&&(rt=et.dehydrated,rt!==null))return rj(_,j,nt,_e,rt,et,$);if(tt){tt=_e.fallback,nt=j.mode,et=_.child,rt=et.sibling;var at={mode:"hidden",children:_e.children};return!(nt&1)&&j.child!==et?(_e=j.child,_e.childLanes=0,_e.pendingProps=at,j.deletions=null):(_e=Pg(et,at),_e.subtreeFlags=et.subtreeFlags&14680064),rt!==null?tt=Pg(rt,tt):(tt=Tg(tt,nt,$,null),tt.flags|=2),tt.return=j,_e.return=j,_e.sibling=tt,j.child=_e,_e=tt,tt=j.child,nt=_.child.memoizedState,nt=nt===null?nj($):{baseLanes:nt.baseLanes|$,cachePool:null,transitions:nt.transitions},tt.memoizedState=nt,tt.childLanes=_.childLanes&~$,j.memoizedState=mj,_e}return tt=_.child,_=tt.sibling,_e=Pg(tt,{mode:"visible",children:_e.children}),!(j.mode&1)&&(_e.lanes=$),_e.return=j,_e.sibling=null,_!==null&&($=j.deletions,$===null?(j.deletions=[_],j.flags|=16):$.push(_)),j.child=_e,j.memoizedState=null,_e}function qj(_,j){return j=pj({mode:"visible",children:j},_.mode,0,null),j.return=_,_.child=j}function sj(_,j,$,_e){return _e!==null&&Jg(_e),Ug(j,_.child,null,$),_=qj(j,j.pendingProps.children),_.flags|=2,j.memoizedState=null,_}function rj(_,j,$,_e,et,tt,nt){if($)return j.flags&256?(j.flags&=-257,_e=Ki(Error(p$6(422))),sj(_,j,nt,_e)):j.memoizedState!==null?(j.child=_.child,j.flags|=128,null):(tt=_e.fallback,et=j.mode,_e=pj({mode:"visible",children:_e.children},et,0,null),tt=Tg(tt,et,nt,null),tt.flags|=2,_e.return=j,tt.return=j,_e.sibling=tt,j.child=_e,j.mode&1&&Ug(j,_.child,null,nt),j.child.memoizedState=nj(nt),j.memoizedState=mj,tt);if(!(j.mode&1))return sj(_,j,nt,null);if(et.data==="$!"){if(_e=et.nextSibling&&et.nextSibling.dataset,_e)var rt=_e.dgst;return _e=rt,tt=Error(p$6(419)),_e=Ki(tt,_e,void 0),sj(_,j,nt,_e)}if(rt=(nt&_.childLanes)!==0,dh||rt){if(_e=Q,_e!==null){switch(nt&-nt){case 4:et=2;break;case 16:et=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:et=32;break;case 536870912:et=268435456;break;default:et=0}et=et&(_e.suspendedLanes|nt)?0:et,et!==0&&et!==tt.retryLane&&(tt.retryLane=et,ih(_,et),gi(_e,_,et,-1))}return tj(),_e=Ki(Error(p$6(421))),sj(_,j,nt,_e)}return et.data==="$?"?(j.flags|=128,j.child=_.child,j=uj.bind(null,_),et._reactRetry=j,null):(_=tt.treeContext,yg=Lf(et.nextSibling),xg=j,I=!0,zg=null,_!==null&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=_.id,sg=_.overflow,qg=j),j=qj(j,_e.children),j.flags|=4096,j)}function vj(_,j,$){_.lanes|=j;var _e=_.alternate;_e!==null&&(_e.lanes|=j),bh(_.return,j,$)}function wj(_,j,$,_e,et){var tt=_.memoizedState;tt===null?_.memoizedState={isBackwards:j,rendering:null,renderingStartTime:0,last:_e,tail:$,tailMode:et}:(tt.isBackwards=j,tt.rendering=null,tt.renderingStartTime=0,tt.last=_e,tt.tail=$,tt.tailMode=et)}function xj(_,j,$){var _e=j.pendingProps,et=_e.revealOrder,tt=_e.tail;if(Xi(_,j,_e.children,$),_e=L$1.current,_e&2)_e=_e&1|2,j.flags|=128;else{if(_!==null&&_.flags&128)e:for(_=j.child;_!==null;){if(_.tag===13)_.memoizedState!==null&&vj(_,$,j);else if(_.tag===19)vj(_,$,j);else if(_.child!==null){_.child.return=_,_=_.child;continue}if(_===j)break e;for(;_.sibling===null;){if(_.return===null||_.return===j)break e;_=_.return}_.sibling.return=_.return,_=_.sibling}_e&=1}if(G(L$1,_e),!(j.mode&1))j.memoizedState=null;else switch(et){case"forwards":for($=j.child,et=null;$!==null;)_=$.alternate,_!==null&&Ch(_)===null&&(et=$),$=$.sibling;$=et,$===null?(et=j.child,j.child=null):(et=$.sibling,$.sibling=null),wj(j,!1,et,$,tt);break;case"backwards":for($=null,et=j.child,j.child=null;et!==null;){if(_=et.alternate,_!==null&&Ch(_)===null){j.child=et;break}_=et.sibling,et.sibling=$,$=et,et=_}wj(j,!0,$,null,tt);break;case"together":wj(j,!1,null,null,void 0);break;default:j.memoizedState=null}return j.child}function ij(_,j){!(j.mode&1)&&_!==null&&(_.alternate=null,j.alternate=null,j.flags|=2)}function Zi(_,j,$){if(_!==null&&(j.dependencies=_.dependencies),rh|=j.lanes,!($&j.childLanes))return null;if(_!==null&&j.child!==_.child)throw Error(p$6(153));if(j.child!==null){for(_=j.child,$=Pg(_,_.pendingProps),j.child=$,$.return=j;_.sibling!==null;)_=_.sibling,$=$.sibling=Pg(_,_.pendingProps),$.return=j;$.sibling=null}return j.child}function yj(_,j,$){switch(j.tag){case 3:kj(j),Ig();break;case 5:Ah(j);break;case 1:Zf(j.type)&&cg(j);break;case 4:yh(j,j.stateNode.containerInfo);break;case 10:var _e=j.type._context,et=j.memoizedProps.value;G(Wg,_e._currentValue),_e._currentValue=et;break;case 13:if(_e=j.memoizedState,_e!==null)return _e.dehydrated!==null?(G(L$1,L$1.current&1),j.flags|=128,null):$&j.child.childLanes?oj(_,j,$):(G(L$1,L$1.current&1),_=Zi(_,j,$),_!==null?_.sibling:null);G(L$1,L$1.current&1);break;case 19:if(_e=($&j.childLanes)!==0,_.flags&128){if(_e)return xj(_,j,$);j.flags|=128}if(et=j.memoizedState,et!==null&&(et.rendering=null,et.tail=null,et.lastEffect=null),G(L$1,L$1.current),_e)break;return null;case 22:case 23:return j.lanes=0,dj(_,j,$)}return Zi(_,j,$)}var zj,Aj,Bj,Cj;zj=function(_,j){for(var $=j.child;$!==null;){if($.tag===5||$.tag===6)_.appendChild($.stateNode);else if($.tag!==4&&$.child!==null){$.child.return=$,$=$.child;continue}if($===j)break;for(;$.sibling===null;){if($.return===null||$.return===j)return;$=$.return}$.sibling.return=$.return,$=$.sibling}};Aj=function(){};Bj=function(_,j,$,_e){var et=_.memoizedProps;if(et!==_e){_=j.stateNode,xh(uh.current);var tt=null;switch($){case"input":et=Ya(_,et),_e=Ya(_,_e),tt=[];break;case"select":et=A({},et,{value:void 0}),_e=A({},_e,{value:void 0}),tt=[];break;case"textarea":et=gb(_,et),_e=gb(_,_e),tt=[];break;default:typeof et.onClick!="function"&&typeof _e.onClick=="function"&&(_.onclick=Bf)}ub($,_e);var nt;$=null;for(it in et)if(!_e.hasOwnProperty(it)&&et.hasOwnProperty(it)&&et[it]!=null)if(it==="style"){var rt=et[it];for(nt in rt)rt.hasOwnProperty(nt)&&($||($={}),$[nt]="")}else it!=="dangerouslySetInnerHTML"&&it!=="children"&&it!=="suppressContentEditableWarning"&&it!=="suppressHydrationWarning"&&it!=="autoFocus"&&(ea.hasOwnProperty(it)?tt||(tt=[]):(tt=tt||[]).push(it,null));for(it in _e){var at=_e[it];if(rt=et!=null?et[it]:void 0,_e.hasOwnProperty(it)&&at!==rt&&(at!=null||rt!=null))if(it==="style")if(rt){for(nt in rt)!rt.hasOwnProperty(nt)||at&&at.hasOwnProperty(nt)||($||($={}),$[nt]="");for(nt in at)at.hasOwnProperty(nt)&&rt[nt]!==at[nt]&&($||($={}),$[nt]=at[nt])}else $||(tt||(tt=[]),tt.push(it,$)),$=at;else it==="dangerouslySetInnerHTML"?(at=at?at.__html:void 0,rt=rt?rt.__html:void 0,at!=null&&rt!==at&&(tt=tt||[]).push(it,at)):it==="children"?typeof at!="string"&&typeof at!="number"||(tt=tt||[]).push(it,""+at):it!=="suppressContentEditableWarning"&&it!=="suppressHydrationWarning"&&(ea.hasOwnProperty(it)?(at!=null&&it==="onScroll"&&D$1("scroll",_),tt||rt===at||(tt=[])):(tt=tt||[]).push(it,at))}$&&(tt=tt||[]).push("style",$);var it=tt;(j.updateQueue=it)&&(j.flags|=4)}};Cj=function(_,j,$,_e){$!==_e&&(j.flags|=4)};function Dj(_,j){if(!I)switch(_.tailMode){case"hidden":j=_.tail;for(var $=null;j!==null;)j.alternate!==null&&($=j),j=j.sibling;$===null?_.tail=null:$.sibling=null;break;case"collapsed":$=_.tail;for(var _e=null;$!==null;)$.alternate!==null&&(_e=$),$=$.sibling;_e===null?j||_.tail===null?_.tail=null:_.tail.sibling=null:_e.sibling=null}}function S$1(_){var j=_.alternate!==null&&_.alternate.child===_.child,$=0,_e=0;if(j)for(var et=_.child;et!==null;)$|=et.lanes|et.childLanes,_e|=et.subtreeFlags&14680064,_e|=et.flags&14680064,et.return=_,et=et.sibling;else for(et=_.child;et!==null;)$|=et.lanes|et.childLanes,_e|=et.subtreeFlags,_e|=et.flags,et.return=_,et=et.sibling;return _.subtreeFlags|=_e,_.childLanes=$,j}function Ej(_,j,$){var _e=j.pendingProps;switch(wg(j),j.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S$1(j),null;case 1:return Zf(j.type)&&$f(),S$1(j),null;case 3:return _e=j.stateNode,zh(),E$2(Wf),E$2(H),Eh(),_e.pendingContext&&(_e.context=_e.pendingContext,_e.pendingContext=null),(_===null||_.child===null)&&(Gg(j)?j.flags|=4:_===null||_.memoizedState.isDehydrated&&!(j.flags&256)||(j.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(_,j),S$1(j),null;case 5:Bh(j);var et=xh(wh.current);if($=j.type,_!==null&&j.stateNode!=null)Bj(_,j,$,_e,et),_.ref!==j.ref&&(j.flags|=512,j.flags|=2097152);else{if(!_e){if(j.stateNode===null)throw Error(p$6(166));return S$1(j),null}if(_=xh(uh.current),Gg(j)){_e=j.stateNode,$=j.type;var tt=j.memoizedProps;switch(_e[Of]=j,_e[Pf]=tt,_=(j.mode&1)!==0,$){case"dialog":D$1("cancel",_e),D$1("close",_e);break;case"iframe":case"object":case"embed":D$1("load",_e);break;case"video":case"audio":for(et=0;et<lf.length;et++)D$1(lf[et],_e);break;case"source":D$1("error",_e);break;case"img":case"image":case"link":D$1("error",_e),D$1("load",_e);break;case"details":D$1("toggle",_e);break;case"input":Za(_e,tt),D$1("invalid",_e);break;case"select":_e._wrapperState={wasMultiple:!!tt.multiple},D$1("invalid",_e);break;case"textarea":hb(_e,tt),D$1("invalid",_e)}ub($,tt),et=null;for(var nt in tt)if(tt.hasOwnProperty(nt)){var rt=tt[nt];nt==="children"?typeof rt=="string"?_e.textContent!==rt&&(tt.suppressHydrationWarning!==!0&&Af(_e.textContent,rt,_),et=["children",rt]):typeof rt=="number"&&_e.textContent!==""+rt&&(tt.suppressHydrationWarning!==!0&&Af(_e.textContent,rt,_),et=["children",""+rt]):ea.hasOwnProperty(nt)&&rt!=null&&nt==="onScroll"&&D$1("scroll",_e)}switch($){case"input":Va(_e),db(_e,tt,!0);break;case"textarea":Va(_e),jb(_e);break;case"select":case"option":break;default:typeof tt.onClick=="function"&&(_e.onclick=Bf)}_e=et,j.updateQueue=_e,_e!==null&&(j.flags|=4)}else{nt=et.nodeType===9?et:et.ownerDocument,_==="http://www.w3.org/1999/xhtml"&&(_=kb($)),_==="http://www.w3.org/1999/xhtml"?$==="script"?(_=nt.createElement("div"),_.innerHTML="<script><\/script>",_=_.removeChild(_.firstChild)):typeof _e.is=="string"?_=nt.createElement($,{is:_e.is}):(_=nt.createElement($),$==="select"&&(nt=_,_e.multiple?nt.multiple=!0:_e.size&&(nt.size=_e.size))):_=nt.createElementNS(_,$),_[Of]=j,_[Pf]=_e,zj(_,j,!1,!1),j.stateNode=_;e:{switch(nt=vb($,_e),$){case"dialog":D$1("cancel",_),D$1("close",_),et=_e;break;case"iframe":case"object":case"embed":D$1("load",_),et=_e;break;case"video":case"audio":for(et=0;et<lf.length;et++)D$1(lf[et],_);et=_e;break;case"source":D$1("error",_),et=_e;break;case"img":case"image":case"link":D$1("error",_),D$1("load",_),et=_e;break;case"details":D$1("toggle",_),et=_e;break;case"input":Za(_,_e),et=Ya(_,_e),D$1("invalid",_);break;case"option":et=_e;break;case"select":_._wrapperState={wasMultiple:!!_e.multiple},et=A({},_e,{value:void 0}),D$1("invalid",_);break;case"textarea":hb(_,_e),et=gb(_,_e),D$1("invalid",_);break;default:et=_e}ub($,et),rt=et;for(tt in rt)if(rt.hasOwnProperty(tt)){var at=rt[tt];tt==="style"?sb(_,at):tt==="dangerouslySetInnerHTML"?(at=at?at.__html:void 0,at!=null&&nb(_,at)):tt==="children"?typeof at=="string"?($!=="textarea"||at!=="")&&ob(_,at):typeof at=="number"&&ob(_,""+at):tt!=="suppressContentEditableWarning"&&tt!=="suppressHydrationWarning"&&tt!=="autoFocus"&&(ea.hasOwnProperty(tt)?at!=null&&tt==="onScroll"&&D$1("scroll",_):at!=null&&ta(_,tt,at,nt))}switch($){case"input":Va(_),db(_,_e,!1);break;case"textarea":Va(_),jb(_);break;case"option":_e.value!=null&&_.setAttribute("value",""+Sa(_e.value));break;case"select":_.multiple=!!_e.multiple,tt=_e.value,tt!=null?fb(_,!!_e.multiple,tt,!1):_e.defaultValue!=null&&fb(_,!!_e.multiple,_e.defaultValue,!0);break;default:typeof et.onClick=="function"&&(_.onclick=Bf)}switch($){case"button":case"input":case"select":case"textarea":_e=!!_e.autoFocus;break e;case"img":_e=!0;break e;default:_e=!1}}_e&&(j.flags|=4)}j.ref!==null&&(j.flags|=512,j.flags|=2097152)}return S$1(j),null;case 6:if(_&&j.stateNode!=null)Cj(_,j,_.memoizedProps,_e);else{if(typeof _e!="string"&&j.stateNode===null)throw Error(p$6(166));if($=xh(wh.current),xh(uh.current),Gg(j)){if(_e=j.stateNode,$=j.memoizedProps,_e[Of]=j,(tt=_e.nodeValue!==$)&&(_=xg,_!==null))switch(_.tag){case 3:Af(_e.nodeValue,$,(_.mode&1)!==0);break;case 5:_.memoizedProps.suppressHydrationWarning!==!0&&Af(_e.nodeValue,$,(_.mode&1)!==0)}tt&&(j.flags|=4)}else _e=($.nodeType===9?$:$.ownerDocument).createTextNode(_e),_e[Of]=j,j.stateNode=_e}return S$1(j),null;case 13:if(E$2(L$1),_e=j.memoizedState,_===null||_.memoizedState!==null&&_.memoizedState.dehydrated!==null){if(I&&yg!==null&&j.mode&1&&!(j.flags&128))Hg(),Ig(),j.flags|=98560,tt=!1;else if(tt=Gg(j),_e!==null&&_e.dehydrated!==null){if(_===null){if(!tt)throw Error(p$6(318));if(tt=j.memoizedState,tt=tt!==null?tt.dehydrated:null,!tt)throw Error(p$6(317));tt[Of]=j}else Ig(),!(j.flags&128)&&(j.memoizedState=null),j.flags|=4;S$1(j),tt=!1}else zg!==null&&(Fj(zg),zg=null),tt=!0;if(!tt)return j.flags&65536?j:null}return j.flags&128?(j.lanes=$,j):(_e=_e!==null,_e!==(_!==null&&_.memoizedState!==null)&&_e&&(j.child.flags|=8192,j.mode&1&&(_===null||L$1.current&1?T$1===0&&(T$1=3):tj())),j.updateQueue!==null&&(j.flags|=4),S$1(j),null);case 4:return zh(),Aj(_,j),_===null&&sf(j.stateNode.containerInfo),S$1(j),null;case 10:return ah(j.type._context),S$1(j),null;case 17:return Zf(j.type)&&$f(),S$1(j),null;case 19:if(E$2(L$1),tt=j.memoizedState,tt===null)return S$1(j),null;if(_e=(j.flags&128)!==0,nt=tt.rendering,nt===null)if(_e)Dj(tt,!1);else{if(T$1!==0||_!==null&&_.flags&128)for(_=j.child;_!==null;){if(nt=Ch(_),nt!==null){for(j.flags|=128,Dj(tt,!1),_e=nt.updateQueue,_e!==null&&(j.updateQueue=_e,j.flags|=4),j.subtreeFlags=0,_e=$,$=j.child;$!==null;)tt=$,_=_e,tt.flags&=14680066,nt=tt.alternate,nt===null?(tt.childLanes=0,tt.lanes=_,tt.child=null,tt.subtreeFlags=0,tt.memoizedProps=null,tt.memoizedState=null,tt.updateQueue=null,tt.dependencies=null,tt.stateNode=null):(tt.childLanes=nt.childLanes,tt.lanes=nt.lanes,tt.child=nt.child,tt.subtreeFlags=0,tt.deletions=null,tt.memoizedProps=nt.memoizedProps,tt.memoizedState=nt.memoizedState,tt.updateQueue=nt.updateQueue,tt.type=nt.type,_=nt.dependencies,tt.dependencies=_===null?null:{lanes:_.lanes,firstContext:_.firstContext}),$=$.sibling;return G(L$1,L$1.current&1|2),j.child}_=_.sibling}tt.tail!==null&&B()>Gj&&(j.flags|=128,_e=!0,Dj(tt,!1),j.lanes=4194304)}else{if(!_e)if(_=Ch(nt),_!==null){if(j.flags|=128,_e=!0,$=_.updateQueue,$!==null&&(j.updateQueue=$,j.flags|=4),Dj(tt,!0),tt.tail===null&&tt.tailMode==="hidden"&&!nt.alternate&&!I)return S$1(j),null}else 2*B()-tt.renderingStartTime>Gj&&$!==1073741824&&(j.flags|=128,_e=!0,Dj(tt,!1),j.lanes=4194304);tt.isBackwards?(nt.sibling=j.child,j.child=nt):($=tt.last,$!==null?$.sibling=nt:j.child=nt,tt.last=nt)}return tt.tail!==null?(j=tt.tail,tt.rendering=j,tt.tail=j.sibling,tt.renderingStartTime=B(),j.sibling=null,$=L$1.current,G(L$1,_e?$&1|2:$&1),j):(S$1(j),null);case 22:case 23:return Hj(),_e=j.memoizedState!==null,_!==null&&_.memoizedState!==null!==_e&&(j.flags|=8192),_e&&j.mode&1?fj&1073741824&&(S$1(j),j.subtreeFlags&6&&(j.flags|=8192)):S$1(j),null;case 24:return null;case 25:return null}throw Error(p$6(156,j.tag))}function Ij(_,j){switch(wg(j),j.tag){case 1:return Zf(j.type)&&$f(),_=j.flags,_&65536?(j.flags=_&-65537|128,j):null;case 3:return zh(),E$2(Wf),E$2(H),Eh(),_=j.flags,_&65536&&!(_&128)?(j.flags=_&-65537|128,j):null;case 5:return Bh(j),null;case 13:if(E$2(L$1),_=j.memoizedState,_!==null&&_.dehydrated!==null){if(j.alternate===null)throw Error(p$6(340));Ig()}return _=j.flags,_&65536?(j.flags=_&-65537|128,j):null;case 19:return E$2(L$1),null;case 4:return zh(),null;case 10:return ah(j.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V=null;function Lj(_,j){var $=_.ref;if($!==null)if(typeof $=="function")try{$(null)}catch(_e){W(_,j,_e)}else $.current=null}function Mj(_,j,$){try{$()}catch(_e){W(_,j,_e)}}var Nj=!1;function Oj(_,j){if(Cf=dd,_=Me(),Ne(_)){if("selectionStart"in _)var $={start:_.selectionStart,end:_.selectionEnd};else e:{$=($=_.ownerDocument)&&$.defaultView||window;var _e=$.getSelection&&$.getSelection();if(_e&&_e.rangeCount!==0){$=_e.anchorNode;var et=_e.anchorOffset,tt=_e.focusNode;_e=_e.focusOffset;try{$.nodeType,tt.nodeType}catch{$=null;break e}var nt=0,rt=-1,at=-1,it=0,ot=0,st=_,ct=null;t:for(;;){for(var pt;st!==$||et!==0&&st.nodeType!==3||(rt=nt+et),st!==tt||_e!==0&&st.nodeType!==3||(at=nt+_e),st.nodeType===3&&(nt+=st.nodeValue.length),(pt=st.firstChild)!==null;)ct=st,st=pt;for(;;){if(st===_)break t;if(ct===$&&++it===et&&(rt=nt),ct===tt&&++ot===_e&&(at=nt),(pt=st.nextSibling)!==null)break;st=ct,ct=st.parentNode}st=pt}$=rt===-1||at===-1?null:{start:rt,end:at}}else $=null}$=$||{start:0,end:0}}else $=null;for(Df={focusedElem:_,selectionRange:$},dd=!1,V=j;V!==null;)if(j=V,_=j.child,(j.subtreeFlags&1028)!==0&&_!==null)_.return=j,V=_;else for(;V!==null;){j=V;try{var dt=j.alternate;if(j.flags&1024)switch(j.tag){case 0:case 11:case 15:break;case 1:if(dt!==null){var ft=dt.memoizedProps,gt=dt.memoizedState,ut=j.stateNode,lt=ut.getSnapshotBeforeUpdate(j.elementType===j.type?ft:Ci(j.type,ft),gt);ut.__reactInternalSnapshotBeforeUpdate=lt}break;case 3:var ht=j.stateNode.containerInfo;ht.nodeType===1?ht.textContent="":ht.nodeType===9&&ht.documentElement&&ht.removeChild(ht.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p$6(163))}}catch(yt){W(j,j.return,yt)}if(_=j.sibling,_!==null){_.return=j.return,V=_;break}V=j.return}return dt=Nj,Nj=!1,dt}function Pj(_,j,$){var _e=j.updateQueue;if(_e=_e!==null?_e.lastEffect:null,_e!==null){var et=_e=_e.next;do{if((et.tag&_)===_){var tt=et.destroy;et.destroy=void 0,tt!==void 0&&Mj(j,$,tt)}et=et.next}while(et!==_e)}}function Qj(_,j){if(j=j.updateQueue,j=j!==null?j.lastEffect:null,j!==null){var $=j=j.next;do{if(($.tag&_)===_){var _e=$.create;$.destroy=_e()}$=$.next}while($!==j)}}function Rj(_){var j=_.ref;if(j!==null){var $=_.stateNode;switch(_.tag){case 5:_=$;break;default:_=$}typeof j=="function"?j(_):j.current=_}}function Sj(_){var j=_.alternate;j!==null&&(_.alternate=null,Sj(j)),_.child=null,_.deletions=null,_.sibling=null,_.tag===5&&(j=_.stateNode,j!==null&&(delete j[Of],delete j[Pf],delete j[of],delete j[Qf],delete j[Rf])),_.stateNode=null,_.return=null,_.dependencies=null,_.memoizedProps=null,_.memoizedState=null,_.pendingProps=null,_.stateNode=null,_.updateQueue=null}function Tj(_){return _.tag===5||_.tag===3||_.tag===4}function Uj(_){e:for(;;){for(;_.sibling===null;){if(_.return===null||Tj(_.return))return null;_=_.return}for(_.sibling.return=_.return,_=_.sibling;_.tag!==5&&_.tag!==6&&_.tag!==18;){if(_.flags&2||_.child===null||_.tag===4)continue e;_.child.return=_,_=_.child}if(!(_.flags&2))return _.stateNode}}function Vj(_,j,$){var _e=_.tag;if(_e===5||_e===6)_=_.stateNode,j?$.nodeType===8?$.parentNode.insertBefore(_,j):$.insertBefore(_,j):($.nodeType===8?(j=$.parentNode,j.insertBefore(_,$)):(j=$,j.appendChild(_)),$=$._reactRootContainer,$!=null||j.onclick!==null||(j.onclick=Bf));else if(_e!==4&&(_=_.child,_!==null))for(Vj(_,j,$),_=_.sibling;_!==null;)Vj(_,j,$),_=_.sibling}function Wj(_,j,$){var _e=_.tag;if(_e===5||_e===6)_=_.stateNode,j?$.insertBefore(_,j):$.appendChild(_);else if(_e!==4&&(_=_.child,_!==null))for(Wj(_,j,$),_=_.sibling;_!==null;)Wj(_,j,$),_=_.sibling}var X=null,Xj=!1;function Yj(_,j,$){for($=$.child;$!==null;)Zj(_,j,$),$=$.sibling}function Zj(_,j,$){if(lc&&typeof lc.onCommitFiberUnmount=="function")try{lc.onCommitFiberUnmount(kc,$)}catch{}switch($.tag){case 5:U||Lj($,j);case 6:var _e=X,et=Xj;X=null,Yj(_,j,$),X=_e,Xj=et,X!==null&&(Xj?(_=X,$=$.stateNode,_.nodeType===8?_.parentNode.removeChild($):_.removeChild($)):X.removeChild($.stateNode));break;case 18:X!==null&&(Xj?(_=X,$=$.stateNode,_.nodeType===8?Kf(_.parentNode,$):_.nodeType===1&&Kf(_,$),bd(_)):Kf(X,$.stateNode));break;case 4:_e=X,et=Xj,X=$.stateNode.containerInfo,Xj=!0,Yj(_,j,$),X=_e,Xj=et;break;case 0:case 11:case 14:case 15:if(!U&&(_e=$.updateQueue,_e!==null&&(_e=_e.lastEffect,_e!==null))){et=_e=_e.next;do{var tt=et,nt=tt.destroy;tt=tt.tag,nt!==void 0&&(tt&2||tt&4)&&Mj($,j,nt),et=et.next}while(et!==_e)}Yj(_,j,$);break;case 1:if(!U&&(Lj($,j),_e=$.stateNode,typeof _e.componentWillUnmount=="function"))try{_e.props=$.memoizedProps,_e.state=$.memoizedState,_e.componentWillUnmount()}catch(rt){W($,j,rt)}Yj(_,j,$);break;case 21:Yj(_,j,$);break;case 22:$.mode&1?(U=(_e=U)||$.memoizedState!==null,Yj(_,j,$),U=_e):Yj(_,j,$);break;default:Yj(_,j,$)}}function ak(_){var j=_.updateQueue;if(j!==null){_.updateQueue=null;var $=_.stateNode;$===null&&($=_.stateNode=new Kj),j.forEach(function(_e){var et=bk.bind(null,_,_e);$.has(_e)||($.add(_e),_e.then(et,et))})}}function ck(_,j){var $=j.deletions;if($!==null)for(var _e=0;_e<$.length;_e++){var et=$[_e];try{var tt=_,nt=j,rt=nt;e:for(;rt!==null;){switch(rt.tag){case 5:X=rt.stateNode,Xj=!1;break e;case 3:X=rt.stateNode.containerInfo,Xj=!0;break e;case 4:X=rt.stateNode.containerInfo,Xj=!0;break e}rt=rt.return}if(X===null)throw Error(p$6(160));Zj(tt,nt,et),X=null,Xj=!1;var at=et.alternate;at!==null&&(at.return=null),et.return=null}catch(it){W(et,j,it)}}if(j.subtreeFlags&12854)for(j=j.child;j!==null;)dk(j,_),j=j.sibling}function dk(_,j){var $=_.alternate,_e=_.flags;switch(_.tag){case 0:case 11:case 14:case 15:if(ck(j,_),ek(_),_e&4){try{Pj(3,_,_.return),Qj(3,_)}catch(ft){W(_,_.return,ft)}try{Pj(5,_,_.return)}catch(ft){W(_,_.return,ft)}}break;case 1:ck(j,_),ek(_),_e&512&&$!==null&&Lj($,$.return);break;case 5:if(ck(j,_),ek(_),_e&512&&$!==null&&Lj($,$.return),_.flags&32){var et=_.stateNode;try{ob(et,"")}catch(ft){W(_,_.return,ft)}}if(_e&4&&(et=_.stateNode,et!=null)){var tt=_.memoizedProps,nt=$!==null?$.memoizedProps:tt,rt=_.type,at=_.updateQueue;if(_.updateQueue=null,at!==null)try{rt==="input"&&tt.type==="radio"&&tt.name!=null&&ab(et,tt),vb(rt,nt);var it=vb(rt,tt);for(nt=0;nt<at.length;nt+=2){var ot=at[nt],st=at[nt+1];ot==="style"?sb(et,st):ot==="dangerouslySetInnerHTML"?nb(et,st):ot==="children"?ob(et,st):ta(et,ot,st,it)}switch(rt){case"input":bb(et,tt);break;case"textarea":ib(et,tt);break;case"select":var ct=et._wrapperState.wasMultiple;et._wrapperState.wasMultiple=!!tt.multiple;var pt=tt.value;pt!=null?fb(et,!!tt.multiple,pt,!1):ct!==!!tt.multiple&&(tt.defaultValue!=null?fb(et,!!tt.multiple,tt.defaultValue,!0):fb(et,!!tt.multiple,tt.multiple?[]:"",!1))}et[Pf]=tt}catch(ft){W(_,_.return,ft)}}break;case 6:if(ck(j,_),ek(_),_e&4){if(_.stateNode===null)throw Error(p$6(162));et=_.stateNode,tt=_.memoizedProps;try{et.nodeValue=tt}catch(ft){W(_,_.return,ft)}}break;case 3:if(ck(j,_),ek(_),_e&4&&$!==null&&$.memoizedState.isDehydrated)try{bd(j.containerInfo)}catch(ft){W(_,_.return,ft)}break;case 4:ck(j,_),ek(_);break;case 13:ck(j,_),ek(_),et=_.child,et.flags&8192&&(tt=et.memoizedState!==null,et.stateNode.isHidden=tt,!tt||et.alternate!==null&&et.alternate.memoizedState!==null||(fk=B())),_e&4&&ak(_);break;case 22:if(ot=$!==null&&$.memoizedState!==null,_.mode&1?(U=(it=U)||ot,ck(j,_),U=it):ck(j,_),ek(_),_e&8192){if(it=_.memoizedState!==null,(_.stateNode.isHidden=it)&&!ot&&_.mode&1)for(V=_,ot=_.child;ot!==null;){for(st=V=ot;V!==null;){switch(ct=V,pt=ct.child,ct.tag){case 0:case 11:case 14:case 15:Pj(4,ct,ct.return);break;case 1:Lj(ct,ct.return);var dt=ct.stateNode;if(typeof dt.componentWillUnmount=="function"){_e=ct,$=ct.return;try{j=_e,dt.props=j.memoizedProps,dt.state=j.memoizedState,dt.componentWillUnmount()}catch(ft){W(_e,$,ft)}}break;case 5:Lj(ct,ct.return);break;case 22:if(ct.memoizedState!==null){gk(st);continue}}pt!==null?(pt.return=ct,V=pt):gk(st)}ot=ot.sibling}e:for(ot=null,st=_;;){if(st.tag===5){if(ot===null){ot=st;try{et=st.stateNode,it?(tt=et.style,typeof tt.setProperty=="function"?tt.setProperty("display","none","important"):tt.display="none"):(rt=st.stateNode,at=st.memoizedProps.style,nt=at!=null&&at.hasOwnProperty("display")?at.display:null,rt.style.display=rb("display",nt))}catch(ft){W(_,_.return,ft)}}}else if(st.tag===6){if(ot===null)try{st.stateNode.nodeValue=it?"":st.memoizedProps}catch(ft){W(_,_.return,ft)}}else if((st.tag!==22&&st.tag!==23||st.memoizedState===null||st===_)&&st.child!==null){st.child.return=st,st=st.child;continue}if(st===_)break e;for(;st.sibling===null;){if(st.return===null||st.return===_)break e;ot===st&&(ot=null),st=st.return}ot===st&&(ot=null),st.sibling.return=st.return,st=st.sibling}}break;case 19:ck(j,_),ek(_),_e&4&&ak(_);break;case 21:break;default:ck(j,_),ek(_)}}function ek(_){var j=_.flags;if(j&2){try{e:{for(var $=_.return;$!==null;){if(Tj($)){var _e=$;break e}$=$.return}throw Error(p$6(160))}switch(_e.tag){case 5:var et=_e.stateNode;_e.flags&32&&(ob(et,""),_e.flags&=-33);var tt=Uj(_);Wj(_,tt,et);break;case 3:case 4:var nt=_e.stateNode.containerInfo,rt=Uj(_);Vj(_,rt,nt);break;default:throw Error(p$6(161))}}catch(at){W(_,_.return,at)}_.flags&=-3}j&4096&&(_.flags&=-4097)}function hk(_,j,$){V=_,ik(_)}function ik(_,j,$){for(var _e=(_.mode&1)!==0;V!==null;){var et=V,tt=et.child;if(et.tag===22&&_e){var nt=et.memoizedState!==null||Jj;if(!nt){var rt=et.alternate,at=rt!==null&&rt.memoizedState!==null||U;rt=Jj;var it=U;if(Jj=nt,(U=at)&&!it)for(V=et;V!==null;)nt=V,at=nt.child,nt.tag===22&&nt.memoizedState!==null?jk(et):at!==null?(at.return=nt,V=at):jk(et);for(;tt!==null;)V=tt,ik(tt),tt=tt.sibling;V=et,Jj=rt,U=it}kk(_)}else et.subtreeFlags&8772&&tt!==null?(tt.return=et,V=tt):kk(_)}}function kk(_){for(;V!==null;){var j=V;if(j.flags&8772){var $=j.alternate;try{if(j.flags&8772)switch(j.tag){case 0:case 11:case 15:U||Qj(5,j);break;case 1:var _e=j.stateNode;if(j.flags&4&&!U)if($===null)_e.componentDidMount();else{var et=j.elementType===j.type?$.memoizedProps:Ci(j.type,$.memoizedProps);_e.componentDidUpdate(et,$.memoizedState,_e.__reactInternalSnapshotBeforeUpdate)}var tt=j.updateQueue;tt!==null&&sh(j,tt,_e);break;case 3:var nt=j.updateQueue;if(nt!==null){if($=null,j.child!==null)switch(j.child.tag){case 5:$=j.child.stateNode;break;case 1:$=j.child.stateNode}sh(j,nt,$)}break;case 5:var rt=j.stateNode;if($===null&&j.flags&4){$=rt;var at=j.memoizedProps;switch(j.type){case"button":case"input":case"select":case"textarea":at.autoFocus&&$.focus();break;case"img":at.src&&($.src=at.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(j.memoizedState===null){var it=j.alternate;if(it!==null){var ot=it.memoizedState;if(ot!==null){var st=ot.dehydrated;st!==null&&bd(st)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p$6(163))}U||j.flags&512&&Rj(j)}catch(ct){W(j,j.return,ct)}}if(j===_){V=null;break}if($=j.sibling,$!==null){$.return=j.return,V=$;break}V=j.return}}function gk(_){for(;V!==null;){var j=V;if(j===_){V=null;break}var $=j.sibling;if($!==null){$.return=j.return,V=$;break}V=j.return}}function jk(_){for(;V!==null;){var j=V;try{switch(j.tag){case 0:case 11:case 15:var $=j.return;try{Qj(4,j)}catch(at){W(j,$,at)}break;case 1:var _e=j.stateNode;if(typeof _e.componentDidMount=="function"){var et=j.return;try{_e.componentDidMount()}catch(at){W(j,et,at)}}var tt=j.return;try{Rj(j)}catch(at){W(j,tt,at)}break;case 5:var nt=j.return;try{Rj(j)}catch(at){W(j,nt,at)}}}catch(at){W(j,j.return,at)}if(j===_){V=null;break}var rt=j.sibling;if(rt!==null){rt.return=j.return,V=rt;break}V=j.return}}var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T$1=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi=!1,Pi=null,Ri=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R$1(){return K&6?B():Ak!==-1?Ak:Ak=B()}function yi(_){return _.mode&1?K&2&&Z!==0?Z&-Z:Kg.transition!==null?(Bk===0&&(Bk=yc()),Bk):(_=C$1,_!==0||(_=window.event,_=_===void 0?16:jd(_.type)),_):1}function gi(_,j,$,_e){if(50<yk)throw yk=0,zk=null,Error(p$6(185));Ac(_,$,_e),(!(K&2)||_!==Q)&&(_===Q&&(!(K&2)&&(qk|=$),T$1===4&&Ck(_,Z)),Dk(_,_e),$===1&&K===0&&!(j.mode&1)&&(Gj=B()+500,fg&&jg()))}function Dk(_,j){var $=_.callbackNode;wc(_,j);var _e=uc(_,_===Q?Z:0);if(_e===0)$!==null&&bc($),_.callbackNode=null,_.callbackPriority=0;else if(j=_e&-_e,_.callbackPriority!==j){if($!=null&&bc($),j===1)_.tag===0?ig(Ek.bind(null,_)):hg(Ek.bind(null,_)),Jf(function(){!(K&6)&&jg()}),$=null;else{switch(Dc(_e)){case 1:$=fc;break;case 4:$=gc;break;case 16:$=hc;break;case 536870912:$=jc;break;default:$=hc}$=Fk($,Gk.bind(null,_))}_.callbackPriority=j,_.callbackNode=$}}function Gk(_,j){if(Ak=-1,Bk=0,K&6)throw Error(p$6(327));var $=_.callbackNode;if(Hk()&&_.callbackNode!==$)return null;var _e=uc(_,_===Q?Z:0);if(_e===0)return null;if(_e&30||_e&_.expiredLanes||j)j=Ik(_,_e);else{j=_e;var et=K;K|=2;var tt=Jk();(Q!==_||Z!==j)&&(uk=null,Gj=B()+500,Kk(_,j));do try{Lk();break}catch(rt){Mk(_,rt)}while(!0);$g(),mk.current=tt,K=et,Y!==null?j=0:(Q=null,Z=0,j=T$1)}if(j!==0){if(j===2&&(et=xc(_),et!==0&&(_e=et,j=Nk(_,et))),j===1)throw $=pk,Kk(_,0),Ck(_,_e),Dk(_,B()),$;if(j===6)Ck(_,_e);else{if(et=_.current.alternate,!(_e&30)&&!Ok(et)&&(j=Ik(_,_e),j===2&&(tt=xc(_),tt!==0&&(_e=tt,j=Nk(_,tt))),j===1))throw $=pk,Kk(_,0),Ck(_,_e),Dk(_,B()),$;switch(_.finishedWork=et,_.finishedLanes=_e,j){case 0:case 1:throw Error(p$6(345));case 2:Pk(_,tk,uk);break;case 3:if(Ck(_,_e),(_e&130023424)===_e&&(j=fk+500-B(),10<j)){if(uc(_,0)!==0)break;if(et=_.suspendedLanes,(et&_e)!==_e){R$1(),_.pingedLanes|=_.suspendedLanes&et;break}_.timeoutHandle=Ff(Pk.bind(null,_,tk,uk),j);break}Pk(_,tk,uk);break;case 4:if(Ck(_,_e),(_e&4194240)===_e)break;for(j=_.eventTimes,et=-1;0<_e;){var nt=31-oc(_e);tt=1<<nt,nt=j[nt],nt>et&&(et=nt),_e&=~tt}if(_e=et,_e=B()-_e,_e=(120>_e?120:480>_e?480:1080>_e?1080:1920>_e?1920:3e3>_e?3e3:4320>_e?4320:1960*lk(_e/1960))-_e,10<_e){_.timeoutHandle=Ff(Pk.bind(null,_,tk,uk),_e);break}Pk(_,tk,uk);break;case 5:Pk(_,tk,uk);break;default:throw Error(p$6(329))}}}return Dk(_,B()),_.callbackNode===$?Gk.bind(null,_):null}function Nk(_,j){var $=sk;return _.current.memoizedState.isDehydrated&&(Kk(_,j).flags|=256),_=Ik(_,j),_!==2&&(j=tk,tk=$,j!==null&&Fj(j)),_}function Fj(_){tk===null?tk=_:tk.push.apply(tk,_)}function Ok(_){for(var j=_;;){if(j.flags&16384){var $=j.updateQueue;if($!==null&&($=$.stores,$!==null))for(var _e=0;_e<$.length;_e++){var et=$[_e],tt=et.getSnapshot;et=et.value;try{if(!He(tt(),et))return!1}catch{return!1}}}if($=j.child,j.subtreeFlags&16384&&$!==null)$.return=j,j=$;else{if(j===_)break;for(;j.sibling===null;){if(j.return===null||j.return===_)return!0;j=j.return}j.sibling.return=j.return,j=j.sibling}}return!0}function Ck(_,j){for(j&=~rk,j&=~qk,_.suspendedLanes|=j,_.pingedLanes&=~j,_=_.expirationTimes;0<j;){var $=31-oc(j),_e=1<<$;_[$]=-1,j&=~_e}}function Ek(_){if(K&6)throw Error(p$6(327));Hk();var j=uc(_,0);if(!(j&1))return Dk(_,B()),null;var $=Ik(_,j);if(_.tag!==0&&$===2){var _e=xc(_);_e!==0&&(j=_e,$=Nk(_,_e))}if($===1)throw $=pk,Kk(_,0),Ck(_,j),Dk(_,B()),$;if($===6)throw Error(p$6(345));return _.finishedWork=_.current.alternate,_.finishedLanes=j,Pk(_,tk,uk),Dk(_,B()),null}function Qk(_,j){var $=K;K|=1;try{return _(j)}finally{K=$,K===0&&(Gj=B()+500,fg&&jg())}}function Rk(_){wk!==null&&wk.tag===0&&!(K&6)&&Hk();var j=K;K|=1;var $=ok.transition,_e=C$1;try{if(ok.transition=null,C$1=1,_)return _()}finally{C$1=_e,ok.transition=$,K=j,!(K&6)&&jg()}}function Hj(){fj=ej.current,E$2(ej)}function Kk(_,j){_.finishedWork=null,_.finishedLanes=0;var $=_.timeoutHandle;if($!==-1&&(_.timeoutHandle=-1,Gf($)),Y!==null)for($=Y.return;$!==null;){var _e=$;switch(wg(_e),_e.tag){case 1:_e=_e.type.childContextTypes,_e!=null&&$f();break;case 3:zh(),E$2(Wf),E$2(H),Eh();break;case 5:Bh(_e);break;case 4:zh();break;case 13:E$2(L$1);break;case 19:E$2(L$1);break;case 10:ah(_e.type._context);break;case 22:case 23:Hj()}$=$.return}if(Q=_,Y=_=Pg(_.current,null),Z=fj=j,T$1=0,pk=null,rk=qk=rh=0,tk=sk=null,fh!==null){for(j=0;j<fh.length;j++)if($=fh[j],_e=$.interleaved,_e!==null){$.interleaved=null;var et=_e.next,tt=$.pending;if(tt!==null){var nt=tt.next;tt.next=et,_e.next=nt}$.pending=_e}fh=null}return _}function Mk(_,j){do{var $=Y;try{if($g(),Fh.current=Rh,Ih){for(var _e=M$1.memoizedState;_e!==null;){var et=_e.queue;et!==null&&(et.pending=null),_e=_e.next}Ih=!1}if(Hh=0,O$1=N=M$1=null,Jh=!1,Kh=0,nk.current=null,$===null||$.return===null){T$1=1,pk=j,Y=null;break}e:{var tt=_,nt=$.return,rt=$,at=j;if(j=Z,rt.flags|=32768,at!==null&&typeof at=="object"&&typeof at.then=="function"){var it=at,ot=rt,st=ot.tag;if(!(ot.mode&1)&&(st===0||st===11||st===15)){var ct=ot.alternate;ct?(ot.updateQueue=ct.updateQueue,ot.memoizedState=ct.memoizedState,ot.lanes=ct.lanes):(ot.updateQueue=null,ot.memoizedState=null)}var pt=Ui(nt);if(pt!==null){pt.flags&=-257,Vi(pt,nt,rt,tt,j),pt.mode&1&&Si(tt,it,j),j=pt,at=it;var dt=j.updateQueue;if(dt===null){var ft=new Set;ft.add(at),j.updateQueue=ft}else dt.add(at);break e}else{if(!(j&1)){Si(tt,it,j),tj();break e}at=Error(p$6(426))}}else if(I&&rt.mode&1){var gt=Ui(nt);if(gt!==null){!(gt.flags&65536)&&(gt.flags|=256),Vi(gt,nt,rt,tt,j),Jg(Ji(at,rt));break e}}tt=at=Ji(at,rt),T$1!==4&&(T$1=2),sk===null?sk=[tt]:sk.push(tt),tt=nt;do{switch(tt.tag){case 3:tt.flags|=65536,j&=-j,tt.lanes|=j;var ut=Ni(tt,at,j);ph(tt,ut);break e;case 1:rt=at;var lt=tt.type,ht=tt.stateNode;if(!(tt.flags&128)&&(typeof lt.getDerivedStateFromError=="function"||ht!==null&&typeof ht.componentDidCatch=="function"&&(Ri===null||!Ri.has(ht)))){tt.flags|=65536,j&=-j,tt.lanes|=j;var yt=Qi(tt,rt,j);ph(tt,yt);break e}}tt=tt.return}while(tt!==null)}Sk($)}catch(vt){j=vt,Y===$&&$!==null&&(Y=$=$.return);continue}break}while(!0)}function Jk(){var _=mk.current;return mk.current=Rh,_===null?Rh:_}function tj(){(T$1===0||T$1===3||T$1===2)&&(T$1=4),Q===null||!(rh&268435455)&&!(qk&268435455)||Ck(Q,Z)}function Ik(_,j){var $=K;K|=2;var _e=Jk();(Q!==_||Z!==j)&&(uk=null,Kk(_,j));do try{Tk();break}catch(et){Mk(_,et)}while(!0);if($g(),K=$,mk.current=_e,Y!==null)throw Error(p$6(261));return Q=null,Z=0,T$1}function Tk(){for(;Y!==null;)Uk(Y)}function Lk(){for(;Y!==null&&!cc();)Uk(Y)}function Uk(_){var j=Vk(_.alternate,_,fj);_.memoizedProps=_.pendingProps,j===null?Sk(_):Y=j,nk.current=null}function Sk(_){var j=_;do{var $=j.alternate;if(_=j.return,j.flags&32768){if($=Ij($,j),$!==null){$.flags&=32767,Y=$;return}if(_!==null)_.flags|=32768,_.subtreeFlags=0,_.deletions=null;else{T$1=6,Y=null;return}}else if($=Ej($,j,fj),$!==null){Y=$;return}if(j=j.sibling,j!==null){Y=j;return}Y=j=_}while(j!==null);T$1===0&&(T$1=5)}function Pk(_,j,$){var _e=C$1,et=ok.transition;try{ok.transition=null,C$1=1,Wk(_,j,$,_e)}finally{ok.transition=et,C$1=_e}return null}function Wk(_,j,$,_e){do Hk();while(wk!==null);if(K&6)throw Error(p$6(327));$=_.finishedWork;var et=_.finishedLanes;if($===null)return null;if(_.finishedWork=null,_.finishedLanes=0,$===_.current)throw Error(p$6(177));_.callbackNode=null,_.callbackPriority=0;var tt=$.lanes|$.childLanes;if(Bc(_,tt),_===Q&&(Y=Q=null,Z=0),!($.subtreeFlags&2064)&&!($.flags&2064)||vk||(vk=!0,Fk(hc,function(){return Hk(),null})),tt=($.flags&15990)!==0,$.subtreeFlags&15990||tt){tt=ok.transition,ok.transition=null;var nt=C$1;C$1=1;var rt=K;K|=4,nk.current=null,Oj(_,$),dk($,_),Oe(Df),dd=!!Cf,Df=Cf=null,_.current=$,hk($),dc(),K=rt,C$1=nt,ok.transition=tt}else _.current=$;if(vk&&(vk=!1,wk=_,xk=et),tt=_.pendingLanes,tt===0&&(Ri=null),mc($.stateNode),Dk(_,B()),j!==null)for(_e=_.onRecoverableError,$=0;$<j.length;$++)et=j[$],_e(et.value,{componentStack:et.stack,digest:et.digest});if(Oi)throw Oi=!1,_=Pi,Pi=null,_;return xk&1&&_.tag!==0&&Hk(),tt=_.pendingLanes,tt&1?_===zk?yk++:(yk=0,zk=_):yk=0,jg(),null}function Hk(){if(wk!==null){var _=Dc(xk),j=ok.transition,$=C$1;try{if(ok.transition=null,C$1=16>_?16:_,wk===null)var _e=!1;else{if(_=wk,wk=null,xk=0,K&6)throw Error(p$6(331));var et=K;for(K|=4,V=_.current;V!==null;){var tt=V,nt=tt.child;if(V.flags&16){var rt=tt.deletions;if(rt!==null){for(var at=0;at<rt.length;at++){var it=rt[at];for(V=it;V!==null;){var ot=V;switch(ot.tag){case 0:case 11:case 15:Pj(8,ot,tt)}var st=ot.child;if(st!==null)st.return=ot,V=st;else for(;V!==null;){ot=V;var ct=ot.sibling,pt=ot.return;if(Sj(ot),ot===it){V=null;break}if(ct!==null){ct.return=pt,V=ct;break}V=pt}}}var dt=tt.alternate;if(dt!==null){var ft=dt.child;if(ft!==null){dt.child=null;do{var gt=ft.sibling;ft.sibling=null,ft=gt}while(ft!==null)}}V=tt}}if(tt.subtreeFlags&2064&&nt!==null)nt.return=tt,V=nt;else e:for(;V!==null;){if(tt=V,tt.flags&2048)switch(tt.tag){case 0:case 11:case 15:Pj(9,tt,tt.return)}var ut=tt.sibling;if(ut!==null){ut.return=tt.return,V=ut;break e}V=tt.return}}var lt=_.current;for(V=lt;V!==null;){nt=V;var ht=nt.child;if(nt.subtreeFlags&2064&&ht!==null)ht.return=nt,V=ht;else e:for(nt=lt;V!==null;){if(rt=V,rt.flags&2048)try{switch(rt.tag){case 0:case 11:case 15:Qj(9,rt)}}catch(vt){W(rt,rt.return,vt)}if(rt===nt){V=null;break e}var yt=rt.sibling;if(yt!==null){yt.return=rt.return,V=yt;break e}V=rt.return}}if(K=et,jg(),lc&&typeof lc.onPostCommitFiberRoot=="function")try{lc.onPostCommitFiberRoot(kc,_)}catch{}_e=!0}return _e}finally{C$1=$,ok.transition=j}}return!1}function Xk(_,j,$){j=Ji($,j),j=Ni(_,j,1),_=nh(_,j,1),j=R$1(),_!==null&&(Ac(_,1,j),Dk(_,j))}function W(_,j,$){if(_.tag===3)Xk(_,_,$);else for(;j!==null;){if(j.tag===3){Xk(j,_,$);break}else if(j.tag===1){var _e=j.stateNode;if(typeof j.type.getDerivedStateFromError=="function"||typeof _e.componentDidCatch=="function"&&(Ri===null||!Ri.has(_e))){_=Ji($,_),_=Qi(j,_,1),j=nh(j,_,1),_=R$1(),j!==null&&(Ac(j,1,_),Dk(j,_));break}}j=j.return}}function Ti(_,j,$){var _e=_.pingCache;_e!==null&&_e.delete(j),j=R$1(),_.pingedLanes|=_.suspendedLanes&$,Q===_&&(Z&$)===$&&(T$1===4||T$1===3&&(Z&130023424)===Z&&500>B()-fk?Kk(_,0):rk|=$),Dk(_,j)}function Yk(_,j){j===0&&(_.mode&1?(j=sc,sc<<=1,!(sc&130023424)&&(sc=4194304)):j=1);var $=R$1();_=ih(_,j),_!==null&&(Ac(_,j,$),Dk(_,$))}function uj(_){var j=_.memoizedState,$=0;j!==null&&($=j.retryLane),Yk(_,$)}function bk(_,j){var $=0;switch(_.tag){case 13:var _e=_.stateNode,et=_.memoizedState;et!==null&&($=et.retryLane);break;case 19:_e=_.stateNode;break;default:throw Error(p$6(314))}_e!==null&&_e.delete(j),Yk(_,$)}var Vk;Vk=function(_,j,$){if(_!==null)if(_.memoizedProps!==j.pendingProps||Wf.current)dh=!0;else{if(!(_.lanes&$)&&!(j.flags&128))return dh=!1,yj(_,j,$);dh=!!(_.flags&131072)}else dh=!1,I&&j.flags&1048576&&ug(j,ng,j.index);switch(j.lanes=0,j.tag){case 2:var _e=j.type;ij(_,j),_=j.pendingProps;var et=Yf(j,H.current);ch(j,$),et=Nh(null,j,_e,_,et,$);var tt=Sh();return j.flags|=1,typeof et=="object"&&et!==null&&typeof et.render=="function"&&et.$$typeof===void 0?(j.tag=1,j.memoizedState=null,j.updateQueue=null,Zf(_e)?(tt=!0,cg(j)):tt=!1,j.memoizedState=et.state!==null&&et.state!==void 0?et.state:null,kh(j),et.updater=Ei,j.stateNode=et,et._reactInternals=j,Ii(j,_e,_,$),j=jj(null,j,_e,!0,tt,$)):(j.tag=0,I&&tt&&vg(j),Xi(null,j,et,$),j=j.child),j;case 16:_e=j.elementType;e:{switch(ij(_,j),_=j.pendingProps,et=_e._init,_e=et(_e._payload),j.type=_e,et=j.tag=Zk(_e),_=Ci(_e,_),et){case 0:j=cj(null,j,_e,_,$);break e;case 1:j=hj(null,j,_e,_,$);break e;case 11:j=Yi(null,j,_e,_,$);break e;case 14:j=$i(null,j,_e,Ci(_e.type,_),$);break e}throw Error(p$6(306,_e,""))}return j;case 0:return _e=j.type,et=j.pendingProps,et=j.elementType===_e?et:Ci(_e,et),cj(_,j,_e,et,$);case 1:return _e=j.type,et=j.pendingProps,et=j.elementType===_e?et:Ci(_e,et),hj(_,j,_e,et,$);case 3:e:{if(kj(j),_===null)throw Error(p$6(387));_e=j.pendingProps,tt=j.memoizedState,et=tt.element,lh(_,j),qh(j,_e,null,$);var nt=j.memoizedState;if(_e=nt.element,tt.isDehydrated)if(tt={element:_e,isDehydrated:!1,cache:nt.cache,pendingSuspenseBoundaries:nt.pendingSuspenseBoundaries,transitions:nt.transitions},j.updateQueue.baseState=tt,j.memoizedState=tt,j.flags&256){et=Ji(Error(p$6(423)),j),j=lj(_,j,_e,$,et);break e}else if(_e!==et){et=Ji(Error(p$6(424)),j),j=lj(_,j,_e,$,et);break e}else for(yg=Lf(j.stateNode.containerInfo.firstChild),xg=j,I=!0,zg=null,$=Vg(j,null,_e,$),j.child=$;$;)$.flags=$.flags&-3|4096,$=$.sibling;else{if(Ig(),_e===et){j=Zi(_,j,$);break e}Xi(_,j,_e,$)}j=j.child}return j;case 5:return Ah(j),_===null&&Eg(j),_e=j.type,et=j.pendingProps,tt=_!==null?_.memoizedProps:null,nt=et.children,Ef(_e,et)?nt=null:tt!==null&&Ef(_e,tt)&&(j.flags|=32),gj(_,j),Xi(_,j,nt,$),j.child;case 6:return _===null&&Eg(j),null;case 13:return oj(_,j,$);case 4:return yh(j,j.stateNode.containerInfo),_e=j.pendingProps,_===null?j.child=Ug(j,null,_e,$):Xi(_,j,_e,$),j.child;case 11:return _e=j.type,et=j.pendingProps,et=j.elementType===_e?et:Ci(_e,et),Yi(_,j,_e,et,$);case 7:return Xi(_,j,j.pendingProps,$),j.child;case 8:return Xi(_,j,j.pendingProps.children,$),j.child;case 12:return Xi(_,j,j.pendingProps.children,$),j.child;case 10:e:{if(_e=j.type._context,et=j.pendingProps,tt=j.memoizedProps,nt=et.value,G(Wg,_e._currentValue),_e._currentValue=nt,tt!==null)if(He(tt.value,nt)){if(tt.children===et.children&&!Wf.current){j=Zi(_,j,$);break e}}else for(tt=j.child,tt!==null&&(tt.return=j);tt!==null;){var rt=tt.dependencies;if(rt!==null){nt=tt.child;for(var at=rt.firstContext;at!==null;){if(at.context===_e){if(tt.tag===1){at=mh(-1,$&-$),at.tag=2;var it=tt.updateQueue;if(it!==null){it=it.shared;var ot=it.pending;ot===null?at.next=at:(at.next=ot.next,ot.next=at),it.pending=at}}tt.lanes|=$,at=tt.alternate,at!==null&&(at.lanes|=$),bh(tt.return,$,j),rt.lanes|=$;break}at=at.next}}else if(tt.tag===10)nt=tt.type===j.type?null:tt.child;else if(tt.tag===18){if(nt=tt.return,nt===null)throw Error(p$6(341));nt.lanes|=$,rt=nt.alternate,rt!==null&&(rt.lanes|=$),bh(nt,$,j),nt=tt.sibling}else nt=tt.child;if(nt!==null)nt.return=tt;else for(nt=tt;nt!==null;){if(nt===j){nt=null;break}if(tt=nt.sibling,tt!==null){tt.return=nt.return,nt=tt;break}nt=nt.return}tt=nt}Xi(_,j,et.children,$),j=j.child}return j;case 9:return et=j.type,_e=j.pendingProps.children,ch(j,$),et=eh(et),_e=_e(et),j.flags|=1,Xi(_,j,_e,$),j.child;case 14:return _e=j.type,et=Ci(_e,j.pendingProps),et=Ci(_e.type,et),$i(_,j,_e,et,$);case 15:return bj(_,j,j.type,j.pendingProps,$);case 17:return _e=j.type,et=j.pendingProps,et=j.elementType===_e?et:Ci(_e,et),ij(_,j),j.tag=1,Zf(_e)?(_=!0,cg(j)):_=!1,ch(j,$),Gi(j,_e,et),Ii(j,_e,et,$),jj(null,j,_e,!0,_,$);case 19:return xj(_,j,$);case 22:return dj(_,j,$)}throw Error(p$6(156,j.tag))};function Fk(_,j){return ac(_,j)}function $k(_,j,$,_e){this.tag=_,this.key=$,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=j,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=_e,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(_,j,$,_e){return new $k(_,j,$,_e)}function aj(_){return _=_.prototype,!(!_||!_.isReactComponent)}function Zk(_){if(typeof _=="function")return aj(_)?1:0;if(_!=null){if(_=_.$$typeof,_===Da)return 11;if(_===Ga)return 14}return 2}function Pg(_,j){var $=_.alternate;return $===null?($=Bg(_.tag,j,_.key,_.mode),$.elementType=_.elementType,$.type=_.type,$.stateNode=_.stateNode,$.alternate=_,_.alternate=$):($.pendingProps=j,$.type=_.type,$.flags=0,$.subtreeFlags=0,$.deletions=null),$.flags=_.flags&14680064,$.childLanes=_.childLanes,$.lanes=_.lanes,$.child=_.child,$.memoizedProps=_.memoizedProps,$.memoizedState=_.memoizedState,$.updateQueue=_.updateQueue,j=_.dependencies,$.dependencies=j===null?null:{lanes:j.lanes,firstContext:j.firstContext},$.sibling=_.sibling,$.index=_.index,$.ref=_.ref,$}function Rg(_,j,$,_e,et,tt){var nt=2;if(_e=_,typeof _=="function")aj(_)&&(nt=1);else if(typeof _=="string")nt=5;else e:switch(_){case ya:return Tg($.children,et,tt,j);case za:nt=8,et|=8;break;case Aa:return _=Bg(12,$,j,et|2),_.elementType=Aa,_.lanes=tt,_;case Ea:return _=Bg(13,$,j,et),_.elementType=Ea,_.lanes=tt,_;case Fa:return _=Bg(19,$,j,et),_.elementType=Fa,_.lanes=tt,_;case Ia:return pj($,et,tt,j);default:if(typeof _=="object"&&_!==null)switch(_.$$typeof){case Ba:nt=10;break e;case Ca:nt=9;break e;case Da:nt=11;break e;case Ga:nt=14;break e;case Ha:nt=16,_e=null;break e}throw Error(p$6(130,_==null?_:typeof _,""))}return j=Bg(nt,$,j,et),j.elementType=_,j.type=_e,j.lanes=tt,j}function Tg(_,j,$,_e){return _=Bg(7,_,_e,j),_.lanes=$,_}function pj(_,j,$,_e){return _=Bg(22,_,_e,j),_.elementType=Ia,_.lanes=$,_.stateNode={isHidden:!1},_}function Qg(_,j,$){return _=Bg(6,_,null,j),_.lanes=$,_}function Sg(_,j,$){return j=Bg(4,_.children!==null?_.children:[],_.key,j),j.lanes=$,j.stateNode={containerInfo:_.containerInfo,pendingChildren:null,implementation:_.implementation},j}function al(_,j,$,_e,et){this.tag=j,this.containerInfo=_,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc(0),this.expirationTimes=zc(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc(0),this.identifierPrefix=_e,this.onRecoverableError=et,this.mutableSourceEagerHydrationData=null}function bl(_,j,$,_e,et,tt,nt,rt,at){return _=new al(_,j,$,rt,at),j===1?(j=1,tt===!0&&(j|=8)):j=0,tt=Bg(3,null,null,j),_.current=tt,tt.stateNode=_,tt.memoizedState={element:_e,isDehydrated:$,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh(tt),_}function cl(_,j,$){var _e=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa,key:_e==null?null:""+_e,children:_,containerInfo:j,implementation:$}}function dl(_){if(!_)return Vf;_=_._reactInternals;e:{if(Vb(_)!==_||_.tag!==1)throw Error(p$6(170));var j=_;do{switch(j.tag){case 3:j=j.stateNode.context;break e;case 1:if(Zf(j.type)){j=j.stateNode.__reactInternalMemoizedMergedChildContext;break e}}j=j.return}while(j!==null);throw Error(p$6(171))}if(_.tag===1){var $=_.type;if(Zf($))return bg(_,$,j)}return j}function el(_,j,$,_e,et,tt,nt,rt,at){return _=bl($,_e,!0,_,et,tt,nt,rt,at),_.context=dl(null),$=_.current,_e=R$1(),et=yi($),tt=mh(_e,et),tt.callback=j??null,nh($,tt,et),_.current.lanes=et,Ac(_,et,_e),Dk(_,_e),_}function fl(_,j,$,_e){var et=j.current,tt=R$1(),nt=yi(et);return $=dl($),j.context===null?j.context=$:j.pendingContext=$,j=mh(tt,nt),j.payload={element:_},_e=_e===void 0?null:_e,_e!==null&&(j.callback=_e),_=nh(et,j,nt),_!==null&&(gi(_,et,nt,tt),oh(_,et,nt)),nt}function gl(_){if(_=_.current,!_.child)return null;switch(_.child.tag){case 5:return _.child.stateNode;default:return _.child.stateNode}}function hl(_,j){if(_=_.memoizedState,_!==null&&_.dehydrated!==null){var $=_.retryLane;_.retryLane=$!==0&&$<j?$:j}}function il(_,j){hl(_,j),(_=_.alternate)&&hl(_,j)}function jl(){return null}var kl=typeof reportError=="function"?reportError:function(_){console.error(_)};function ll(_){this._internalRoot=_}ml.prototype.render=ll.prototype.render=function(_){var j=this._internalRoot;if(j===null)throw Error(p$6(409));fl(_,j,null,null)};ml.prototype.unmount=ll.prototype.unmount=function(){var _=this._internalRoot;if(_!==null){this._internalRoot=null;var j=_.containerInfo;Rk(function(){fl(null,_,null,null)}),j[uf]=null}};function ml(_){this._internalRoot=_}ml.prototype.unstable_scheduleHydration=function(_){if(_){var j=Hc();_={blockedOn:null,target:_,priority:j};for(var $=0;$<Qc.length&&j!==0&&j<Qc[$].priority;$++);Qc.splice($,0,_),$===0&&Vc(_)}};function nl(_){return!(!_||_.nodeType!==1&&_.nodeType!==9&&_.nodeType!==11)}function ol(_){return!(!_||_.nodeType!==1&&_.nodeType!==9&&_.nodeType!==11&&(_.nodeType!==8||_.nodeValue!==" react-mount-point-unstable "))}function pl(){}function ql(_,j,$,_e,et){if(et){if(typeof _e=="function"){var tt=_e;_e=function(){var it=gl(nt);tt.call(it)}}var nt=el(j,_e,_,0,null,!1,!1,"",pl);return _._reactRootContainer=nt,_[uf]=nt.current,sf(_.nodeType===8?_.parentNode:_),Rk(),nt}for(;et=_.lastChild;)_.removeChild(et);if(typeof _e=="function"){var rt=_e;_e=function(){var it=gl(at);rt.call(it)}}var at=bl(_,0,!1,null,null,!1,!1,"",pl);return _._reactRootContainer=at,_[uf]=at.current,sf(_.nodeType===8?_.parentNode:_),Rk(function(){fl(j,at,$,_e)}),at}function rl(_,j,$,_e,et){var tt=$._reactRootContainer;if(tt){var nt=tt;if(typeof et=="function"){var rt=et;et=function(){var at=gl(nt);rt.call(at)}}fl(j,nt,_,et)}else nt=ql($,j,_,et,_e);return gl(nt)}Ec=function(_){switch(_.tag){case 3:var j=_.stateNode;if(j.current.memoizedState.isDehydrated){var $=tc(j.pendingLanes);$!==0&&(Cc(j,$|1),Dk(j,B()),!(K&6)&&(Gj=B()+500,jg()))}break;case 13:Rk(function(){var _e=ih(_,1);if(_e!==null){var et=R$1();gi(_e,_,1,et)}}),il(_,1)}};Fc=function(_){if(_.tag===13){var j=ih(_,134217728);if(j!==null){var $=R$1();gi(j,_,134217728,$)}il(_,134217728)}};Gc=function(_){if(_.tag===13){var j=yi(_),$=ih(_,j);if($!==null){var _e=R$1();gi($,_,j,_e)}il(_,j)}};Hc=function(){return C$1};Ic=function(_,j){var $=C$1;try{return C$1=_,j()}finally{C$1=$}};yb=function(_,j,$){switch(j){case"input":if(bb(_,$),j=$.name,$.type==="radio"&&j!=null){for($=_;$.parentNode;)$=$.parentNode;for($=$.querySelectorAll("input[name="+JSON.stringify(""+j)+'][type="radio"]'),j=0;j<$.length;j++){var _e=$[j];if(_e!==_&&_e.form===_.form){var et=Db(_e);if(!et)throw Error(p$6(90));Wa(_e),bb(_e,et)}}}break;case"textarea":ib(_,$);break;case"select":j=$.value,j!=null&&fb(_,!!$.multiple,j,!1)}};Gb=Qk;Hb=Rk;var sl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(_){return _=Zb(_),_===null?null:_.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||jl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;reactDom_production_min.createPortal=function(_,j){var $=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl(j))throw Error(p$6(200));return cl(_,j,null,$)};reactDom_production_min.createRoot=function(_,j){if(!nl(_))throw Error(p$6(299));var $=!1,_e="",et=kl;return j!=null&&(j.unstable_strictMode===!0&&($=!0),j.identifierPrefix!==void 0&&(_e=j.identifierPrefix),j.onRecoverableError!==void 0&&(et=j.onRecoverableError)),j=bl(_,1,!1,null,null,$,!1,_e,et),_[uf]=j.current,sf(_.nodeType===8?_.parentNode:_),new ll(j)};reactDom_production_min.findDOMNode=function(_){if(_==null)return null;if(_.nodeType===1)return _;var j=_._reactInternals;if(j===void 0)throw typeof _.render=="function"?Error(p$6(188)):(_=Object.keys(_).join(","),Error(p$6(268,_)));return _=Zb(j),_=_===null?null:_.stateNode,_};reactDom_production_min.flushSync=function(_){return Rk(_)};reactDom_production_min.hydrate=function(_,j,$){if(!ol(j))throw Error(p$6(200));return rl(null,_,j,!0,$)};reactDom_production_min.hydrateRoot=function(_,j,$){if(!nl(_))throw Error(p$6(405));var _e=$!=null&&$.hydratedSources||null,et=!1,tt="",nt=kl;if($!=null&&($.unstable_strictMode===!0&&(et=!0),$.identifierPrefix!==void 0&&(tt=$.identifierPrefix),$.onRecoverableError!==void 0&&(nt=$.onRecoverableError)),j=el(j,null,_,1,$??null,et,!1,tt,nt),_[uf]=j.current,sf(_),_e)for(_=0;_<_e.length;_++)$=_e[_],et=$._getVersion,et=et($._source),j.mutableSourceEagerHydrationData==null?j.mutableSourceEagerHydrationData=[$,et]:j.mutableSourceEagerHydrationData.push($,et);return new ml(j)};reactDom_production_min.render=function(_,j,$){if(!ol(j))throw Error(p$6(200));return rl(null,_,j,!1,$)};reactDom_production_min.unmountComponentAtNode=function(_){if(!ol(_))throw Error(p$6(40));return _._reactRootContainer?(Rk(function(){rl(null,null,_,!1,function(){_._reactRootContainer=null,_[uf]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(_,j,$,_e){if(!ol($))throw Error(p$6(200));if(_==null||_._reactInternals===void 0)throw Error(p$6(38));return rl(_,j,$,!1,_e)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(_){console.error(_)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports;const ReactDOM=getDefaultExportFromCjs(reactDomExports);var m$3=reactDomExports;client.createRoot=m$3.createRoot,client.hydrateRoot=m$3.hydrateRoot;var Intent={NONE:"none",PRIMARY:"primary",SUCCESS:"success",WARNING:"warning",DANGER:"danger"},NS$1="bp5";typeof BLUEPRINT_NAMESPACE<"u"?NS$1=BLUEPRINT_NAMESPACE:typeof REACT_APP_BLUEPRINT_NAMESPACE<"u"&&(NS$1=REACT_APP_BLUEPRINT_NAMESPACE);var DARK="".concat(NS$1,"-dark"),DISABLED="".concat(NS$1,"-disabled"),FILL="".concat(NS$1,"-fill"),INLINE="".concat(NS$1,"-inline"),LARGE="".concat(NS$1,"-large"),MINIMAL="".concat(NS$1,"-minimal");intentClass(Intent.PRIMARY);intentClass(Intent.SUCCESS);intentClass(Intent.WARNING);intentClass(Intent.DANGER);var BUTTON="".concat(NS$1,"-button"),BUTTON_GROUP="".concat(BUTTON,"-group"),HTML_SELECT="".concat(NS$1,"-html-select"),LABEL="".concat(NS$1,"-label"),NAVBAR="".concat(NS$1,"-navbar"),NAVBAR_GROUP="".concat(NAVBAR,"-group"),NAVBAR_HEADING="".concat(NAVBAR,"-heading"),OVERLAY="".concat(NS$1,"-overlay"),OVERLAY_BACKDROP="".concat(OVERLAY,"-backdrop"),OVERLAY_CONTENT="".concat(OVERLAY,"-content"),OVERLAY_INLINE="".concat(OVERLAY,"-inline"),OVERLAY_OPEN="".concat(OVERLAY,"-open"),OVERLAY_START_FOCUS_TRAP="".concat(OVERLAY,"-start-focus-trap"),OVERLAY_END_FOCUS_TRAP="".concat(OVERLAY,"-end-focus-trap"),PORTAL="".concat(NS$1,"-portal");function iconClass(_){if(_!=null)return _.indexOf("".concat(NS$1,"-icon-"))===0?_:"".concat(NS$1,"-icon-").concat(_)}function intentClass(_){if(!(_==null||_===Intent.NONE))return"".concat(NS$1,"-intent-").concat(_.toLowerCase())}var __assign$4=function(){return __assign$4=Object.assign||function(j){for(var $,_e=1,et=arguments.length;_e<et;_e++){$=arguments[_e];for(var tt in $)Object.prototype.hasOwnProperty.call($,tt)&&(j[tt]=$[tt])}return j},__assign$4.apply(this,arguments)};function __rest(_,j){var $={};for(var _e in _)Object.prototype.hasOwnProperty.call(_,_e)&&j.indexOf(_e)<0&&($[_e]=_[_e]);if(_!=null&&typeof Object.getOwnPropertySymbols=="function")for(var et=0,_e=Object.getOwnPropertySymbols(_);et<_e.length;et++)j.indexOf(_e[et])<0&&Object.prototype.propertyIsEnumerable.call(_,_e[et])&&($[_e[et]]=_[_e[et]]);return $}typeof SuppressedError=="function"&&SuppressedError;function hasDOMEnvironment(){return typeof window<"u"&&window.document!=null}function getActiveElement(_,j){var $;if(_==null)return document.activeElement;var _e=($=_.getRootNode(j))!==null&&$!==void 0?$:document;return _e.activeElement}var ns="[Blueprint]",PORTAL_CONTEXT_CLASS_NAME_STRING=ns+" <Portal> context blueprintPortalClassName must be string",PORTAL_LEGACY_CONTEXT_API=ns+" setting blueprintPortalClassName via legacy React context API is deprecated, use <PortalProvider> instead.",OVERLAY2_REQUIRES_OVERLAY_PROVDER=ns+" <Overlay2> was used outside of a <OverlaysProvider> context. This will no longer be supported in Blueprint v6. See https://github.com/palantir/blueprint/wiki/Overlay2-migration",OVERLAY_CHILD_REF_AND_REFS_MUTEX=ns+" <Overlay2> cannot use childRef and childRefs props simultaneously",OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS=ns+" <Overlay2> requires childRefs prop when rendering multiple child elements",OVERLAY_CHILD_REQUIRES_KEY=ns+" <Overlay2> requires each child element to have a unique key prop when childRefs is used";function isNodeEnv(_){return typeof NODE_ENV<"u"&&NODE_ENV===_}function isEmptyString(_){return typeof _=="string"&&_.trim().length===0}function ensureElement(_,j,$){if($===void 0&&($={}),!(_==null||typeof _=="boolean"||isEmptyString(_)))return typeof _=="string"||typeof _=="number"||isReactFragment(_)||isReactNodeArray(_)?reactExports.createElement(j,$,_):isReactElement(_)?Object.keys($).length>0?reactExports.cloneElement(_,$):_:void 0}function isReactElement(_){return typeof _=="object"&&typeof _.type<"u"&&typeof _.props<"u"}function isReactFragment(_){return typeof _.type=="symbol"}function isReactNodeArray(_){return Array.isArray(_)}function isReact18(){return reactExports.version.startsWith("18")}function isRefObject(_){return _!=null&&typeof _!="function"}function isRefCallback(_){return typeof _=="function"}function setRef$1(_,j){isRefObject(_)?_.current=j:isRefCallback(_)&&_(j)}function mergeRefs(){for(var _=[],j=0;j<arguments.length;j++)_[j]=arguments[j];return function($){_.forEach(function(_e){setRef$1(_e,$)})}}function getRef(_){return _===null?null:typeof _.current>"u"?_:_.current}var DISPLAYNAME_PREFIX="Blueprint5",classnames={exports:{}};/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function(_){(function(){var j={}.hasOwnProperty;function $(){for(var tt="",nt=0;nt<arguments.length;nt++){var rt=arguments[nt];rt&&(tt=et(tt,_e(rt)))}return tt}function _e(tt){if(typeof tt=="string"||typeof tt=="number")return tt;if(typeof tt!="object")return"";if(Array.isArray(tt))return $.apply(null,tt);if(tt.toString!==Object.prototype.toString&&!tt.toString.toString().includes("[native code]"))return tt.toString();var nt="";for(var rt in tt)j.call(tt,rt)&&tt[rt]&&(nt=et(nt,rt));return nt}function et(tt,nt){return nt?tt?tt+" "+nt:tt+nt:tt}_.exports?($.default=$,_.exports=$):window.classNames=$})()})(classnames);var classnamesExports=classnames.exports;const classNames=getDefaultExportFromCjs(classnamesExports);function lowerCase(_){return _.toLowerCase()}var DEFAULT_SPLIT_REGEXP=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],DEFAULT_STRIP_REGEXP=/[^A-Z0-9]+/gi;function noCase(_,j){j===void 0&&(j={});for(var $=j.splitRegexp,_e=$===void 0?DEFAULT_SPLIT_REGEXP:$,et=j.stripRegexp,tt=et===void 0?DEFAULT_STRIP_REGEXP:et,nt=j.transform,rt=nt===void 0?lowerCase:nt,at=j.delimiter,it=at===void 0?" ":at,ot=replace(replace(_,_e,"$1\0$2"),tt,"\0"),st=0,ct=ot.length;ot.charAt(st)==="\0";)st++;for(;ot.charAt(ct-1)==="\0";)ct--;return ot.slice(st,ct).split("\0").map(rt).join(it)}function replace(_,j,$){return j instanceof RegExp?_.replace(j,$):j.reduce(function(_e,et){return _e.replace(et,$)},_)}function pascalCaseTransform(_,j){var $=_.charAt(0),_e=_.substr(1).toLowerCase();return j>0&&$>="0"&&$<="9"?"_"+$+_e:""+$.toUpperCase()+_e}function pascalCase(_,j){return j===void 0&&(j={}),noCase(_,__assign$4({delimiter:"",transform:pascalCaseTransform},j))}function dotCase(_,j){return j===void 0&&(j={}),noCase(_,__assign$4({delimiter:"."},j))}function snakeCase(_,j){return j===void 0&&(j={}),dotCase(_,__assign$4({delimiter:"_"},j))}var IconSize;(function(_){_[_.STANDARD=16]="STANDARD",_[_.LARGE=20]="LARGE"})(IconSize||(IconSize={}));var _a$1,BlueprintIcons_16;(function(_){_.AddClip="add-clip",_.AddColumnLeft="add-column-left",_.AddColumnRight="add-column-right",_.AddLocation="add-location",_.AddRowBottom="add-row-bottom",_.AddRowTop="add-row-top",_.AddToArtifact="add-to-artifact",_.AddToFolder="add-to-folder",_.Add="add",_.AimpointsTarget="aimpoints-target",_.Airplane="airplane",_.AlignCenter="align-center",_.AlignJustify="align-justify",_.AlignLeft="align-left",_.AlignRight="align-right",_.AlignmentBottom="alignment-bottom",_.AlignmentHorizontalCenter="alignment-horizontal-center",_.AlignmentLeft="alignment-left",_.AlignmentRight="alignment-right",_.AlignmentTop="alignment-top",_.AlignmentVerticalCenter="alignment-vertical-center",_.Ammunition="ammunition",_.Anchor="anchor",_.Annotation="annotation",_.Antenna="antenna",_.AppHeader="app-header",_.Application="application",_.Applications="applications",_.Archive="archive",_.AreaOfInterest="area-of-interest",_.ArrayBoolean="array-boolean",_.ArrayDate="array-date",_.ArrayFloatingPoint="array-floating-point",_.ArrayNumeric="array-numeric",_.ArrayString="array-string",_.ArrayTimestamp="array-timestamp",_.Array="array",_.ArrowBottomLeft="arrow-bottom-left",_.ArrowBottomRight="arrow-bottom-right",_.ArrowDown="arrow-down",_.ArrowLeft="arrow-left",_.ArrowRight="arrow-right",_.ArrowTopLeft="arrow-top-left",_.ArrowTopRight="arrow-top-right",_.ArrowUp="arrow-up",_.ArrowsHorizontal="arrows-horizontal",_.ArrowsVertical="arrows-vertical",_.Asterisk="asterisk",_.At="at",_.AutomaticUpdates="automatic-updates",_.Axle="axle",_.Backlink="backlink",_.BackwardTen="backward-ten",_.Badge="badge",_.BanCircle="ban-circle",_.BankAccount="bank-account",_.Barcode="barcode",_.BinaryNumber="binary-number",_.Blank="blank",_.BlockedPerson="blocked-person",_.Bold="bold",_.Book="book",_.Bookmark="bookmark",_.Box="box",_.Briefcase="briefcase",_.BringData="bring-data",_.BringForward="bring-forward",_.Bug="bug",_.Buggy="buggy",_.Build="build",_.Bullseye="bullseye",_.Calculator="calculator",_.Calendar="calendar",_.Camera="camera",_.CaretDown="caret-down",_.CaretLeft="caret-left",_.CaretRight="caret-right",_.CaretUp="caret-up",_.CargoShip="cargo-ship",_.CellTower="cell-tower",_.Changes="changes",_.Chart="chart",_.Chat="chat",_.ChevronBackward="chevron-backward",_.ChevronDown="chevron-down",_.ChevronForward="chevron-forward",_.ChevronLeft="chevron-left",_.ChevronRight="chevron-right",_.ChevronUp="chevron-up",_.CircleArrowDown="circle-arrow-down",_.CircleArrowLeft="circle-arrow-left",_.CircleArrowRight="circle-arrow-right",_.CircleArrowUp="circle-arrow-up",_.Circle="circle",_.Citation="citation",_.Clean="clean",_.Clip="clip",_.ClipboardFile="clipboard-file",_.Clipboard="clipboard",_.CloudDownload="cloud-download",_.CloudServer="cloud-server",_.CloudTick="cloud-tick",_.CloudUpload="cloud-upload",_.Cloud="cloud",_.CodeBlock="code-block",_.Code="code",_.Cog="cog",_.CollapseAll="collapse-all",_.ColorFill="color-fill",_.ColumnLayout="column-layout",_.Comment="comment",_.Comparison="comparison",_.Compass="compass",_.Compressed="compressed",_.Confirm="confirm",_.Console="console",_.Contrast="contrast",_.Control="control",_.CreditCard="credit-card",_.Crop="crop",_.CrossCircle="cross-circle",_.Cross="cross",_.Crown="crown",_.CubeAdd="cube-add",_.CubeRemove="cube-remove",_.Cube="cube",_.CurlyBraces="curly-braces",_.CurvedRangeChart="curved-range-chart",_.Cut="cut",_.Cycle="cycle",_.Dashboard="dashboard",_.DataConnection="data-connection",_.DataLineage="data-lineage",_.Database="database",_.Delete="delete",_.Delta="delta",_.DeriveColumn="derive-column",_.Desktop="desktop",_.Detection="detection",_.Diagnosis="diagnosis",_.DiagramTree="diagram-tree",_.DirectionLeft="direction-left",_.DirectionRight="direction-right",_.Disable="disable",_.Divide="divide",_.DocumentOpen="document-open",_.DocumentShare="document-share",_.Document="document",_.Dollar="dollar",_.Dot="dot",_.DoubleCaretHorizontal="double-caret-horizontal",_.DoubleCaretVertical="double-caret-vertical",_.DoubleChevronDown="double-chevron-down",_.DoubleChevronLeft="double-chevron-left",_.DoubleChevronRight="double-chevron-right",_.DoubleChevronUp="double-chevron-up",_.DoughnutChart="doughnut-chart",_.Download="download",_.DragHandleHorizontal="drag-handle-horizontal",_.DragHandleVertical="drag-handle-vertical",_.Draw="draw",_.DrawerLeftFilled="drawer-left-filled",_.DrawerLeft="drawer-left",_.DrawerRightFilled="drawer-right-filled",_.DrawerRight="drawer-right",_.DriveTime="drive-time",_.Duplicate="duplicate",_.Edit="edit",_.Eject="eject",_.Emoji="emoji",_.Endnote="endnote",_.Endorsed="endorsed",_.Envelope="envelope",_.Equals="equals",_.Eraser="eraser",_.Error="error",_.Euro="euro",_.Exchange="exchange",_.ExcludeRow="exclude-row",_.ExpandAll="expand-all",_.Explain="explain",_.Export="export",_.EyeOff="eye-off",_.EyeOn="eye-on",_.EyeOpen="eye-open",_.FastBackward="fast-backward",_.FastForward="fast-forward",_.FeedSubscribed="feed-subscribed",_.Feed="feed",_.Film="film",_.FilterKeep="filter-keep",_.FilterList="filter-list",_.FilterOpen="filter-open",_.FilterRemove="filter-remove",_.Filter="filter",_.Flag="flag",_.Flame="flame",_.Flash="flash",_.FloatingPoint="floating-point",_.FloppyDisk="floppy-disk",_.FlowBranch="flow-branch",_.FlowEnd="flow-end",_.FlowLinear="flow-linear",_.FlowReviewBranch="flow-review-branch",_.FlowReview="flow-review",_.Flows="flows",_.FolderClose="folder-close",_.FolderNew="folder-new",_.FolderOpen="folder-open",_.FolderSharedOpen="folder-shared-open",_.FolderShared="folder-shared",_.Follower="follower",_.Following="following",_.Font="font",_.Fork="fork",_.Form="form",_.ForwardTen="forward-ten",_.Fuel="fuel",_.FullCircle="full-circle",_.FullStackedChart="full-stacked-chart",_.Fullscreen="fullscreen",_.Function="function",_.GanttChart="gantt-chart",_.Generate="generate",_.Geofence="geofence",_.Geolocation="geolocation",_.Geosearch="geosearch",_.Geotime="geotime",_.GitBranch="git-branch",_.GitCommit="git-commit",_.GitMerge="git-merge",_.GitNewBranch="git-new-branch",_.GitPull="git-pull",_.GitPush="git-push",_.GitRepo="git-repo",_.Glass="glass",_.GlobeNetwork="globe-network",_.Globe="globe",_.GraphRemove="graph-remove",_.Graph="graph",_.GreaterThanOrEqualTo="greater-than-or-equal-to",_.GreaterThan="greater-than",_.GridView="grid-view",_.Grid="grid",_.GroupItem="group-item",_.GroupObjects="group-objects",_.GroupedBarChart="grouped-bar-chart",_.HandDown="hand-down",_.HandLeft="hand-left",_.HandRight="hand-right",_.HandUp="hand-up",_.Hand="hand",_.Hat="hat",_.HeaderOne="header-one",_.HeaderThree="header-three",_.HeaderTwo="header-two",_.Header="header",_.Headset="headset",_.HeartBroken="heart-broken",_.Heart="heart",_.HeatGrid="heat-grid",_.Heatmap="heatmap",_.Helicopter="helicopter",_.Help="help",_.HelperManagement="helper-management",_.HighPriority="high-priority",_.HighVoltagePole="high-voltage-pole",_.Highlight="highlight",_.History="history",_.Home="home",_.HorizontalBarChartAsc="horizontal-bar-chart-asc",_.HorizontalBarChartDesc="horizontal-bar-chart-desc",_.HorizontalBarChart="horizontal-bar-chart",_.HorizontalDistribution="horizontal-distribution",_.HorizontalInbetween="horizontal-inbetween",_.Hurricane="hurricane",_.IdNumber="id-number",_.ImageRotateLeft="image-rotate-left",_.ImageRotateRight="image-rotate-right",_.Import="import",_.InboxFiltered="inbox-filtered",_.InboxGeo="inbox-geo",_.InboxSearch="inbox-search",_.InboxUpdate="inbox-update",_.Inbox="inbox",_.InfoSign="info-sign",_.Inheritance="inheritance",_.InheritedGroup="inherited-group",_.InnerJoin="inner-join",_.Input="input",_.Insert="insert",_.Intelligence="intelligence",_.Intersection="intersection",_.IpAddress="ip-address",_.IssueClosed="issue-closed",_.IssueNew="issue-new",_.Issue="issue",_.Italic="italic",_.JoinTable="join-table",_.KeyBackspace="key-backspace",_.KeyCommand="key-command",_.KeyControl="key-control",_.KeyDelete="key-delete",_.KeyEnter="key-enter",_.KeyEscape="key-escape",_.KeyOption="key-option",_.KeyShift="key-shift",_.KeyTab="key-tab",_.Key="key",_.KnownVehicle="known-vehicle",_.LabTest="lab-test",_.Label="label",_.LayerOutline="layer-outline",_.Layer="layer",_.Layers="layers",_.LayoutAuto="layout-auto",_.LayoutBalloon="layout-balloon",_.LayoutCircle="layout-circle",_.LayoutGrid="layout-grid",_.LayoutGroupBy="layout-group-by",_.LayoutHierarchy="layout-hierarchy",_.LayoutLinear="layout-linear",_.LayoutSkewGrid="layout-skew-grid",_.LayoutSortedClusters="layout-sorted-clusters",_.Layout="layout",_.Learning="learning",_.LeftJoin="left-join",_.LengthenText="lengthen-text",_.LessThanOrEqualTo="less-than-or-equal-to",_.LessThan="less-than",_.Lifesaver="lifesaver",_.Lightbulb="lightbulb",_.Lightning="lightning",_.Link="link",_.ListColumns="list-columns",_.ListDetailView="list-detail-view",_.List="list",_.Locate="locate",_.Lock="lock",_.Locomotive="locomotive",_.LogIn="log-in",_.LogOut="log-out",_.LowVoltagePole="low-voltage-pole",_.Manual="manual",_.ManuallyEnteredData="manually-entered-data",_.ManyToMany="many-to-many",_.ManyToOne="many-to-one",_.MapCreate="map-create",_.MapMarker="map-marker",_.Map="map",_.Maximize="maximize",_.Media="media",_.MenuClosed="menu-closed",_.MenuOpen="menu-open",_.Menu="menu",_.MergeColumns="merge-columns",_.MergeLinks="merge-links",_.Microphone="microphone",_.Minimize="minimize",_.Minus="minus",_.MobilePhone="mobile-phone",_.MobileVideo="mobile-video",_.ModalFilled="modal-filled",_.Modal="modal",_.Model="model",_.Moon="moon",_.More="more",_.Mountain="mountain",_.Move="move",_.Mugshot="mugshot",_.MultiSelect="multi-select",_.Music="music",_.Nest="nest",_.NewDrawing="new-drawing",_.NewGridItem="new-grid-item",_.NewLayer="new-layer",_.NewLayers="new-layers",_.NewLink="new-link",_.NewObject="new-object",_.NewPerson="new-person",_.NewPrescription="new-prescription",_.NewShield="new-shield",_.NewTextBox="new-text-box",_.Ninja="ninja",_.NotEqualTo="not-equal-to",_.NotificationsSnooze="notifications-snooze",_.NotificationsUpdated="notifications-updated",_.Notifications="notifications",_.NumberedList="numbered-list",_.Numerical="numerical",_.Office="office",_.Offline="offline",_.OilField="oil-field",_.OneColumn="one-column",_.OneToMany="one-to-many",_.OneToOne="one-to-one",_.OpenApplication="open-application",_.Outdated="outdated",_.PageLayout="page-layout",_.PanelStats="panel-stats",_.PanelTable="panel-table",_.Paperclip="paperclip",_.Paragraph="paragraph",_.PasteVariable="paste-variable",_.PathSearch="path-search",_.Path="path",_.Pause="pause",_.People="people",_.Percentage="percentage",_.Person="person",_.PhoneCall="phone-call",_.PhoneForward="phone-forward",_.Phone="phone",_.PieChart="pie-chart",_.Pin="pin",_.PivotTable="pivot-table",_.Pivot="pivot",_.Play="play",_.Playbook="playbook",_.Plus="plus",_.PolygonFilter="polygon-filter",_.Power="power",_.PredictiveAnalysis="predictive-analysis",_.Prescription="prescription",_.Presentation="presentation",_.Print="print",_.Projects="projects",_.Properties="properties",_.Property="property",_.PublishFunction="publish-function",_.Pulse="pulse",_.Rain="rain",_.Random="random",_.Record="record",_.RectHeight="rect-height",_.RectWidth="rect-width",_.Rectangle="rectangle",_.Redo="redo",_.Refresh="refresh",_.Regex="regex",_.RegressionChart="regression-chart",_.RemoveColumnLeft="remove-column-left",_.RemoveColumnRight="remove-column-right",_.RemoveColumn="remove-column",_.RemoveRowBottom="remove-row-bottom",_.RemoveRowTop="remove-row-top",_.Remove="remove",_.Repeat="repeat",_.Reset="reset",_.Resolve="resolve",_.Rig="rig",_.RightJoin="right-join",_.Ring="ring",_.RocketSlant="rocket-slant",_.Rocket="rocket",_.RotateDocument="rotate-document",_.RotatePage="rotate-page",_.Route="route",_.Satellite="satellite",_.Saved="saved",_.ScatterPlot="scatter-plot",_.SearchAround="search-around",_.SearchTemplate="search-template",_.SearchText="search-text",_.Search="search",_.SegmentedControl="segmented-control",_.Select="select",_.Selection="selection",_.SendBackward="send-backward",_.SendMessage="send-message",_.SendToGraph="send-to-graph",_.SendToMap="send-to-map",_.SendTo="send-to",_.Sensor="sensor",_.SeriesAdd="series-add",_.SeriesConfiguration="series-configuration",_.SeriesDerived="series-derived",_.SeriesFiltered="series-filtered",_.SeriesSearch="series-search",_.Settings="settings",_.Shapes="shapes",_.Share="share",_.SharedFilter="shared-filter",_.Shield="shield",_.Ship="ship",_.Shop="shop",_.ShoppingCart="shopping-cart",_.ShortenText="shorten-text",_.SignalSearch="signal-search",_.SimCard="sim-card",_.Slash="slash",_.SmallCross="small-cross",_.SmallInfoSign="small-info-sign",_.SmallMinus="small-minus",_.SmallPlus="small-plus",_.SmallSquare="small-square",_.SmallTick="small-tick",_.Snowflake="snowflake",_.SoccerBall="soccer-ball",_.SocialMedia="social-media",_.SortAlphabeticalDesc="sort-alphabetical-desc",_.SortAlphabetical="sort-alphabetical",_.SortAsc="sort-asc",_.SortDesc="sort-desc",_.SortNumericalDesc="sort-numerical-desc",_.SortNumerical="sort-numerical",_.Sort="sort",_.SpellCheck="spell-check",_.SplitColumns="split-columns",_.SportsStadium="sports-stadium",_.Square="square",_.StackedChart="stacked-chart",_.StadiumGeometry="stadium-geometry",_.StarEmpty="star-empty",_.Star="star",_.StepBackward="step-backward",_.StepChart="step-chart",_.StepForward="step-forward",_.Stop="stop",_.Stopwatch="stopwatch",_.Strikethrough="strikethrough",_.Style="style",_.Subscript="subscript",_.Superscript="superscript",_.SwapHorizontal="swap-horizontal",_.SwapVertical="swap-vertical",_.Switch="switch",_.SymbolCircle="symbol-circle",_.SymbolCross="symbol-cross",_.SymbolDiamond="symbol-diamond",_.SymbolRectangle="symbol-rectangle",_.SymbolSquare="symbol-square",_.SymbolTriangleDown="symbol-triangle-down",_.SymbolTriangleUp="symbol-triangle-up",_.Syringe="syringe",_.Tag="tag",_.TakeAction="take-action",_.Tank="tank",_.Target="target",_.Taxi="taxi",_.Team="team",_.Temperature="temperature",_.TextHighlight="text-highlight",_.ThDerived="th-derived",_.ThDisconnect="th-disconnect",_.ThFiltered="th-filtered",_.ThList="th-list",_.Th="th",_.ThirdParty="third-party",_.ThumbsDown="thumbs-down",_.ThumbsUp="thumbs-up",_.TickCircle="tick-circle",_.Tick="tick",_.Time="time",_.TimelineAreaChart="timeline-area-chart",_.TimelineBarChart="timeline-bar-chart",_.TimelineEvents="timeline-events",_.TimelineLineChart="timeline-line-chart",_.Tint="tint",_.Torch="torch",_.Tractor="tractor",_.Train="train",_.Translate="translate",_.Trash="trash",_.Tree="tree",_.TrendingDown="trending-down",_.TrendingUp="trending-up",_.Trophy="trophy",_.Truck="truck",_.TwoColumns="two-columns",_.Unarchive="unarchive",_.Underline="underline",_.Undo="undo",_.UngroupObjects="ungroup-objects",_.UnknownVehicle="unknown-vehicle",_.Unlink="unlink",_.Unlock="unlock",_.Unpin="unpin",_.Unresolve="unresolve",_.Updated="updated",_.Upload="upload",_.User="user",_.Variable="variable",_.VerticalBarChartAsc="vertical-bar-chart-asc",_.VerticalBarChartDesc="vertical-bar-chart-desc",_.VerticalDistribution="vertical-distribution",_.VerticalInbetween="vertical-inbetween",_.Video="video",_.Virus="virus",_.VolumeDown="volume-down",_.VolumeOff="volume-off",_.VolumeUp="volume-up",_.Walk="walk",_.WarningSign="warning-sign",_.WaterfallChart="waterfall-chart",_.Waves="waves",_.WidgetButton="widget-button",_.WidgetFooter="widget-footer",_.WidgetHeader="widget-header",_.Widget="widget",_.Wind="wind",_.Wrench="wrench",_.ZoomIn="zoom-in",_.ZoomOut="zoom-out",_.ZoomToFit="zoom-to-fit"})(BlueprintIcons_16||(BlueprintIcons_16={}));_a$1={},_a$1[BlueprintIcons_16.AddClip]="61697",_a$1[BlueprintIcons_16.AddColumnLeft]="61698",_a$1[BlueprintIcons_16.AddColumnRight]="61699",_a$1[BlueprintIcons_16.AddLocation]="61700",_a$1[BlueprintIcons_16.AddRowBottom]="61701",_a$1[BlueprintIcons_16.AddRowTop]="61702",_a$1[BlueprintIcons_16.AddToArtifact]="61703",_a$1[BlueprintIcons_16.AddToFolder]="61704",_a$1[BlueprintIcons_16.Add]="61705",_a$1[BlueprintIcons_16.AimpointsTarget]="62261",_a$1[BlueprintIcons_16.Airplane]="61706",_a$1[BlueprintIcons_16.AlignCenter]="61707",_a$1[BlueprintIcons_16.AlignJustify]="61708",_a$1[BlueprintIcons_16.AlignLeft]="61709",_a$1[BlueprintIcons_16.AlignRight]="61710",_a$1[BlueprintIcons_16.AlignmentBottom]="61711",_a$1[BlueprintIcons_16.AlignmentHorizontalCenter]="61712",_a$1[BlueprintIcons_16.AlignmentLeft]="61713",_a$1[BlueprintIcons_16.AlignmentRight]="61714",_a$1[BlueprintIcons_16.AlignmentTop]="61715",_a$1[BlueprintIcons_16.AlignmentVerticalCenter]="61716",_a$1[BlueprintIcons_16.Ammunition]="62274",_a$1[BlueprintIcons_16.Anchor]="62256",_a$1[BlueprintIcons_16.Annotation]="61717",_a$1[BlueprintIcons_16.Antenna]="61718",_a$1[BlueprintIcons_16.AppHeader]="61719",_a$1[BlueprintIcons_16.Application]="61720",_a$1[BlueprintIcons_16.Applications]="61721",_a$1[BlueprintIcons_16.Archive]="61722",_a$1[BlueprintIcons_16.AreaOfInterest]="61723",_a$1[BlueprintIcons_16.ArrayBoolean]="61724",_a$1[BlueprintIcons_16.ArrayDate]="61725",_a$1[BlueprintIcons_16.ArrayFloatingPoint]="62253",_a$1[BlueprintIcons_16.ArrayNumeric]="61726",_a$1[BlueprintIcons_16.ArrayString]="61727",_a$1[BlueprintIcons_16.ArrayTimestamp]="61728",_a$1[BlueprintIcons_16.Array]="61729",_a$1[BlueprintIcons_16.ArrowBottomLeft]="61730",_a$1[BlueprintIcons_16.ArrowBottomRight]="61731",_a$1[BlueprintIcons_16.ArrowDown]="61732",_a$1[BlueprintIcons_16.ArrowLeft]="61733",_a$1[BlueprintIcons_16.ArrowRight]="61734",_a$1[BlueprintIcons_16.ArrowTopLeft]="61735",_a$1[BlueprintIcons_16.ArrowTopRight]="61736",_a$1[BlueprintIcons_16.ArrowUp]="61737",_a$1[BlueprintIcons_16.ArrowsHorizontal]="61738",_a$1[BlueprintIcons_16.ArrowsVertical]="61739",_a$1[BlueprintIcons_16.Asterisk]="61740",_a$1[BlueprintIcons_16.At]="62257",_a$1[BlueprintIcons_16.AutomaticUpdates]="61741",_a$1[BlueprintIcons_16.Axle]="62264",_a$1[BlueprintIcons_16.Backlink]="61742",_a$1[BlueprintIcons_16.BackwardTen]="62300",_a$1[BlueprintIcons_16.Badge]="61743",_a$1[BlueprintIcons_16.BanCircle]="61744",_a$1[BlueprintIcons_16.BankAccount]="61745",_a$1[BlueprintIcons_16.Barcode]="61746",_a$1[BlueprintIcons_16.BinaryNumber]="62295",_a$1[BlueprintIcons_16.Blank]="61747",_a$1[BlueprintIcons_16.BlockedPerson]="61748",_a$1[BlueprintIcons_16.Bold]="61749",_a$1[BlueprintIcons_16.Book]="61750",_a$1[BlueprintIcons_16.Bookmark]="61751",_a$1[BlueprintIcons_16.Box]="61752",_a$1[BlueprintIcons_16.Briefcase]="61753",_a$1[BlueprintIcons_16.BringData]="61754",_a$1[BlueprintIcons_16.BringForward]="62292",_a$1[BlueprintIcons_16.Bug]="62254",_a$1[BlueprintIcons_16.Buggy]="61755",_a$1[BlueprintIcons_16.Build]="61756",_a$1[BlueprintIcons_16.Bullseye]="62297",_a$1[BlueprintIcons_16.Calculator]="61757",_a$1[BlueprintIcons_16.Calendar]="61758",_a$1[BlueprintIcons_16.Camera]="61759",_a$1[BlueprintIcons_16.CaretDown]="61760",_a$1[BlueprintIcons_16.CaretLeft]="61761",_a$1[BlueprintIcons_16.CaretRight]="61762",_a$1[BlueprintIcons_16.CaretUp]="61763",_a$1[BlueprintIcons_16.CargoShip]="61764",_a$1[BlueprintIcons_16.CellTower]="61765",_a$1[BlueprintIcons_16.Changes]="61766",_a$1[BlueprintIcons_16.Chart]="61767",_a$1[BlueprintIcons_16.Chat]="61768",_a$1[BlueprintIcons_16.ChevronBackward]="61769",_a$1[BlueprintIcons_16.ChevronDown]="61770",_a$1[BlueprintIcons_16.ChevronForward]="61771",_a$1[BlueprintIcons_16.ChevronLeft]="61772",_a$1[BlueprintIcons_16.ChevronRight]="61773",_a$1[BlueprintIcons_16.ChevronUp]="61774",_a$1[BlueprintIcons_16.CircleArrowDown]="61775",_a$1[BlueprintIcons_16.CircleArrowLeft]="61776",_a$1[BlueprintIcons_16.CircleArrowRight]="61777",_a$1[BlueprintIcons_16.CircleArrowUp]="61778",_a$1[BlueprintIcons_16.Circle]="61779",_a$1[BlueprintIcons_16.Citation]="61780",_a$1[BlueprintIcons_16.Clean]="61781",_a$1[BlueprintIcons_16.Clip]="61782",_a$1[BlueprintIcons_16.ClipboardFile]="62299",_a$1[BlueprintIcons_16.Clipboard]="61783",_a$1[BlueprintIcons_16.CloudDownload]="61784",_a$1[BlueprintIcons_16.CloudServer]="62298",_a$1[BlueprintIcons_16.CloudTick]="62286",_a$1[BlueprintIcons_16.CloudUpload]="61785",_a$1[BlueprintIcons_16.Cloud]="61786",_a$1[BlueprintIcons_16.CodeBlock]="61787",_a$1[BlueprintIcons_16.Code]="61788",_a$1[BlueprintIcons_16.Cog]="61789",_a$1[BlueprintIcons_16.CollapseAll]="61790",_a$1[BlueprintIcons_16.ColorFill]="62248",_a$1[BlueprintIcons_16.ColumnLayout]="61791",_a$1[BlueprintIcons_16.Comment]="61792",_a$1[BlueprintIcons_16.Comparison]="61793",_a$1[BlueprintIcons_16.Compass]="61794",_a$1[BlueprintIcons_16.Compressed]="61795",_a$1[BlueprintIcons_16.Confirm]="61796",_a$1[BlueprintIcons_16.Console]="61797",_a$1[BlueprintIcons_16.Contrast]="61798",_a$1[BlueprintIcons_16.Control]="61799",_a$1[BlueprintIcons_16.CreditCard]="61800",_a$1[BlueprintIcons_16.Crop]="62291",_a$1[BlueprintIcons_16.CrossCircle]="62262",_a$1[BlueprintIcons_16.Cross]="61801",_a$1[BlueprintIcons_16.Crown]="61802",_a$1[BlueprintIcons_16.CubeAdd]="61803",_a$1[BlueprintIcons_16.CubeRemove]="61804",_a$1[BlueprintIcons_16.Cube]="61805",_a$1[BlueprintIcons_16.CurlyBraces]="62296",_a$1[BlueprintIcons_16.CurvedRangeChart]="61806",_a$1[BlueprintIcons_16.Cut]="61807",_a$1[BlueprintIcons_16.Cycle]="61808",_a$1[BlueprintIcons_16.Dashboard]="61809",_a$1[BlueprintIcons_16.DataConnection]="61810",_a$1[BlueprintIcons_16.DataLineage]="61811",_a$1[BlueprintIcons_16.Database]="61812",_a$1[BlueprintIcons_16.Delete]="61813",_a$1[BlueprintIcons_16.Delta]="61814",_a$1[BlueprintIcons_16.DeriveColumn]="61815",_a$1[BlueprintIcons_16.Desktop]="61816",_a$1[BlueprintIcons_16.Detection]="62273",_a$1[BlueprintIcons_16.Diagnosis]="61817",_a$1[BlueprintIcons_16.DiagramTree]="61818",_a$1[BlueprintIcons_16.DirectionLeft]="61819",_a$1[BlueprintIcons_16.DirectionRight]="61820",_a$1[BlueprintIcons_16.Disable]="61821",_a$1[BlueprintIcons_16.Divide]="62247",_a$1[BlueprintIcons_16.DocumentOpen]="61822",_a$1[BlueprintIcons_16.DocumentShare]="61823",_a$1[BlueprintIcons_16.Document]="61824",_a$1[BlueprintIcons_16.Dollar]="61825",_a$1[BlueprintIcons_16.Dot]="61826",_a$1[BlueprintIcons_16.DoubleCaretHorizontal]="61827",_a$1[BlueprintIcons_16.DoubleCaretVertical]="61828",_a$1[BlueprintIcons_16.DoubleChevronDown]="61829",_a$1[BlueprintIcons_16.DoubleChevronLeft]="61830",_a$1[BlueprintIcons_16.DoubleChevronRight]="61831",_a$1[BlueprintIcons_16.DoubleChevronUp]="61832",_a$1[BlueprintIcons_16.DoughnutChart]="61833",_a$1[BlueprintIcons_16.Download]="61834",_a$1[BlueprintIcons_16.DragHandleHorizontal]="61835",_a$1[BlueprintIcons_16.DragHandleVertical]="61836",_a$1[BlueprintIcons_16.Draw]="61837",_a$1[BlueprintIcons_16.DrawerLeftFilled]="61838",_a$1[BlueprintIcons_16.DrawerLeft]="61839",_a$1[BlueprintIcons_16.DrawerRightFilled]="61840",_a$1[BlueprintIcons_16.DrawerRight]="61841",_a$1[BlueprintIcons_16.DriveTime]="61842",_a$1[BlueprintIcons_16.Duplicate]="61843",_a$1[BlueprintIcons_16.Edit]="61844",_a$1[BlueprintIcons_16.Eject]="61845",_a$1[BlueprintIcons_16.Emoji]="61846",_a$1[BlueprintIcons_16.Endnote]="62294",_a$1[BlueprintIcons_16.Endorsed]="61847",_a$1[BlueprintIcons_16.Envelope]="61848",_a$1[BlueprintIcons_16.Equals]="61849",_a$1[BlueprintIcons_16.Eraser]="61850",_a$1[BlueprintIcons_16.Error]="61851",_a$1[BlueprintIcons_16.Euro]="61852",_a$1[BlueprintIcons_16.Exchange]="61853",_a$1[BlueprintIcons_16.ExcludeRow]="61854",_a$1[BlueprintIcons_16.ExpandAll]="61855",_a$1[BlueprintIcons_16.Explain]="62285",_a$1[BlueprintIcons_16.Export]="61856",_a$1[BlueprintIcons_16.EyeOff]="61857",_a$1[BlueprintIcons_16.EyeOn]="61858",_a$1[BlueprintIcons_16.EyeOpen]="61859",_a$1[BlueprintIcons_16.FastBackward]="61860",_a$1[BlueprintIcons_16.FastForward]="61861",_a$1[BlueprintIcons_16.FeedSubscribed]="61862",_a$1[BlueprintIcons_16.Feed]="61863",_a$1[BlueprintIcons_16.Film]="61864",_a$1[BlueprintIcons_16.FilterKeep]="61865",_a$1[BlueprintIcons_16.FilterList]="61866",_a$1[BlueprintIcons_16.FilterOpen]="61867",_a$1[BlueprintIcons_16.FilterRemove]="61868",_a$1[BlueprintIcons_16.Filter]="61869",_a$1[BlueprintIcons_16.Flag]="61870",_a$1[BlueprintIcons_16.Flame]="61871",_a$1[BlueprintIcons_16.Flash]="61872",_a$1[BlueprintIcons_16.FloatingPoint]="62252",_a$1[BlueprintIcons_16.FloppyDisk]="61873",_a$1[BlueprintIcons_16.FlowBranch]="61874",_a$1[BlueprintIcons_16.FlowEnd]="61875",_a$1[BlueprintIcons_16.FlowLinear]="61876",_a$1[BlueprintIcons_16.FlowReviewBranch]="61877",_a$1[BlueprintIcons_16.FlowReview]="61878",_a$1[BlueprintIcons_16.Flows]="61879",_a$1[BlueprintIcons_16.FolderClose]="61880",_a$1[BlueprintIcons_16.FolderNew]="61881",_a$1[BlueprintIcons_16.FolderOpen]="61882",_a$1[BlueprintIcons_16.FolderSharedOpen]="61883",_a$1[BlueprintIcons_16.FolderShared]="61884",_a$1[BlueprintIcons_16.Follower]="61885",_a$1[BlueprintIcons_16.Following]="61886",_a$1[BlueprintIcons_16.Font]="61887",_a$1[BlueprintIcons_16.Fork]="61888",_a$1[BlueprintIcons_16.Form]="61889",_a$1[BlueprintIcons_16.ForwardTen]="62301",_a$1[BlueprintIcons_16.Fuel]="62243",_a$1[BlueprintIcons_16.FullCircle]="61890",_a$1[BlueprintIcons_16.FullStackedChart]="61891",_a$1[BlueprintIcons_16.Fullscreen]="61892",_a$1[BlueprintIcons_16.Function]="61893",_a$1[BlueprintIcons_16.GanttChart]="61894",_a$1[BlueprintIcons_16.Generate]="62284",_a$1[BlueprintIcons_16.Geofence]="61895",_a$1[BlueprintIcons_16.Geolocation]="61896",_a$1[BlueprintIcons_16.Geosearch]="61897",_a$1[BlueprintIcons_16.Geotime]="62276",_a$1[BlueprintIcons_16.GitBranch]="61898",_a$1[BlueprintIcons_16.GitCommit]="61899",_a$1[BlueprintIcons_16.GitMerge]="61900",_a$1[BlueprintIcons_16.GitNewBranch]="61901",_a$1[BlueprintIcons_16.GitPull]="61902",_a$1[BlueprintIcons_16.GitPush]="61903",_a$1[BlueprintIcons_16.GitRepo]="61904",_a$1[BlueprintIcons_16.Glass]="61905",_a$1[BlueprintIcons_16.GlobeNetwork]="61906",_a$1[BlueprintIcons_16.Globe]="61907",_a$1[BlueprintIcons_16.GraphRemove]="61908",_a$1[BlueprintIcons_16.Graph]="61909",_a$1[BlueprintIcons_16.GreaterThanOrEqualTo]="61910",_a$1[BlueprintIcons_16.GreaterThan]="61911",_a$1[BlueprintIcons_16.GridView]="61912",_a$1[BlueprintIcons_16.Grid]="61913",_a$1[BlueprintIcons_16.GroupItem]="62282",_a$1[BlueprintIcons_16.GroupObjects]="61914",_a$1[BlueprintIcons_16.GroupedBarChart]="61915",_a$1[BlueprintIcons_16.HandDown]="61916",_a$1[BlueprintIcons_16.HandLeft]="61917",_a$1[BlueprintIcons_16.HandRight]="61918",_a$1[BlueprintIcons_16.HandUp]="61919",_a$1[BlueprintIcons_16.Hand]="61920",_a$1[BlueprintIcons_16.Hat]="61921",_a$1[BlueprintIcons_16.HeaderOne]="61922",_a$1[BlueprintIcons_16.HeaderThree]="61923",_a$1[BlueprintIcons_16.HeaderTwo]="61924",_a$1[BlueprintIcons_16.Header]="61925",_a$1[BlueprintIcons_16.Headset]="61926",_a$1[BlueprintIcons_16.HeartBroken]="61927",_a$1[BlueprintIcons_16.Heart]="61928",_a$1[BlueprintIcons_16.HeatGrid]="61929",_a$1[BlueprintIcons_16.Heatmap]="61930",_a$1[BlueprintIcons_16.Helicopter]="61931",_a$1[BlueprintIcons_16.Help]="61932",_a$1[BlueprintIcons_16.HelperManagement]="61933",_a$1[BlueprintIcons_16.HighPriority]="61934",_a$1[BlueprintIcons_16.HighVoltagePole]="62259",_a$1[BlueprintIcons_16.Highlight]="61935",_a$1[BlueprintIcons_16.History]="61936",_a$1[BlueprintIcons_16.Home]="61937",_a$1[BlueprintIcons_16.HorizontalBarChartAsc]="61938",_a$1[BlueprintIcons_16.HorizontalBarChartDesc]="61939",_a$1[BlueprintIcons_16.HorizontalBarChart]="61940",_a$1[BlueprintIcons_16.HorizontalDistribution]="61941",_a$1[BlueprintIcons_16.HorizontalInbetween]="62249",_a$1[BlueprintIcons_16.Hurricane]="61942",_a$1[BlueprintIcons_16.IdNumber]="61943",_a$1[BlueprintIcons_16.ImageRotateLeft]="61944",_a$1[BlueprintIcons_16.ImageRotateRight]="61945",_a$1[BlueprintIcons_16.Import]="61946",_a$1[BlueprintIcons_16.InboxFiltered]="61947",_a$1[BlueprintIcons_16.InboxGeo]="61948",_a$1[BlueprintIcons_16.InboxSearch]="61949",_a$1[BlueprintIcons_16.InboxUpdate]="61950",_a$1[BlueprintIcons_16.Inbox]="61951",_a$1[BlueprintIcons_16.InfoSign]="61952",_a$1[BlueprintIcons_16.Inheritance]="61953",_a$1[BlueprintIcons_16.InheritedGroup]="61954",_a$1[BlueprintIcons_16.InnerJoin]="61955",_a$1[BlueprintIcons_16.Input]="62283",_a$1[BlueprintIcons_16.Insert]="61956",_a$1[BlueprintIcons_16.Intelligence]="62263",_a$1[BlueprintIcons_16.Intersection]="61957",_a$1[BlueprintIcons_16.IpAddress]="61958",_a$1[BlueprintIcons_16.IssueClosed]="61959",_a$1[BlueprintIcons_16.IssueNew]="61960",_a$1[BlueprintIcons_16.Issue]="61961",_a$1[BlueprintIcons_16.Italic]="61962",_a$1[BlueprintIcons_16.JoinTable]="61963",_a$1[BlueprintIcons_16.KeyBackspace]="61964",_a$1[BlueprintIcons_16.KeyCommand]="61965",_a$1[BlueprintIcons_16.KeyControl]="61966",_a$1[BlueprintIcons_16.KeyDelete]="61967",_a$1[BlueprintIcons_16.KeyEnter]="61968",_a$1[BlueprintIcons_16.KeyEscape]="61969",_a$1[BlueprintIcons_16.KeyOption]="61970",_a$1[BlueprintIcons_16.KeyShift]="61971",_a$1[BlueprintIcons_16.KeyTab]="61972",_a$1[BlueprintIcons_16.Key]="61973",_a$1[BlueprintIcons_16.KnownVehicle]="61974",_a$1[BlueprintIcons_16.LabTest]="61975",_a$1[BlueprintIcons_16.Label]="61976",_a$1[BlueprintIcons_16.LayerOutline]="61977",_a$1[BlueprintIcons_16.Layer]="61978",_a$1[BlueprintIcons_16.Layers]="61979",_a$1[BlueprintIcons_16.LayoutAuto]="61980",_a$1[BlueprintIcons_16.LayoutBalloon]="61981",_a$1[BlueprintIcons_16.LayoutCircle]="61982",_a$1[BlueprintIcons_16.LayoutGrid]="61983",_a$1[BlueprintIcons_16.LayoutGroupBy]="61984",_a$1[BlueprintIcons_16.LayoutHierarchy]="61985",_a$1[BlueprintIcons_16.LayoutLinear]="61986",_a$1[BlueprintIcons_16.LayoutSkewGrid]="61987",_a$1[BlueprintIcons_16.LayoutSortedClusters]="61988",_a$1[BlueprintIcons_16.Layout]="61989",_a$1[BlueprintIcons_16.Learning]="61990",_a$1[BlueprintIcons_16.LeftJoin]="61991",_a$1[BlueprintIcons_16.LengthenText]="62270",_a$1[BlueprintIcons_16.LessThanOrEqualTo]="61992",_a$1[BlueprintIcons_16.LessThan]="61993",_a$1[BlueprintIcons_16.Lifesaver]="61994",_a$1[BlueprintIcons_16.Lightbulb]="61995",_a$1[BlueprintIcons_16.Lightning]="61996",_a$1[BlueprintIcons_16.Link]="61997",_a$1[BlueprintIcons_16.ListColumns]="61998",_a$1[BlueprintIcons_16.ListDetailView]="61999",_a$1[BlueprintIcons_16.List]="62000",_a$1[BlueprintIcons_16.Locate]="62001",_a$1[BlueprintIcons_16.Lock]="62002",_a$1[BlueprintIcons_16.Locomotive]="62267",_a$1[BlueprintIcons_16.LogIn]="62003",_a$1[BlueprintIcons_16.LogOut]="62004",_a$1[BlueprintIcons_16.LowVoltagePole]="62258",_a$1[BlueprintIcons_16.Manual]="62005",_a$1[BlueprintIcons_16.ManuallyEnteredData]="62006",_a$1[BlueprintIcons_16.ManyToMany]="62007",_a$1[BlueprintIcons_16.ManyToOne]="62008",_a$1[BlueprintIcons_16.MapCreate]="62009",_a$1[BlueprintIcons_16.MapMarker]="62010",_a$1[BlueprintIcons_16.Map]="62011",_a$1[BlueprintIcons_16.Maximize]="62012",_a$1[BlueprintIcons_16.Media]="62013",_a$1[BlueprintIcons_16.MenuClosed]="62014",_a$1[BlueprintIcons_16.MenuOpen]="62015",_a$1[BlueprintIcons_16.Menu]="62016",_a$1[BlueprintIcons_16.MergeColumns]="62017",_a$1[BlueprintIcons_16.MergeLinks]="62018",_a$1[BlueprintIcons_16.Microphone]="62275",_a$1[BlueprintIcons_16.Minimize]="62019",_a$1[BlueprintIcons_16.Minus]="62020",_a$1[BlueprintIcons_16.MobilePhone]="62021",_a$1[BlueprintIcons_16.MobileVideo]="62022",_a$1[BlueprintIcons_16.ModalFilled]="62023",_a$1[BlueprintIcons_16.Modal]="62024",_a$1[BlueprintIcons_16.Model]="62269",_a$1[BlueprintIcons_16.Moon]="62025",_a$1[BlueprintIcons_16.More]="62026",_a$1[BlueprintIcons_16.Mountain]="62027",_a$1[BlueprintIcons_16.Move]="62028",_a$1[BlueprintIcons_16.Mugshot]="62029",_a$1[BlueprintIcons_16.MultiSelect]="62030",_a$1[BlueprintIcons_16.Music]="62031",_a$1[BlueprintIcons_16.Nest]="62032",_a$1[BlueprintIcons_16.NewDrawing]="62033",_a$1[BlueprintIcons_16.NewGridItem]="62034",_a$1[BlueprintIcons_16.NewLayer]="62035",_a$1[BlueprintIcons_16.NewLayers]="62036",_a$1[BlueprintIcons_16.NewLink]="62037",_a$1[BlueprintIcons_16.NewObject]="62038",_a$1[BlueprintIcons_16.NewPerson]="62039",_a$1[BlueprintIcons_16.NewPrescription]="62040",_a$1[BlueprintIcons_16.NewShield]="62281",_a$1[BlueprintIcons_16.NewTextBox]="62041",_a$1[BlueprintIcons_16.Ninja]="62042",_a$1[BlueprintIcons_16.NotEqualTo]="62043",_a$1[BlueprintIcons_16.NotificationsSnooze]="62044",_a$1[BlueprintIcons_16.NotificationsUpdated]="62045",_a$1[BlueprintIcons_16.Notifications]="62046",_a$1[BlueprintIcons_16.NumberedList]="62047",_a$1[BlueprintIcons_16.Numerical]="62048",_a$1[BlueprintIcons_16.Office]="62049",_a$1[BlueprintIcons_16.Offline]="62050",_a$1[BlueprintIcons_16.OilField]="62051",_a$1[BlueprintIcons_16.OneColumn]="62052",_a$1[BlueprintIcons_16.OneToMany]="62053",_a$1[BlueprintIcons_16.OneToOne]="62054",_a$1[BlueprintIcons_16.OpenApplication]="62251",_a$1[BlueprintIcons_16.Outdated]="62055",_a$1[BlueprintIcons_16.PageLayout]="62056",_a$1[BlueprintIcons_16.PanelStats]="62057",_a$1[BlueprintIcons_16.PanelTable]="62058",_a$1[BlueprintIcons_16.Paperclip]="62059",_a$1[BlueprintIcons_16.Paragraph]="62060",_a$1[BlueprintIcons_16.PasteVariable]="62278",_a$1[BlueprintIcons_16.PathSearch]="62061",_a$1[BlueprintIcons_16.Path]="62062",_a$1[BlueprintIcons_16.Pause]="62063",_a$1[BlueprintIcons_16.People]="62064",_a$1[BlueprintIcons_16.Percentage]="62065",_a$1[BlueprintIcons_16.Person]="62066",_a$1[BlueprintIcons_16.PhoneCall]="62279",_a$1[BlueprintIcons_16.PhoneForward]="62280",_a$1[BlueprintIcons_16.Phone]="62067",_a$1[BlueprintIcons_16.PieChart]="62068",_a$1[BlueprintIcons_16.Pin]="62069",_a$1[BlueprintIcons_16.PivotTable]="62070",_a$1[BlueprintIcons_16.Pivot]="62071",_a$1[BlueprintIcons_16.Play]="62072",_a$1[BlueprintIcons_16.Playbook]="62244",_a$1[BlueprintIcons_16.Plus]="62073",_a$1[BlueprintIcons_16.PolygonFilter]="62074",_a$1[BlueprintIcons_16.Power]="62075",_a$1[BlueprintIcons_16.PredictiveAnalysis]="62076",_a$1[BlueprintIcons_16.Prescription]="62077",_a$1[BlueprintIcons_16.Presentation]="62078",_a$1[BlueprintIcons_16.Print]="62079",_a$1[BlueprintIcons_16.Projects]="62080",_a$1[BlueprintIcons_16.Properties]="62081",_a$1[BlueprintIcons_16.Property]="62082",_a$1[BlueprintIcons_16.PublishFunction]="62083",_a$1[BlueprintIcons_16.Pulse]="62084",_a$1[BlueprintIcons_16.Rain]="62085",_a$1[BlueprintIcons_16.Random]="62086",_a$1[BlueprintIcons_16.Record]="62087",_a$1[BlueprintIcons_16.RectHeight]="62245",_a$1[BlueprintIcons_16.RectWidth]="62246",_a$1[BlueprintIcons_16.Rectangle]="62241",_a$1[BlueprintIcons_16.Redo]="62088",_a$1[BlueprintIcons_16.Refresh]="62089",_a$1[BlueprintIcons_16.Regex]="62255",_a$1[BlueprintIcons_16.RegressionChart]="62090",_a$1[BlueprintIcons_16.RemoveColumnLeft]="62091",_a$1[BlueprintIcons_16.RemoveColumnRight]="62092",_a$1[BlueprintIcons_16.RemoveColumn]="62093",_a$1[BlueprintIcons_16.RemoveRowBottom]="62094",_a$1[BlueprintIcons_16.RemoveRowTop]="62095",_a$1[BlueprintIcons_16.Remove]="62096",_a$1[BlueprintIcons_16.Repeat]="62097",_a$1[BlueprintIcons_16.Reset]="62098",_a$1[BlueprintIcons_16.Resolve]="62099",_a$1[BlueprintIcons_16.Rig]="62100",_a$1[BlueprintIcons_16.RightJoin]="62101",_a$1[BlueprintIcons_16.Ring]="62102",_a$1[BlueprintIcons_16.RocketSlant]="62103",_a$1[BlueprintIcons_16.Rocket]="62104",_a$1[BlueprintIcons_16.RotateDocument]="62105",_a$1[BlueprintIcons_16.RotatePage]="62106",_a$1[BlueprintIcons_16.Route]="62107",_a$1[BlueprintIcons_16.Satellite]="62108",_a$1[BlueprintIcons_16.Saved]="62109",_a$1[BlueprintIcons_16.ScatterPlot]="62110",_a$1[BlueprintIcons_16.SearchAround]="62111",_a$1[BlueprintIcons_16.SearchTemplate]="62112",_a$1[BlueprintIcons_16.SearchText]="62113",_a$1[BlueprintIcons_16.Search]="62114",_a$1[BlueprintIcons_16.SegmentedControl]="62115",_a$1[BlueprintIcons_16.Select]="62116",_a$1[BlueprintIcons_16.Selection]="62117",_a$1[BlueprintIcons_16.SendBackward]="62293",_a$1[BlueprintIcons_16.SendMessage]="62118",_a$1[BlueprintIcons_16.SendToGraph]="62119",_a$1[BlueprintIcons_16.SendToMap]="62120",_a$1[BlueprintIcons_16.SendTo]="62121",_a$1[BlueprintIcons_16.Sensor]="62268",_a$1[BlueprintIcons_16.SeriesAdd]="62122",_a$1[BlueprintIcons_16.SeriesConfiguration]="62123",_a$1[BlueprintIcons_16.SeriesDerived]="62124",_a$1[BlueprintIcons_16.SeriesFiltered]="62125",_a$1[BlueprintIcons_16.SeriesSearch]="62126",_a$1[BlueprintIcons_16.Settings]="62127",_a$1[BlueprintIcons_16.Shapes]="62128",_a$1[BlueprintIcons_16.Share]="62129",_a$1[BlueprintIcons_16.SharedFilter]="62130",_a$1[BlueprintIcons_16.Shield]="62131",_a$1[BlueprintIcons_16.Ship]="62132",_a$1[BlueprintIcons_16.Shop]="62133",_a$1[BlueprintIcons_16.ShoppingCart]="62134",_a$1[BlueprintIcons_16.ShortenText]="62271",_a$1[BlueprintIcons_16.SignalSearch]="62135",_a$1[BlueprintIcons_16.SimCard]="62136",_a$1[BlueprintIcons_16.Slash]="62137",_a$1[BlueprintIcons_16.SmallCross]="62138",_a$1[BlueprintIcons_16.SmallInfoSign]="62260",_a$1[BlueprintIcons_16.SmallMinus]="62139",_a$1[BlueprintIcons_16.SmallPlus]="62140",_a$1[BlueprintIcons_16.SmallSquare]="62141",_a$1[BlueprintIcons_16.SmallTick]="62142",_a$1[BlueprintIcons_16.Snowflake]="62143",_a$1[BlueprintIcons_16.SoccerBall]="62288",_a$1[BlueprintIcons_16.SocialMedia]="62144",_a$1[BlueprintIcons_16.SortAlphabeticalDesc]="62145",_a$1[BlueprintIcons_16.SortAlphabetical]="62146",_a$1[BlueprintIcons_16.SortAsc]="62147",_a$1[BlueprintIcons_16.SortDesc]="62148",_a$1[BlueprintIcons_16.SortNumericalDesc]="62149",_a$1[BlueprintIcons_16.SortNumerical]="62150",_a$1[BlueprintIcons_16.Sort]="62151",_a$1[BlueprintIcons_16.SpellCheck]="62272",_a$1[BlueprintIcons_16.SplitColumns]="62152",_a$1[BlueprintIcons_16.SportsStadium]="62289",_a$1[BlueprintIcons_16.Square]="62153",_a$1[BlueprintIcons_16.StackedChart]="62154",_a$1[BlueprintIcons_16.StadiumGeometry]="62155",_a$1[BlueprintIcons_16.StarEmpty]="62156",_a$1[BlueprintIcons_16.Star]="62157",_a$1[BlueprintIcons_16.StepBackward]="62158",_a$1[BlueprintIcons_16.StepChart]="62159",_a$1[BlueprintIcons_16.StepForward]="62160",_a$1[BlueprintIcons_16.Stop]="62161",_a$1[BlueprintIcons_16.Stopwatch]="62162",_a$1[BlueprintIcons_16.Strikethrough]="62163",_a$1[BlueprintIcons_16.Style]="62164",_a$1[BlueprintIcons_16.Subscript]="62265",_a$1[BlueprintIcons_16.Superscript]="62266",_a$1[BlueprintIcons_16.SwapHorizontal]="62165",_a$1[BlueprintIcons_16.SwapVertical]="62166",_a$1[BlueprintIcons_16.Switch]="62167",_a$1[BlueprintIcons_16.SymbolCircle]="62168",_a$1[BlueprintIcons_16.SymbolCross]="62169",_a$1[BlueprintIcons_16.SymbolDiamond]="62170",_a$1[BlueprintIcons_16.SymbolRectangle]="62242",_a$1[BlueprintIcons_16.SymbolSquare]="62171",_a$1[BlueprintIcons_16.SymbolTriangleDown]="62172",_a$1[BlueprintIcons_16.SymbolTriangleUp]="62173",_a$1[BlueprintIcons_16.Syringe]="62174",_a$1[BlueprintIcons_16.Tag]="62175",_a$1[BlueprintIcons_16.TakeAction]="62176",_a$1[BlueprintIcons_16.Tank]="62177",_a$1[BlueprintIcons_16.Target]="62178",_a$1[BlueprintIcons_16.Taxi]="62179",_a$1[BlueprintIcons_16.Team]="62290",_a$1[BlueprintIcons_16.Temperature]="62180",_a$1[BlueprintIcons_16.TextHighlight]="62181",_a$1[BlueprintIcons_16.ThDerived]="62182",_a$1[BlueprintIcons_16.ThDisconnect]="62183",_a$1[BlueprintIcons_16.ThFiltered]="62184",_a$1[BlueprintIcons_16.ThList]="62185",_a$1[BlueprintIcons_16.Th]="62186",_a$1[BlueprintIcons_16.ThirdParty]="62187",_a$1[BlueprintIcons_16.ThumbsDown]="62188",_a$1[BlueprintIcons_16.ThumbsUp]="62189",_a$1[BlueprintIcons_16.TickCircle]="62190",_a$1[BlueprintIcons_16.Tick]="62191",_a$1[BlueprintIcons_16.Time]="62192",_a$1[BlueprintIcons_16.TimelineAreaChart]="62193",_a$1[BlueprintIcons_16.TimelineBarChart]="62194",_a$1[BlueprintIcons_16.TimelineEvents]="62195",_a$1[BlueprintIcons_16.TimelineLineChart]="62196",_a$1[BlueprintIcons_16.Tint]="62197",_a$1[BlueprintIcons_16.Torch]="62198",_a$1[BlueprintIcons_16.Tractor]="62199",_a$1[BlueprintIcons_16.Train]="62200",_a$1[BlueprintIcons_16.Translate]="62201",_a$1[BlueprintIcons_16.Trash]="62202",_a$1[BlueprintIcons_16.Tree]="62203",_a$1[BlueprintIcons_16.TrendingDown]="62204",_a$1[BlueprintIcons_16.TrendingUp]="62205",_a$1[BlueprintIcons_16.Trophy]="62287",_a$1[BlueprintIcons_16.Truck]="62206",_a$1[BlueprintIcons_16.TwoColumns]="62207",_a$1[BlueprintIcons_16.Unarchive]="62208",_a$1[BlueprintIcons_16.Underline]="62209",_a$1[BlueprintIcons_16.Undo]="62210",_a$1[BlueprintIcons_16.UngroupObjects]="62211",_a$1[BlueprintIcons_16.UnknownVehicle]="62212",_a$1[BlueprintIcons_16.Unlink]="62277",_a$1[BlueprintIcons_16.Unlock]="62213",_a$1[BlueprintIcons_16.Unpin]="62214",_a$1[BlueprintIcons_16.Unresolve]="62215",_a$1[BlueprintIcons_16.Updated]="62216",_a$1[BlueprintIcons_16.Upload]="62217",_a$1[BlueprintIcons_16.User]="62218",_a$1[BlueprintIcons_16.Variable]="62219",_a$1[BlueprintIcons_16.VerticalBarChartAsc]="62220",_a$1[BlueprintIcons_16.VerticalBarChartDesc]="62221",_a$1[BlueprintIcons_16.VerticalDistribution]="62222",_a$1[BlueprintIcons_16.VerticalInbetween]="62250",_a$1[BlueprintIcons_16.Video]="62223",_a$1[BlueprintIcons_16.Virus]="62224",_a$1[BlueprintIcons_16.VolumeDown]="62225",_a$1[BlueprintIcons_16.VolumeOff]="62226",_a$1[BlueprintIcons_16.VolumeUp]="62227",_a$1[BlueprintIcons_16.Walk]="62228",_a$1[BlueprintIcons_16.WarningSign]="62229",_a$1[BlueprintIcons_16.WaterfallChart]="62230",_a$1[BlueprintIcons_16.Waves]="62231",_a$1[BlueprintIcons_16.WidgetButton]="62232",_a$1[BlueprintIcons_16.WidgetFooter]="62233",_a$1[BlueprintIcons_16.WidgetHeader]="62234",_a$1[BlueprintIcons_16.Widget]="62235",_a$1[BlueprintIcons_16.Wind]="62236",_a$1[BlueprintIcons_16.Wrench]="62237",_a$1[BlueprintIcons_16.ZoomIn]="62238",_a$1[BlueprintIcons_16.ZoomOut]="62239",_a$1[BlueprintIcons_16.ZoomToFit]="62240";var IconNamesNew={},IconNamesLegacy={};for(var _i=0,_a=Object.values(BlueprintIcons_16);_i<_a.length;_i++){var name_1=_a[_i];IconNamesNew[pascalCase(name_1)]=name_1,IconNamesLegacy[snakeCase(name_1).toUpperCase()]=name_1}var IconNames=__assign$4(__assign$4({},IconNamesNew),IconNamesLegacy);new Set(Object.values(IconNames));var NS="bp5",ICON="".concat(NS,"-icon"),uniqueCountForNamespace=new Map;function uniqueId(_){var j,$=(j=uniqueCountForNamespace.get(_))!==null&&j!==void 0?j:0;return uniqueCountForNamespace.set(_,$+1),"".concat(_,"-").concat($)}var SVGIconContainer=reactExports.forwardRef(function(_,j){var $=_.children,_e=_.className,et=_.color,tt=_.htmlTitle,nt=_.iconName,rt=_.size,at=rt===void 0?IconSize.STANDARD:rt,it=_.svgProps,ot=_.tagName,st=ot===void 0?"span":ot,ct=_.title,pt=__rest(_,["children","className","color","htmlTitle","iconName","size","svgProps","tagName","title"]),dt=at>=IconSize.LARGE,ft=dt?IconSize.LARGE:IconSize.STANDARD,gt="0 0 ".concat(ft," ").concat(ft),ut=uniqueId("iconTitle"),lt=__assign$4({fill:et,height:at,role:"img",viewBox:gt,width:at},it);return st===null?reactExports.createElement("svg",__assign$4({"aria-labelledby":ct?ut:void 0,"data-icon":nt,ref:j},lt,pt,{className:classNames(_e,it==null?void 0:it.className)}),ct&&reactExports.createElement("title",{id:ut},ct),$):reactExports.createElement(st,__assign$4(__assign$4({"aria-hidden":ct?void 0:!0},pt),{className:classNames(ICON,"".concat(ICON,"-").concat(nt),_e),ref:j,title:tt}),reactExports.createElement("svg",__assign$4({"data-icon":nt},lt,{className:it==null?void 0:it.className}),ct&&reactExports.createElement("title",null,ct),$))});SVGIconContainer.displayName="Blueprint5.SVGIconContainer";var CaretDown=reactExports.forwardRef(function(_,j){var $=_.size>=IconSize.LARGE,_e=$?IconSize.LARGE:IconSize.STANDARD,et="".concat(-1*_e/.05/2),tt={transformOrigin:"center"};return reactExports.createElement(SVGIconContainer,__assign$4({iconName:"caret-down",ref:j},_),reactExports.createElement("path",{d:$?"M320 260C320 271 311 280 300 280H100C89 280 80 271 80 260C80 255.2 82 250.8 84.8 247.4L84.6 247.2L184.6 127.2L184.8 127.4C188.6 123 193.8 120 200 120S211.4 123 215.2 127.4L215.4 127.2L315.4 247.2L315.2 247.4C318 250.8 320 255.2 320 260z":"M240 190C240 195.6 235.6 200 230 200H90C84.4 200 80 195.6 80 190C80 187.4 81 185.2 82.6 183.4C82.6 183.4 82.6 183.4 82.6 183.4L152.6 103.4L152.6 103.4C154.4 101.4 157 100 160 100S165.6 101.4 167.4 103.4L167.4 103.4L237.4 183.4L237.4 183.4C239 185.2 240 187.4 240 190z",fillRule:"evenodd",transform:"scale(0.05, -0.05) translate(".concat(et,", ").concat(et,")"),style:tt}))});CaretDown.defaultProps={size:IconSize.STANDARD};CaretDown.displayName="Blueprint5.Icon.CaretDown";var DoubleCaretVertical=reactExports.forwardRef(function(_,j){var $=_.size>=IconSize.LARGE,_e=$?IconSize.LARGE:IconSize.STANDARD,et="".concat(-1*_e/.05/2),tt={transformOrigin:"center"};return reactExports.createElement(SVGIconContainer,__assign$4({iconName:"double-caret-vertical",ref:j},_),reactExports.createElement("path",{d:$?"M100 220H300C311 220 320 229 320 240C320 244.8 318 249.2 315.2 252.6L315.4 252.8L215.4 372.8L215.2 372.6C211.4 377 206.2 380 200 380S188.6 377 184.8 372.6L184.6 372.8L84.6 252.8L84.8 252.6C82 249.2 80 244.8 80 240C80 229 89 220 100 220zM300 180H100C89 180 80 171 80 160C80 155.2 82 150.8 84.8 147.4L84.6 147.2L184.6 27.2L184.8 27.4C188.6 23 193.8 20 200 20S211.4 23 215.2 27.4L215.4 27.2L315.4 147.2L315.2 147.4C318 150.8 320 155.2 320 160C320 171 311 180 300 180z":"M100 180H220C231 180 240 189 240 200C240 205.6 237.8 210.6 234.2 214.2L174.2 274.2C170.6 277.8 165.6 280 160 280S149.4 277.8 145.8 274.2L85.8 214.2C82.2 210.6 80 205.6 80 200C80 189 89 180 100 180zM220 140H100C89 140 80 131 80 120C80 114.4 82.2 109.4 85.8 105.8L145.8 45.8C149.4 42.2 154.4 40 160 40S170.6 42.2 174.2 45.8L234.2 105.8C237.8 109.4 240 114.4 240 120C240 131 231 140 220 140z",fillRule:"evenodd",transform:"scale(0.05, -0.05) translate(".concat(et,", ").concat(et,")"),style:tt}))});DoubleCaretVertical.defaultProps={size:IconSize.STANDARD};DoubleCaretVertical.displayName="Blueprint5.Icon.DoubleCaretVertical";function _extends(){return _extends=Object.assign?Object.assign.bind():function(_){for(var j=1;j<arguments.length;j++){var $=arguments[j];for(var _e in $)Object.prototype.hasOwnProperty.call($,_e)&&(_[_e]=$[_e])}return _},_extends.apply(this,arguments)}function _objectWithoutPropertiesLoose$1(_,j){if(_==null)return{};var $={};for(var _e in _)if(Object.prototype.hasOwnProperty.call(_,_e)){if(j.indexOf(_e)>=0)continue;$[_e]=_[_e]}return $}function _setPrototypeOf(_,j){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(_e,et){return _e.__proto__=et,_e},_setPrototypeOf(_,j)}function _inheritsLoose(_,j){_.prototype=Object.create(j.prototype),_.prototype.constructor=_,_setPrototypeOf(_,j)}function hasClass(_,j){return _.classList?!!j&&_.classList.contains(j):(" "+(_.className.baseVal||_.className)+" ").indexOf(" "+j+" ")!==-1}function addClass(_,j){_.classList?_.classList.add(j):hasClass(_,j)||(typeof _.className=="string"?_.className=_.className+" "+j:_.setAttribute("class",(_.className&&_.className.baseVal||"")+" "+j))}function replaceClassName(_,j){return _.replace(new RegExp("(^|\\s)"+j+"(?:\\s|$)","g"),"$1").replace(/\s+/g," ").replace(/^\s*|\s*$/g,"")}function removeClass$1(_,j){_.classList?_.classList.remove(j):typeof _.className=="string"?_.className=replaceClassName(_.className,j):_.setAttribute("class",replaceClassName(_.className&&_.className.baseVal||"",j))}const config={disabled:!1},TransitionGroupContext=React.createContext(null);var forceReflow=function(j){return j.scrollTop},UNMOUNTED="unmounted",EXITED="exited",ENTERING="entering",ENTERED="entered",EXITING="exiting",Transition=function(_){_inheritsLoose(j,_);function j(_e,et){var tt;tt=_.call(this,_e,et)||this;var nt=et,rt=nt&&!nt.isMounting?_e.enter:_e.appear,at;return tt.appearStatus=null,_e.in?rt?(at=EXITED,tt.appearStatus=ENTERING):at=ENTERED:_e.unmountOnExit||_e.mountOnEnter?at=UNMOUNTED:at=EXITED,tt.state={status:at},tt.nextCallback=null,tt}j.getDerivedStateFromProps=function(et,tt){var nt=et.in;return nt&&tt.status===UNMOUNTED?{status:EXITED}:null};var $=j.prototype;return $.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},$.componentDidUpdate=function(et){var tt=null;if(et!==this.props){var nt=this.state.status;this.props.in?nt!==ENTERING&&nt!==ENTERED&&(tt=ENTERING):(nt===ENTERING||nt===ENTERED)&&(tt=EXITING)}this.updateStatus(!1,tt)},$.componentWillUnmount=function(){this.cancelNextCallback()},$.getTimeouts=function(){var et=this.props.timeout,tt,nt,rt;return tt=nt=rt=et,et!=null&&typeof et!="number"&&(tt=et.exit,nt=et.enter,rt=et.appear!==void 0?et.appear:nt),{exit:tt,enter:nt,appear:rt}},$.updateStatus=function(et,tt){if(et===void 0&&(et=!1),tt!==null)if(this.cancelNextCallback(),tt===ENTERING){if(this.props.unmountOnExit||this.props.mountOnEnter){var nt=this.props.nodeRef?this.props.nodeRef.current:ReactDOM.findDOMNode(this);nt&&forceReflow(nt)}this.performEnter(et)}else this.performExit();else this.props.unmountOnExit&&this.state.status===EXITED&&this.setState({status:UNMOUNTED})},$.performEnter=function(et){var tt=this,nt=this.props.enter,rt=this.context?this.context.isMounting:et,at=this.props.nodeRef?[rt]:[ReactDOM.findDOMNode(this),rt],it=at[0],ot=at[1],st=this.getTimeouts(),ct=rt?st.appear:st.enter;if(!et&&!nt||config.disabled){this.safeSetState({status:ENTERED},function(){tt.props.onEntered(it)});return}this.props.onEnter(it,ot),this.safeSetState({status:ENTERING},function(){tt.props.onEntering(it,ot),tt.onTransitionEnd(ct,function(){tt.safeSetState({status:ENTERED},function(){tt.props.onEntered(it,ot)})})})},$.performExit=function(){var et=this,tt=this.props.exit,nt=this.getTimeouts(),rt=this.props.nodeRef?void 0:ReactDOM.findDOMNode(this);if(!tt||config.disabled){this.safeSetState({status:EXITED},function(){et.props.onExited(rt)});return}this.props.onExit(rt),this.safeSetState({status:EXITING},function(){et.props.onExiting(rt),et.onTransitionEnd(nt.exit,function(){et.safeSetState({status:EXITED},function(){et.props.onExited(rt)})})})},$.cancelNextCallback=function(){this.nextCallback!==null&&(this.nextCallback.cancel(),this.nextCallback=null)},$.safeSetState=function(et,tt){tt=this.setNextCallback(tt),this.setState(et,tt)},$.setNextCallback=function(et){var tt=this,nt=!0;return this.nextCallback=function(rt){nt&&(nt=!1,tt.nextCallback=null,et(rt))},this.nextCallback.cancel=function(){nt=!1},this.nextCallback},$.onTransitionEnd=function(et,tt){this.setNextCallback(tt);var nt=this.props.nodeRef?this.props.nodeRef.current:ReactDOM.findDOMNode(this),rt=et==null&&!this.props.addEndListener;if(!nt||rt){setTimeout(this.nextCallback,0);return}if(this.props.addEndListener){var at=this.props.nodeRef?[this.nextCallback]:[nt,this.nextCallback],it=at[0],ot=at[1];this.props.addEndListener(it,ot)}et!=null&&setTimeout(this.nextCallback,et)},$.render=function(){var et=this.state.status;if(et===UNMOUNTED)return null;var tt=this.props,nt=tt.children;tt.in,tt.mountOnEnter,tt.unmountOnExit,tt.appear,tt.enter,tt.exit,tt.timeout,tt.addEndListener,tt.onEnter,tt.onEntering,tt.onEntered,tt.onExit,tt.onExiting,tt.onExited,tt.nodeRef;var rt=_objectWithoutPropertiesLoose$1(tt,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]);return React.createElement(TransitionGroupContext.Provider,{value:null},typeof nt=="function"?nt(et,rt):React.cloneElement(React.Children.only(nt),rt))},j}(React.Component);Transition.contextType=TransitionGroupContext;Transition.propTypes={};function noop$1(){}Transition.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:noop$1,onEntering:noop$1,onEntered:noop$1,onExit:noop$1,onExiting:noop$1,onExited:noop$1};Transition.UNMOUNTED=UNMOUNTED;Transition.EXITED=EXITED;Transition.ENTERING=ENTERING;Transition.ENTERED=ENTERED;Transition.EXITING=EXITING;var _addClass=function(j,$){return j&&$&&$.split(" ").forEach(function(_e){return addClass(j,_e)})},removeClass=function(j,$){return j&&$&&$.split(" ").forEach(function(_e){return removeClass$1(j,_e)})},CSSTransition=function(_){_inheritsLoose(j,_);function j(){for(var _e,et=arguments.length,tt=new Array(et),nt=0;nt<et;nt++)tt[nt]=arguments[nt];return _e=_.call.apply(_,[this].concat(tt))||this,_e.appliedClasses={appear:{},enter:{},exit:{}},_e.onEnter=function(rt,at){var it=_e.resolveArguments(rt,at),ot=it[0],st=it[1];_e.removeClasses(ot,"exit"),_e.addClass(ot,st?"appear":"enter","base"),_e.props.onEnter&&_e.props.onEnter(rt,at)},_e.onEntering=function(rt,at){var it=_e.resolveArguments(rt,at),ot=it[0],st=it[1],ct=st?"appear":"enter";_e.addClass(ot,ct,"active"),_e.props.onEntering&&_e.props.onEntering(rt,at)},_e.onEntered=function(rt,at){var it=_e.resolveArguments(rt,at),ot=it[0],st=it[1],ct=st?"appear":"enter";_e.removeClasses(ot,ct),_e.addClass(ot,ct,"done"),_e.props.onEntered&&_e.props.onEntered(rt,at)},_e.onExit=function(rt){var at=_e.resolveArguments(rt),it=at[0];_e.removeClasses(it,"appear"),_e.removeClasses(it,"enter"),_e.addClass(it,"exit","base"),_e.props.onExit&&_e.props.onExit(rt)},_e.onExiting=function(rt){var at=_e.resolveArguments(rt),it=at[0];_e.addClass(it,"exit","active"),_e.props.onExiting&&_e.props.onExiting(rt)},_e.onExited=function(rt){var at=_e.resolveArguments(rt),it=at[0];_e.removeClasses(it,"exit"),_e.addClass(it,"exit","done"),_e.props.onExited&&_e.props.onExited(rt)},_e.resolveArguments=function(rt,at){return _e.props.nodeRef?[_e.props.nodeRef.current,rt]:[rt,at]},_e.getClassNames=function(rt){var at=_e.props.classNames,it=typeof at=="string",ot=it&&at?at+"-":"",st=it?""+ot+rt:at[rt],ct=it?st+"-active":at[rt+"Active"],pt=it?st+"-done":at[rt+"Done"];return{baseClassName:st,activeClassName:ct,doneClassName:pt}},_e}var $=j.prototype;return $.addClass=function(et,tt,nt){var rt=this.getClassNames(tt)[nt+"ClassName"],at=this.getClassNames("enter"),it=at.doneClassName;tt==="appear"&&nt==="done"&&it&&(rt+=" "+it),nt==="active"&&et&&forceReflow(et),rt&&(this.appliedClasses[tt][nt]=rt,_addClass(et,rt))},$.removeClasses=function(et,tt){var nt=this.appliedClasses[tt],rt=nt.base,at=nt.active,it=nt.done;this.appliedClasses[tt]={},rt&&removeClass(et,rt),at&&removeClass(et,at),it&&removeClass(et,it)},$.render=function(){var et=this.props;et.classNames;var tt=_objectWithoutPropertiesLoose$1(et,["classNames"]);return React.createElement(Transition,_extends({},tt,{onEnter:this.onEnter,onEntered:this.onEntered,onEntering:this.onEntering,onExit:this.onExit,onExiting:this.onExiting,onExited:this.onExited}))},j}(React.Component);CSSTransition.defaultProps={classNames:""};CSSTransition.propTypes={};function _assertThisInitialized(_){if(_===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return _}function getChildMapping(_,j){var $=function(tt){return j&&reactExports.isValidElement(tt)?j(tt):tt},_e=Object.create(null);return _&&reactExports.Children.map(_,function(et){return et}).forEach(function(et){_e[et.key]=$(et)}),_e}function mergeChildMappings(_,j){_=_||{},j=j||{};function $(ot){return ot in j?j[ot]:_[ot]}var _e=Object.create(null),et=[];for(var tt in _)tt in j?et.length&&(_e[tt]=et,et=[]):et.push(tt);var nt,rt={};for(var at in j){if(_e[at])for(nt=0;nt<_e[at].length;nt++){var it=_e[at][nt];rt[_e[at][nt]]=$(it)}rt[at]=$(at)}for(nt=0;nt<et.length;nt++)rt[et[nt]]=$(et[nt]);return rt}function getProp(_,j,$){return $[j]!=null?$[j]:_.props[j]}function getInitialChildMapping(_,j){return getChildMapping(_.children,function($){return reactExports.cloneElement($,{onExited:j.bind(null,$),in:!0,appear:getProp($,"appear",_),enter:getProp($,"enter",_),exit:getProp($,"exit",_)})})}function getNextChildMapping(_,j,$){var _e=getChildMapping(_.children),et=mergeChildMappings(j,_e);return Object.keys(et).forEach(function(tt){var nt=et[tt];if(reactExports.isValidElement(nt)){var rt=tt in j,at=tt in _e,it=j[tt],ot=reactExports.isValidElement(it)&&!it.props.in;at&&(!rt||ot)?et[tt]=reactExports.cloneElement(nt,{onExited:$.bind(null,nt),in:!0,exit:getProp(nt,"exit",_),enter:getProp(nt,"enter",_)}):!at&&rt&&!ot?et[tt]=reactExports.cloneElement(nt,{in:!1}):at&&rt&&reactExports.isValidElement(it)&&(et[tt]=reactExports.cloneElement(nt,{onExited:$.bind(null,nt),in:it.props.in,exit:getProp(nt,"exit",_),enter:getProp(nt,"enter",_)}))}}),et}var values$1=Object.values||function(_){return Object.keys(_).map(function(j){return _[j]})},defaultProps={component:"div",childFactory:function(j){return j}},TransitionGroup=function(_){_inheritsLoose(j,_);function j(_e,et){var tt;tt=_.call(this,_e,et)||this;var nt=tt.handleExited.bind(_assertThisInitialized(tt));return tt.state={contextValue:{isMounting:!0},handleExited:nt,firstRender:!0},tt}var $=j.prototype;return $.componentDidMount=function(){this.mounted=!0,this.setState({contextValue:{isMounting:!1}})},$.componentWillUnmount=function(){this.mounted=!1},j.getDerivedStateFromProps=function(et,tt){var nt=tt.children,rt=tt.handleExited,at=tt.firstRender;return{children:at?getInitialChildMapping(et,rt):getNextChildMapping(et,nt,rt),firstRender:!1}},$.handleExited=function(et,tt){var nt=getChildMapping(this.props.children);et.key in nt||(et.props.onExited&&et.props.onExited(tt),this.mounted&&this.setState(function(rt){var at=_extends({},rt.children);return delete at[et.key],{children:at}}))},$.render=function(){var et=this.props,tt=et.component,nt=et.childFactory,rt=_objectWithoutPropertiesLoose$1(et,["component","childFactory"]),at=this.state.contextValue,it=values$1(this.state.children).map(nt);return delete rt.appear,delete rt.enter,delete rt.exit,tt===null?React.createElement(TransitionGroupContext.Provider,{value:at},it):React.createElement(TransitionGroupContext.Provider,{value:at},React.createElement(tt,rt,it))},j}(React.Component);TransitionGroup.propTypes={};TransitionGroup.defaultProps=defaultProps;var generateUID$1=function(){var _=1,j=new WeakMap,$=function(_e,et){return typeof _e=="number"||typeof _e=="string"?et?"idx-".concat(et):"val-".concat(_e):j.has(_e)?"uid"+j.get(_e):(j.set(_e,_++),$(_e))};return $},createSource=function(_){return _===void 0&&(_=""),{value:1,prefix:_,uid:generateUID$1()}},counter=createSource(),source=reactExports.createContext(createSource()),getId=function(_){return _.value++},getPrefix=function(_){return _?_.prefix:""},generateUID=function(_){var j=_||counter,$=getPrefix(j),_e=getId(j),et=$+_e,tt=function(nt){return et+j.uid(nt)};return{uid:et,gen:tt}},useUIDState=function(){var _=reactExports.useContext(source),j=reactExports.useState(function(){return generateUID(_)})[0];return j},useUID=function(){var _=useUIDState().uid;return _},OverlaysContext=reactExports.createContext({hasProvider:!1,stack:{current:[]}}),OverlaysProvider=function(_){var j=_.children,$=reactExports.useRef([]),_e=reactExports.useMemo(function(){return{hasProvider:!0,stack:$}},[$]);return reactExports.createElement(OverlaysContext.Provider,{value:_e},j)},shim$1={exports:{}},useSyncExternalStoreShim_production_min$1={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var e$1=reactExports;function h$3(_,j){return _===j&&(_!==0||1/_===1/j)||_!==_&&j!==j}var k$1=typeof Object.is=="function"?Object.is:h$3,l$3=e$1.useState,m$2=e$1.useEffect,n$2=e$1.useLayoutEffect,p$5=e$1.useDebugValue;function q$2(_,j){var $=j(),_e=l$3({inst:{value:$,getSnapshot:j}}),et=_e[0].inst,tt=_e[1];return n$2(function(){et.value=$,et.getSnapshot=j,r$2(et)&&tt({inst:et})},[_,$,j]),m$2(function(){return r$2(et)&&tt({inst:et}),_(function(){r$2(et)&&tt({inst:et})})},[_]),p$5($),$}function r$2(_){var j=_.getSnapshot;_=_.value;try{var $=j();return!k$1(_,$)}catch{return!0}}function t$3(_,j){return j()}var u$4=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?t$3:q$2;useSyncExternalStoreShim_production_min$1.useSyncExternalStore=e$1.useSyncExternalStore!==void 0?e$1.useSyncExternalStore:u$4;shim$1.exports=useSyncExternalStoreShim_production_min$1;var shimExports$1=shim$1.exports,globalStack=[],globalStackListeners=[],modifyGlobalStack=function(_){_(globalStack),globalStackListeners.forEach(function(j){return j()})},legacyGlobalOverlayStackStore={getSnapshot:function(){return globalStack},subscribe:function(_){return globalStackListeners.push(_),function(){var j=globalStackListeners.indexOf(_);globalStackListeners.splice(j,1)}}};function useLegacyOverlayStack(){var _=shimExports$1.useSyncExternalStore(legacyGlobalOverlayStackStore.subscribe,legacyGlobalOverlayStackStore.getSnapshot,legacyGlobalOverlayStackStore.getSnapshot),j=React.useCallback(function(){return _.at(-1)},[_]),$=React.useCallback(function(nt){var rt=_.findIndex(function(at){return at.id===nt});return _.slice(rt)},[_]),_e=React.useCallback(function(){modifyGlobalStack(function(nt){return nt.splice(0,nt.length)})},[]),et=React.useCallback(function(nt){globalStack.push(nt),nt.props.usePortal&&nt.props.hasBackdrop&&document.body.classList.add(OVERLAY_OPEN)},[]),tt=React.useCallback(function(nt){var rt=_.filter(function(it){return it.props.usePortal&&it.props.hasBackdrop&&it.id!==nt}),at=globalStack.findIndex(function(it){return it.id===nt});at>-1&&globalStack.splice(at,1),rt.length===0&&document.body.classList.remove(OVERLAY_OPEN)},[_]);return{closeOverlay:tt,getLastOpened:j,getThisOverlayAndDescendants:$,openOverlay:et,resetStack:_e}}function useOverlayStack(){var _=React.useContext(OverlaysContext),j=_.stack,$=_.hasProvider,_e=useLegacyOverlayStack(),et=React.useCallback(function(){return j.current.at(-1)},[j]),tt=React.useCallback(function(it){var ot=j.current.findIndex(function(st){return st.id===it});return ot===-1?[]:j.current.slice(ot)},[j]),nt=React.useCallback(function(){j.current=[]},[j]),rt=React.useCallback(function(it){j.current.push(it),it.props.usePortal&&it.props.hasBackdrop&&document.body.classList.add(OVERLAY_OPEN)},[j]),at=React.useCallback(function(it){var ot=j.current.filter(function(ct){return ct.props.usePortal&&ct.props.hasBackdrop&&ct.id!==it}),st=j.current.findIndex(function(ct){return ct.id===it});st>-1&&j.current.splice(st,1),ot.length===0&&document.body.classList.remove(OVERLAY_OPEN)},[j]);return $?{closeOverlay:at,getLastOpened:et,getThisOverlayAndDescendants:tt,openOverlay:rt,resetStack:nt}:(isNodeEnv("development")&&console.error(OVERLAY2_REQUIRES_OVERLAY_PROVDER),_e)}function usePrevious(_){var j=reactExports.useRef();return reactExports.useEffect(function(){j.current=_},[_]),j.current}function getKeyboardFocusableElements(_){var j=getRef(_),$=j!=null?Array.from(j.querySelectorAll(['a[href]:not([tabindex="-1"])','button:not([disabled]):not([tabindex="-1"])','details:not([tabindex="-1"])','input:not([disabled]):not([tabindex="-1"])','select:not([disabled]):not([tabindex="-1"])','textarea:not([disabled]):not([tabindex="-1"])','[tabindex]:not([tabindex="-1"])'].join(","))):[];return $.filter(function(_e){return!_e.classList.contains(OVERLAY_START_FOCUS_TRAP)&&!_e.classList.contains(OVERLAY_END_FOCUS_TRAP)})}var PortalContext=reactExports.createContext({}),PORTAL_LEGACY_CONTEXT_TYPES={blueprintPortalClassName:function(_,j){if(_[j]!=null&&typeof _[j]!="string")return new Error(PORTAL_CONTEXT_CLASS_NAME_STRING)}};function Portal(_,j){var $,_e=_.className,et=_.stopPropagationEvents,tt=_.container,nt=_.onChildrenMount,rt=_.children;j===void 0&&(j={});var at=reactExports.useContext(PortalContext),it=($=tt??at.portalContainer)!==null&&$!==void 0?$:typeof document<"u"?document.body:void 0,ot=reactExports.useState(),st=ot[0],ct=ot[1],pt=reactExports.useCallback(function(){var dt=document.createElement("div");dt.classList.add(PORTAL),maybeAddClass(dt.classList,_e),maybeAddClass(dt.classList,at.portalClassName),addStopPropagationListeners(dt,et);var ft=j.blueprintPortalClassName;return ft!=null&&ft!==""&&(console.error(PORTAL_LEGACY_CONTEXT_API),maybeAddClass(dt.classList,ft)),dt},[_e,at.portalClassName,j.blueprintPortalClassName,et]);return reactExports.useEffect(function(){if(it!=null){var dt=pt();return it.appendChild(dt),ct(dt),function(){removeStopPropagationListeners(dt,et),dt.remove(),ct(void 0)}}},[it,pt,et]),reactExports.useEffect(function(){st!=null&&(nt==null||nt())},[st,nt]),reactExports.useEffect(function(){if(st!=null)return maybeAddClass(st.classList,_e),function(){return maybeRemoveClass(st.classList,_e)}},[_e,st]),reactExports.useEffect(function(){if(st!=null)return addStopPropagationListeners(st,et),function(){return removeStopPropagationListeners(st,et)}},[st,et]),typeof document>"u"||st==null?null:reactDomExports.createPortal(rt,st)}Portal.displayName="".concat(DISPLAYNAME_PREFIX,".Portal");isReact18()||(Portal.contextTypes=PORTAL_LEGACY_CONTEXT_TYPES);function maybeRemoveClass(_,j){j!=null&&j!==""&&_.remove.apply(_,j.split(" "))}function maybeAddClass(_,j){j!=null&&j!==""&&_.add.apply(_,j.split(" "))}function addStopPropagationListeners(_,j){j==null||j.forEach(function($){return _.addEventListener($,handleStopProgation)})}function removeStopPropagationListeners(_,j){j==null||j.forEach(function($){return _.removeEventListener($,handleStopProgation)})}function handleStopProgation(_){_.stopPropagation()}var Overlay2=reactExports.forwardRef(function(_,j){var $,_e,et,tt=_.autoFocus,nt=_.backdropClassName,rt=_.backdropProps,at=_.canEscapeKeyClose,it=_.canOutsideClickClose,ot=_.childRef,st=_.childRefs,ct=_.children,pt=_.className,dt=_.enforceFocus,ft=_.hasBackdrop,gt=_.isOpen,ut=_.lazy,lt=_.onClose,ht=_.onClosed,yt=_.onClosing,vt=_.onOpened,bt=_.onOpening,mt=_.portalClassName,_t=_.portalContainer,Et=_.shouldReturnFocusOnClose,wt=_.transitionDuration,St=_.transitionName,Tt=_.usePortal;useOverlay2Validation(_);var At=useOverlayStack(),Ht=At.closeOverlay,Rt=At.getLastOpened,Ft=At.getThisOverlayAndDescendants,Vt=At.openOverlay,kt=reactExports.useState(!1),Ot=kt[0],Dt=kt[1],$t=reactExports.useState(!1),Pt=$t[0],zt=$t[1],Mt=reactExports.useRef(null),It=reactExports.useRef(null),Lt=reactExports.useRef(null),Ut=reactExports.useRef(null),Zt=reactExports.useRef(null),rn=reactExports.useRef(null),qt=reactExports.useCallback(function(){return requestAnimationFrame(function(){var xt,jt=getRef(It),Ct=getActiveElement(jt);if(!(jt==null||Ct==null)){var Nt=!jt.contains(Ct);Nt&&((xt=getRef(Ut))===null||xt===void 0||xt.focus({preventScroll:!0}),Dt(!1))}})},[]),Gt=useOverlay2ID(),en=reactExports.useRef(null),Wt=reactExports.useCallback(function(xt){var jt=xt.composed?xt.composedPath()[0]:xt.target,Ct=getRef(It);Ct!=null&&jt instanceof Node&&!Ct.contains(jt)&&(xt.preventDefault(),xt.stopImmediatePropagation(),qt())},[qt]),Kt=reactExports.useCallback(function(xt){var jt=xt.composed?xt.composedPath()[0]:xt.target,Ct=Ft(Gt),Nt=Ct.some(function(Bt){var yn=Bt.containerElement,Xt=getRef(yn);return(Xt==null?void 0:Xt.contains(jt))&&!Xt.isSameNode(jt)});Nt||lt==null||lt(xt)},[Ft,Gt,lt]);reactExports.useEffect(function(){document.removeEventListener("mousedown",Kt)},[Kt]),reactExports.useEffect(function(){document.removeEventListener("focus",Wt,!0)},[Wt]);var pn=reactExports.useMemo(function(){return mergeRefs(j,en)},[j]);reactExports.useImperativeHandle(pn,function(){return{bringFocusInsideOverlay:qt,containerElement:It,handleDocumentFocus:Wt,handleDocumentMousedown:Kt,id:Gt,props:{autoFocus:tt,enforceFocus:dt,hasBackdrop:ft,usePortal:Tt}}},[tt,qt,dt,Wt,Kt,ft,Gt,Tt]);var fn=reactExports.useCallback(function(xt){xt.key==="Escape"&&at&&(lt==null||lt(xt),xt.stopPropagation(),xt.preventDefault())},[at,lt]),an=reactExports.useCallback(function(){if(en.current!=null){var xt=Rt();(xt==null?void 0:xt.handleDocumentFocus)!==void 0&&document.removeEventListener("focus",xt.handleDocumentFocus,!0),Vt(en.current),tt&&(Dt(!0),qt()),dt&&document.addEventListener("focus",Wt,!0),it&&!ft&&document.addEventListener("mousedown",Kt),setRef$1(Mt,getActiveElement(getRef(It)))}},[tt,qt,it,dt,Rt,Kt,Wt,ft,Vt]),tn=reactExports.useCallback(function(){var xt;document.removeEventListener("focus",Wt,!0),document.removeEventListener("mousedown",Kt),Ht(Gt);var jt=Rt();jt!==void 0&&jt.props.autoFocus&&jt.props.enforceFocus&&((xt=jt.bringFocusInsideOverlay)===null||xt===void 0||xt.call(jt),jt.handleDocumentFocus!==void 0&&document.addEventListener("focus",jt.handleDocumentFocus,!0))},[Ht,Rt,Wt,Kt,Gt]),nn=(_e=usePrevious(gt))!==null&&_e!==void 0?_e:!1;reactExports.useEffect(function(){gt&&zt(!0),!nn&&gt&&an(),nn&&!gt&&tn()},[gt,an,tn,nn]),reactExports.useEffect(function(){return function(){tn()}},[]);var on=reactExports.useCallback(function(xt){var jt=getRef(Mt);Et&&jt instanceof HTMLElement&&jt.focus(),ht==null||ht(xt)},[ht,Et]),Jt=reactExports.useCallback(function(){},[]),sn=reactExports.useCallback(function(xt){if(ot!=null)return ot;if(st!=null){var jt=xt.key;if(jt==null){isNodeEnv("production")||console.error(OVERLAY_CHILD_REQUIRES_KEY);return}return st[jt]}},[ot,st]),hn=reactExports.useCallback(function(xt){if(xt==null||isEmptyString(xt))return null;var jt=sn(xt),Ct=isReactElement(xt)?xt.props:{},Nt=ensureElement(xt,"span",{className:classNames(Ct.className,OVERLAY_CONTENT),ref:jt===void 0?rn:void 0,tabIndex:dt||tt?0:void 0}),Bt=jt??rn;return reactExports.createElement(CSSTransition,{addEndListener:Jt,classNames:St,nodeRef:Bt,onEntered:getLifecycleCallbackWithChildRef(vt,Bt),onEntering:getLifecycleCallbackWithChildRef(bt,Bt),onExited:getLifecycleCallbackWithChildRef(on,Bt),onExiting:getLifecycleCallbackWithChildRef(yt,Bt),timeout:wt},Nt)},[tt,dt,sn,Jt,on,yt,vt,bt,wt,St]),cn=reactExports.useCallback(function(xt){var jt;it&&(lt==null||lt(xt)),dt&&qt(),(jt=rt==null?void 0:rt.onMouseDown)===null||jt===void 0||jt.call(rt,xt)},[rt,qt,it,dt,lt]),ln=reactExports.useCallback(function(xt,jt){return reactExports.createElement(CSSTransition,{addEndListener:Jt,classNames:St,key:xt,nodeRef:jt.ref,timeout:wt,unmountOnExit:!0},reactExports.createElement("div",__assign$4({tabIndex:0},jt)))},[Jt,wt,St]),mn=reactExports.useCallback(function(xt){if(!(!dt||Ot)){var jt=getRef(It),Ct=getRef(Zt);xt.relatedTarget!=null&&(jt!=null&&jt.contains(xt.relatedTarget))&&xt.relatedTarget!==Ct&&(Ct==null||Ct.focus({preventScroll:!0}))}},[dt,Ot]),_n=reactExports.useCallback(function(xt){var jt;if(dt&&xt.shiftKey&&xt.key==="Tab"){var Ct=getKeyboardFocusableElements(It).pop();Ct!=null?Ct.focus():(jt=getRef(Zt))===null||jt===void 0||jt.focus({preventScroll:!0})}},[dt]),gn=reactExports.useCallback(function(xt){var jt,Ct=getRef(Ut);if(xt.relatedTarget!=null&&(!((jt=getRef(It))===null||jt===void 0)&&jt.contains(xt.relatedTarget))&&xt.relatedTarget!==Ct){var Nt=getKeyboardFocusableElements(It).shift();!Ot&&Nt!=null&&Nt!==xt.relatedTarget?Nt.focus():Ct==null||Ct.focus({preventScroll:!0})}else{var Bt=getKeyboardFocusableElements(It).pop();Bt!=null?Bt.focus():Ct==null||Ct.focus({preventScroll:!0})}},[Ot]),un=reactExports.useMemo(function(){return ft&&gt?reactExports.createElement(CSSTransition,{classNames:St,key:"__backdrop",nodeRef:Lt,timeout:wt,addEndListener:Jt},reactExports.createElement("div",__assign$4({},rt,{className:classNames(OVERLAY_BACKDROP,nt,rt==null?void 0:rt.className),onMouseDown:cn,ref:Lt}))):null},[nt,rt,cn,Jt,ft,gt,wt,St]);if(ut&&!Pt)return null;var Yt=gt?(et=reactExports.Children.map(ct,hn))!==null&&et!==void 0?et:[]:[];un!==null&&Yt.unshift(un),gt&&(tt||dt)&&Yt.length>0&&(Yt.unshift(ln("__start",{className:OVERLAY_START_FOCUS_TRAP,onFocus:mn,onKeyDown:_n,ref:Ut})),dt&&Yt.push(ln("__end",{className:OVERLAY_END_FOCUS_TRAP,onFocus:gn,ref:Zt})));var dn=reactExports.createElement("div",{"aria-live":"polite",className:classNames(OVERLAY,($={},$[OVERLAY_OPEN]=gt,$[OVERLAY_INLINE]=!Tt,$),pt),onKeyDown:fn,ref:It},reactExports.createElement(TransitionGroup,{appear:!0,component:null},Yt));return Tt?reactExports.createElement(Portal,{className:mt,container:_t},dn):dn});Overlay2.defaultProps={autoFocus:!0,backdropProps:{},canEscapeKeyClose:!0,canOutsideClickClose:!0,enforceFocus:!0,hasBackdrop:!0,isOpen:!1,lazy:hasDOMEnvironment(),shouldReturnFocusOnClose:!0,transitionDuration:300,transitionName:OVERLAY,usePortal:!0};Overlay2.displayName="".concat(DISPLAYNAME_PREFIX,".Overlay2");function useOverlay2Validation(_){var j=_.childRef,$=_.childRefs,_e=_.children,et=reactExports.Children.count(_e);reactExports.useEffect(function(){isNodeEnv("production")||(j!=null&&$!=null&&console.error(OVERLAY_CHILD_REF_AND_REFS_MUTEX),et>1&&$==null&&console.error(OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS))},[j,$,et])}function useOverlay2ID(){var _=useUID();return"".concat(Overlay2.displayName,"-").concat(_)}function getLifecycleCallbackWithChildRef(_,j){return function(){(j==null?void 0:j.current)!=null&&(_==null||_(j.current))}}var HTMLSelect=reactExports.forwardRef(function(_,j){var $,_e=_.className,et=_.children,tt=_.disabled,nt=_.fill,rt=_.iconName,at=rt===void 0?"double-caret-vertical":rt,it=_.iconProps,ot=_.large,st=_.minimal,ct=_.options,pt=ct===void 0?[]:ct,dt=_.value,ft=__rest(_,["className","children","disabled","fill","iconName","iconProps","large","minimal","options","value"]),gt=classNames(HTML_SELECT,($={},$[DISABLED]=tt,$[FILL]=nt,$[LARGE]=ot,$[MINIMAL]=st,$),_e),ut="Open dropdown",lt=at==="double-caret-vertical"?reactExports.createElement(DoubleCaretVertical,__assign$4({title:ut},it)):reactExports.createElement(CaretDown,__assign$4({title:ut},it)),ht=pt.map(function(yt){var vt=typeof yt=="object"?yt:{value:yt};return reactExports.createElement("option",__assign$4({},vt,{key:vt.value,children:vt.label||vt.value}))});return reactExports.createElement("div",{className:gt},reactExports.createElement("select",__assign$4({disabled:tt,ref:j,value:dt},ft,{multiple:!1}),ht,et),lt)});HTMLSelect.displayName="".concat(DISPLAYNAME_PREFIX,".HTMLSelect");function baseSlice$3(_,j,$){var _e=-1,et=_.length;j<0&&(j=-j>et?0:et+j),$=$>et?et:$,$<0&&($+=et),et=j>$?0:$-j>>>0,j>>>=0;for(var tt=Array(et);++_e<et;)tt[_e]=_[_e+j];return tt}var _baseSlice=baseSlice$3,reWhitespace=/\s/;function trimmedEndIndex$1(_){for(var j=_.length;j--&&reWhitespace.test(_.charAt(j)););return j}var _trimmedEndIndex=trimmedEndIndex$1,trimmedEndIndex=_trimmedEndIndex,reTrimStart=/^\s+/;function baseTrim$1(_){return _&&_.slice(0,trimmedEndIndex(_)+1).replace(reTrimStart,"")}var _baseTrim=baseTrim$1;function isObject$b(_){var j=typeof _;return _!=null&&(j=="object"||j=="function")}var isObject_1=isObject$b,freeGlobal$1=typeof commonjsGlobal=="object"&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal,_freeGlobal=freeGlobal$1,freeGlobal=_freeGlobal,freeSelf=typeof self=="object"&&self&&self.Object===Object&&self,root$9=freeGlobal||freeSelf||Function("return this")(),_root=root$9,root$8=_root,Symbol$7=root$8.Symbol,_Symbol=Symbol$7,Symbol$6=_Symbol,objectProto$g=Object.prototype,hasOwnProperty$d=objectProto$g.hasOwnProperty,nativeObjectToString$1=objectProto$g.toString,symToStringTag$1=Symbol$6?Symbol$6.toStringTag:void 0;function getRawTag$1(_){var j=hasOwnProperty$d.call(_,symToStringTag$1),$=_[symToStringTag$1];try{_[symToStringTag$1]=void 0;var _e=!0}catch{}var et=nativeObjectToString$1.call(_);return _e&&(j?_[symToStringTag$1]=$:delete _[symToStringTag$1]),et}var _getRawTag=getRawTag$1,objectProto$f=Object.prototype,nativeObjectToString=objectProto$f.toString;function objectToString$1(_){return nativeObjectToString.call(_)}var _objectToString=objectToString$1,Symbol$5=_Symbol,getRawTag=_getRawTag,objectToString=_objectToString,nullTag="[object Null]",undefinedTag="[object Undefined]",symToStringTag=Symbol$5?Symbol$5.toStringTag:void 0;function baseGetTag$5(_){return _==null?_===void 0?undefinedTag:nullTag:symToStringTag&&symToStringTag in Object(_)?getRawTag(_):objectToString(_)}var _baseGetTag=baseGetTag$5;function isObjectLike$7(_){return _!=null&&typeof _=="object"}var isObjectLike_1=isObjectLike$7,baseGetTag$4=_baseGetTag,isObjectLike$6=isObjectLike_1,symbolTag$3="[object Symbol]";function isSymbol$4(_){return typeof _=="symbol"||isObjectLike$6(_)&&baseGetTag$4(_)==symbolTag$3}var isSymbol_1=isSymbol$4,baseTrim=_baseTrim,isObject$a=isObject_1,isSymbol$3=isSymbol_1,NAN=NaN,reIsBadHex=/^[-+]0x[0-9a-f]+$/i,reIsBinary=/^0b[01]+$/i,reIsOctal=/^0o[0-7]+$/i,freeParseInt=parseInt;function toNumber$3(_){if(typeof _=="number")return _;if(isSymbol$3(_))return NAN;if(isObject$a(_)){var j=typeof _.valueOf=="function"?_.valueOf():_;_=isObject$a(j)?j+"":j}if(typeof _!="string")return _===0?_:+_;_=baseTrim(_);var $=reIsBinary.test(_);return $||reIsOctal.test(_)?freeParseInt(_.slice(2),$?2:8):reIsBadHex.test(_)?NAN:+_}var toNumber_1=toNumber$3,toNumber$2=toNumber_1,INFINITY$2=1/0,MAX_INTEGER=17976931348623157e292;function toFinite$1(_){if(!_)return _===0?_:0;if(_=toNumber$2(_),_===INFINITY$2||_===-INFINITY$2){var j=_<0?-1:1;return j*MAX_INTEGER}return _===_?_:0}var toFinite_1=toFinite$1,toFinite=toFinite_1;function toInteger$3(_){var j=toFinite(_),$=j%1;return j===j?$?j-$:j:0}var toInteger_1=toInteger$3,baseSlice$2=_baseSlice,toInteger$2=toInteger_1;function dropRight(_,j,$){var _e=_==null?0:_.length;return _e?(j=$||j===void 0?1:toInteger$2(j),j=_e-j,baseSlice$2(_,0,j<0?0:j)):[]}var dropRight_1$2=dropRight;const dropRight$1=getDefaultExportFromCjs(dropRight_1$2);var imjoyCore$1={exports:{}};(function(module,exports){(function(j,$){module.exports=$()})(window,function(){return function(_){var j={};function $(_e){if(j[_e])return j[_e].exports;var et=j[_e]={i:_e,l:!1,exports:{}};return _[_e].call(et.exports,et,et.exports,$),et.l=!0,et.exports}return $.m=_,$.c=j,$.d=function(_e,et,tt){$.o(_e,et)||Object.defineProperty(_e,et,{enumerable:!0,get:tt})},$.r=function(_e){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(_e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(_e,"__esModule",{value:!0})},$.t=function(_e,et){if(et&1&&(_e=$(_e)),et&8||et&4&&typeof _e=="object"&&_e&&_e.__esModule)return _e;var tt=Object.create(null);if($.r(tt),Object.defineProperty(tt,"default",{enumerable:!0,value:_e}),et&2&&typeof _e!="string")for(var nt in _e)$.d(tt,nt,(function(rt){return _e[rt]}).bind(null,nt));return tt},$.n=function(_e){var et=_e&&_e.__esModule?function(){return _e.default}:function(){return _e};return $.d(et,"a",et),et},$.o=function(_e,et){return Object.prototype.hasOwnProperty.call(_e,et)},$.p="",$($.s="./src/imjoyCore.js")}({"./node_modules/ajv/lib/ajv.js":function(module,exports,__webpack_require__){eval(`

var compileSchema = __webpack_require__(/*! ./compile */ "./node_modules/ajv/lib/compile/index.js")
  , resolve = __webpack_require__(/*! ./compile/resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , Cache = __webpack_require__(/*! ./cache */ "./node_modules/ajv/lib/cache.js")
  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js")
  , formats = __webpack_require__(/*! ./compile/formats */ "./node_modules/ajv/lib/compile/formats.js")
  , rules = __webpack_require__(/*! ./compile/rules */ "./node_modules/ajv/lib/compile/rules.js")
  , $dataMetaSchema = __webpack_require__(/*! ./data */ "./node_modules/ajv/lib/data.js")
  , util = __webpack_require__(/*! ./compile/util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ "./node_modules/ajv/lib/compile/async.js");
var customKeyword = __webpack_require__(/*! ./keyword */ "./node_modules/ajv/lib/keyword.js");
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;

var errorClasses = __webpack_require__(/*! ./compile/error_classes */ "./node_modules/ajv/lib/compile/error_classes.js");
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: \`Ajv(opts)\`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in \`ajv.errors\` (and also in compiled schema: \`schema.errors\`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, \`key\` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to \`validate\` method instead of schema object or id/ref. One schema per instance can have empty \`id\` and \`key\`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by \`key\` or \`ref\`.
 * @this   Ajv
 * @param  {String} keyRef \`key\` that was passed to \`addSchema\` or full schema reference (\`schema.id\` or resolved id).
 * @return {Function} schema validating function (with property \`schema\`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties \`separator\` and \`dataVar\`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = __webpack_require__(/*! ./refs/data.json */ "./node_modules/ajv/lib/refs/data.json");
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/ajv.js?`)},"./node_modules/ajv/lib/cache.js":function(module,exports,__webpack_require__){eval(`


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/cache.js?`)},"./node_modules/ajv/lib/compile/async.js":function(module,exports,__webpack_require__){eval(`

var MissingRefError = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js").MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * \`loadSchema\` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/async.js?`)},"./node_modules/ajv/lib/compile/error_classes.js":function(module,exports,__webpack_require__){eval(`

var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js");

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/error_classes.js?`)},"./node_modules/ajv/lib/compile/formats.js":function(module,exports,__webpack_require__){eval(`

var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

var DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\\x00-\\x20"'<>%\\\\^\`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;
var URL = /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,
  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\\/?\\/)?[^\\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_\`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_\`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,
  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\\\]\\\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/formats.js?`)},"./node_modules/ajv/lib/compile/index.js":function(module,exports,__webpack_require__){eval(`

var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , errorClasses = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");

var validateGenerator = __webpack_require__(/*! ../dotjs/validate */ "./node_modules/ajv/lib/dotjs/validate.js");

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\\n\\n\\n *** \\n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/index.js?`)},"./node_modules/ajv/lib/compile/resolve.js":function(module,exports,__webpack_require__){eval(`

var URI = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js")
  , equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , SchemaObject = __webpack_require__(/*! ./schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , traverse = __webpack_require__(/*! json-schema-traverse */ "./node_modules/json-schema-traverse/index.js");

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/resolve.js?`)},"./node_modules/ajv/lib/compile/rules.js":function(module,exports,__webpack_require__){eval(`

var ruleModules = __webpack_require__(/*! ../dotjs */ "./node_modules/ajv/lib/dotjs/index.js")
  , toHash = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js").toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/rules.js?`)},"./node_modules/ajv/lib/compile/schema_obj.js":function(module,exports,__webpack_require__){eval(`

var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/schema_obj.js?`)},"./node_modules/ajv/lib/compile/ucs2length.js":function(module,exports,__webpack_require__){eval(`

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/ucs2length.js?`)},"./node_modules/ajv/lib/compile/util.js":function(module,exports,__webpack_require__){eval(`


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js"),
  ucs2length: __webpack_require__(/*! ./ucs2length */ "./node_modules/ajv/lib/compile/ucs2length.js"),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\\\$&')
            .replace(/\\n/g, '\\\\n')
            .replace(/\\r/g, '\\\\r')
            .replace(/\\f/g, '\\\\f')
            .replace(/\\t/g, '\\\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\\s*{\\s*}/g
  , EMPTY_IF_NO_ELSE = /if\\s*\\([^)]+\\)\\s*\\{\\s*\\}(?!\\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\\s*\\(([^)]+)\\)\\s*\\{\\s*\\}\\s*else(?!\\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \\(errors === 0\\) return data;\\s*else throw new ValidationError\\(vErrors\\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \\(rootData === undefined\\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) {
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  }

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\\'' + escapeQuotes(str) + '\\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')
              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \\+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/compile/util.js?`)},"./node_modules/ajv/lib/data.js":function(module,exports,__webpack_require__){eval(`

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/data.js?`)},"./node_modules/ajv/lib/definition_schema.js":function(module,exports,__webpack_require__){eval(`

var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");

module.exports = {
  $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/definition_schema.js?`)},"./node_modules/ajv/lib/dotjs/_limit.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\\' + ' + $opExpr + ' + \\'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \\'boolean\\' && ' + ($exclType) + ' != \\'undefined\\' && ' + ($exclType) + ' != \\'number\\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ($errorKeyword || '_exclusiveLimit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'' + ($exclusiveKeyword) + ' should be boolean\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
    }
    out += ' ' + ($exclType) + ' == \\'number\\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \\'' + ($op) + '\\' : \\'' + ($op) + '=\\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\\'' + $opStr + '\\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\\'' + $opStr + '\\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limit.js?`)},"./node_modules/ajv/lib/dotjs/_limitItems.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limitItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limitItems.js?`)},"./node_modules/ajv/lib/dotjs/_limitLength.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limitLength') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limitLength.js?`)},"./node_modules/ajv/lib/dotjs/_limitProperties.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ($errorKeyword || '_limitProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/_limitProperties.js?`)},"./node_modules/ajv/lib/dotjs/allOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/allOf.js?`)},"./node_modules/ajv/lib/dotjs/anyOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('anyOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should match some schema in anyOf\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/anyOf.js?`)},"./node_modules/ajv/lib/dotjs/comment.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/comment.js?`)},"./node_modules/ajv/lib/dotjs/const.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('const') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be equal to constant\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/const.js?`)},"./node_modules/ajv/lib/dotjs/contains.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('contains') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should contain a valid item\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/contains.js?`)},"./node_modules/ajv/lib/dotjs/custom.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\\'' + ($keyword) + '\\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \\'\\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should pass "' + ($rule.keyword) + '" keyword validation\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \\'should pass "' + ($rule.keyword) + '" keyword validation\\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/custom.js?`)},"./node_modules/ajv/lib/dotjs/dependencies.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \\'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/dependencies.js?`)},"./node_modules/ajv/lib/dotjs/enum.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('enum') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be equal to one of the allowed values\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/enum.js?`)},"./node_modules/ajv/lib/dotjs/format.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \\'object\\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \\'string\\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \\'' + ($ruleType) + '\\' && !(typeof ' + ($format) + ' == \\'function\\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('format') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should match format "';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/format.js?`)},"./node_modules/ajv/lib/dotjs/if.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \\'then\\'; ';
      } else {
        $ifClause = '\\'then\\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \\'else\\'; ';
      } else {
        $ifClause = '\\'else\\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('if') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should match "\\' + ' + ($ifClause) + ' + \\'" schema\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/if.js?`)},"./node_modules/ajv/lib/dotjs/index.js":function(module,exports,__webpack_require__){eval(`

//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': __webpack_require__(/*! ./ref */ "./node_modules/ajv/lib/dotjs/ref.js"),
  allOf: __webpack_require__(/*! ./allOf */ "./node_modules/ajv/lib/dotjs/allOf.js"),
  anyOf: __webpack_require__(/*! ./anyOf */ "./node_modules/ajv/lib/dotjs/anyOf.js"),
  '$comment': __webpack_require__(/*! ./comment */ "./node_modules/ajv/lib/dotjs/comment.js"),
  const: __webpack_require__(/*! ./const */ "./node_modules/ajv/lib/dotjs/const.js"),
  contains: __webpack_require__(/*! ./contains */ "./node_modules/ajv/lib/dotjs/contains.js"),
  dependencies: __webpack_require__(/*! ./dependencies */ "./node_modules/ajv/lib/dotjs/dependencies.js"),
  'enum': __webpack_require__(/*! ./enum */ "./node_modules/ajv/lib/dotjs/enum.js"),
  format: __webpack_require__(/*! ./format */ "./node_modules/ajv/lib/dotjs/format.js"),
  'if': __webpack_require__(/*! ./if */ "./node_modules/ajv/lib/dotjs/if.js"),
  items: __webpack_require__(/*! ./items */ "./node_modules/ajv/lib/dotjs/items.js"),
  maximum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  minimum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  maxItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  minItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  maxLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  minLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  maxProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  minProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  multipleOf: __webpack_require__(/*! ./multipleOf */ "./node_modules/ajv/lib/dotjs/multipleOf.js"),
  not: __webpack_require__(/*! ./not */ "./node_modules/ajv/lib/dotjs/not.js"),
  oneOf: __webpack_require__(/*! ./oneOf */ "./node_modules/ajv/lib/dotjs/oneOf.js"),
  pattern: __webpack_require__(/*! ./pattern */ "./node_modules/ajv/lib/dotjs/pattern.js"),
  properties: __webpack_require__(/*! ./properties */ "./node_modules/ajv/lib/dotjs/properties.js"),
  propertyNames: __webpack_require__(/*! ./propertyNames */ "./node_modules/ajv/lib/dotjs/propertyNames.js"),
  required: __webpack_require__(/*! ./required */ "./node_modules/ajv/lib/dotjs/required.js"),
  uniqueItems: __webpack_require__(/*! ./uniqueItems */ "./node_modules/ajv/lib/dotjs/uniqueItems.js"),
  validate: __webpack_require__(/*! ./validate */ "./node_modules/ajv/lib/dotjs/validate.js")
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/index.js?`)},"./node_modules/ajv/lib/dotjs/items.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \\'' + ('additionalItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/items.js?`)},"./node_modules/ajv/lib/dotjs/multipleOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \\'number\\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('multipleOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should be multiple of ';
      if ($isData) {
        out += '\\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/multipleOf.js?`)},"./node_modules/ajv/lib/dotjs/not.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should NOT be valid\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should NOT be valid\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/not.js?`)},"./node_modules/ajv/lib/dotjs/oneOf.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('oneOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should match exactly one schema in oneOf\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/oneOf.js?`)},"./node_modules/ajv/lib/dotjs/pattern.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \\'' + ('pattern') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \\'should match pattern "';
      if ($isData) {
        out += '\\' + ' + ($schemaValue) + ' + \\'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/pattern.js?`)},"./node_modules/ajv/lib/dotjs/properties.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\\' + ' + $key + ' + \\'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \\'' + ('additionalProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \\'' + ($additionalProperty) + '\\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \\'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \\'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
                  }
                  out += '\\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/properties.js?`)},"./node_modules/ajv/lib/dotjs/propertyNames.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\\' + ' + $key + ' + \\'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('propertyNames') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \\'' + ($invalidName) + '\\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'property name \\\\\\'' + ($invalidName) + '\\\\\\' is invalid\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/propertyNames.js?`)},"./node_modules/ajv/lib/dotjs/ref.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('$ref') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \\'' + (it.util.escapeQuotes($schema)) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \\'\\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/ref.js?`)},"./node_modules/ajv/lib/dotjs/required.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \\'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
              }
              out += '\\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \\'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';
                }
                out += '\\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/required.js?`)},"./node_modules/ajv/lib/dotjs/uniqueItems.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \\'boolean\\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \\'string\\') item = \\'"\\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \\'number\\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \\'' + ('uniqueItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/uniqueItems.js?`)},"./node_modules/ajv/lib/dotjs/validate.js":function(module,exports,__webpack_require__){eval(`
module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \\'use strict\\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \\'' + ($errorKeyword || 'false schema') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \\'boolean schema is false\\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \\'object\\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \\'array\\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \\'array\\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\') ' + ($coerced) + ' = \\'\\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \\'\\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \\'string\\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \\'false\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \\'true\\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \\'\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \\'string\\' || ' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \\'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \\'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top) {
    out = it.util.finalCleanUpCode(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/dotjs/validate.js?`)},"./node_modules/ajv/lib/keyword.js":function(module,exports,__webpack_require__){eval(`

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = __webpack_require__(/*! ./dotjs/custom */ "./node_modules/ajv/lib/dotjs/custom.js");
var definitionSchema = __webpack_require__(/*! ./definition_schema */ "./node_modules/ajv/lib/definition_schema.js");

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties \`type\` (type(s) which the keyword applies to), \`validate\` or \`compile\`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, \`true\` if it is a predefined keyword, \`false\` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definitionSchema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/keyword.js?`)},"./node_modules/ajv/lib/refs/data.json":function(module){eval(`module.exports = JSON.parse("{\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"$id\\":\\"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#\\",\\"description\\":\\"Meta-schema for $data reference (JSON Schema extension proposal)\\",\\"type\\":\\"object\\",\\"required\\":[\\"$data\\"],\\"properties\\":{\\"$data\\":{\\"type\\":\\"string\\",\\"anyOf\\":[{\\"format\\":\\"relative-json-pointer\\"},{\\"format\\":\\"json-pointer\\"}]}},\\"additionalProperties\\":false}");

//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/refs/data.json?`)},"./node_modules/ajv/lib/refs/json-schema-draft-07.json":function(module){eval(`module.exports = JSON.parse("{\\"$schema\\":\\"http://json-schema.org/draft-07/schema#\\",\\"$id\\":\\"http://json-schema.org/draft-07/schema#\\",\\"title\\":\\"Core schema meta-schema\\",\\"definitions\\":{\\"schemaArray\\":{\\"type\\":\\"array\\",\\"minItems\\":1,\\"items\\":{\\"$ref\\":\\"#\\"}},\\"nonNegativeInteger\\":{\\"type\\":\\"integer\\",\\"minimum\\":0},\\"nonNegativeIntegerDefault0\\":{\\"allOf\\":[{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},{\\"default\\":0}]},\\"simpleTypes\\":{\\"enum\\":[\\"array\\",\\"boolean\\",\\"integer\\",\\"null\\",\\"number\\",\\"object\\",\\"string\\"]},\\"stringArray\\":{\\"type\\":\\"array\\",\\"items\\":{\\"type\\":\\"string\\"},\\"uniqueItems\\":true,\\"default\\":[]}},\\"type\\":[\\"object\\",\\"boolean\\"],\\"properties\\":{\\"$id\\":{\\"type\\":\\"string\\",\\"format\\":\\"uri-reference\\"},\\"$schema\\":{\\"type\\":\\"string\\",\\"format\\":\\"uri\\"},\\"$ref\\":{\\"type\\":\\"string\\",\\"format\\":\\"uri-reference\\"},\\"$comment\\":{\\"type\\":\\"string\\"},\\"title\\":{\\"type\\":\\"string\\"},\\"description\\":{\\"type\\":\\"string\\"},\\"default\\":true,\\"readOnly\\":{\\"type\\":\\"boolean\\",\\"default\\":false},\\"examples\\":{\\"type\\":\\"array\\",\\"items\\":true},\\"multipleOf\\":{\\"type\\":\\"number\\",\\"exclusiveMinimum\\":0},\\"maximum\\":{\\"type\\":\\"number\\"},\\"exclusiveMaximum\\":{\\"type\\":\\"number\\"},\\"minimum\\":{\\"type\\":\\"number\\"},\\"exclusiveMinimum\\":{\\"type\\":\\"number\\"},\\"maxLength\\":{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},\\"minLength\\":{\\"$ref\\":\\"#/definitions/nonNegativeIntegerDefault0\\"},\\"pattern\\":{\\"type\\":\\"string\\",\\"format\\":\\"regex\\"},\\"additionalItems\\":{\\"$ref\\":\\"#\\"},\\"items\\":{\\"anyOf\\":[{\\"$ref\\":\\"#\\"},{\\"$ref\\":\\"#/definitions/schemaArray\\"}],\\"default\\":true},\\"maxItems\\":{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},\\"minItems\\":{\\"$ref\\":\\"#/definitions/nonNegativeIntegerDefault0\\"},\\"uniqueItems\\":{\\"type\\":\\"boolean\\",\\"default\\":false},\\"contains\\":{\\"$ref\\":\\"#\\"},\\"maxProperties\\":{\\"$ref\\":\\"#/definitions/nonNegativeInteger\\"},\\"minProperties\\":{\\"$ref\\":\\"#/definitions/nonNegativeIntegerDefault0\\"},\\"required\\":{\\"$ref\\":\\"#/definitions/stringArray\\"},\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"definitions\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"default\\":{}},\\"properties\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"default\\":{}},\\"patternProperties\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"$ref\\":\\"#\\"},\\"propertyNames\\":{\\"format\\":\\"regex\\"},\\"default\\":{}},\\"dependencies\\":{\\"type\\":\\"object\\",\\"additionalProperties\\":{\\"anyOf\\":[{\\"$ref\\":\\"#\\"},{\\"$ref\\":\\"#/definitions/stringArray\\"}]}},\\"propertyNames\\":{\\"$ref\\":\\"#\\"},\\"const\\":true,\\"enum\\":{\\"type\\":\\"array\\",\\"items\\":true,\\"minItems\\":1,\\"uniqueItems\\":true},\\"type\\":{\\"anyOf\\":[{\\"$ref\\":\\"#/definitions/simpleTypes\\"},{\\"type\\":\\"array\\",\\"items\\":{\\"$ref\\":\\"#/definitions/simpleTypes\\"},\\"minItems\\":1,\\"uniqueItems\\":true}]},\\"format\\":{\\"type\\":\\"string\\"},\\"contentMediaType\\":{\\"type\\":\\"string\\"},\\"contentEncoding\\":{\\"type\\":\\"string\\"},\\"if\\":{\\"$ref\\":\\"#\\"},\\"then\\":{\\"$ref\\":\\"#\\"},\\"else\\":{\\"$ref\\":\\"#\\"},\\"allOf\\":{\\"$ref\\":\\"#/definitions/schemaArray\\"},\\"anyOf\\":{\\"$ref\\":\\"#/definitions/schemaArray\\"},\\"oneOf\\":{\\"$ref\\":\\"#/definitions/schemaArray\\"},\\"not\\":{\\"$ref\\":\\"#\\"}},\\"default\\":true}");

//# sourceURL=webpack://%5Bname%5D/./node_modules/ajv/lib/refs/json-schema-draft-07.json?`)},"./node_modules/argsarray/index.js":function(module,exports,__webpack_require__){eval(`

module.exports = argsArray;

function argsArray(fun) {
  return function () {
    var len = arguments.length;
    if (len) {
      var args = [];
      var i = -1;
      while (++i < len) {
        args[i] = arguments[i];
      }
      return fun.call(this, args);
    } else {
      return fun.call(this, []);
    }
  };
}

//# sourceURL=webpack://%5Bname%5D/./node_modules/argsarray/index.js?`)},"./node_modules/axios/index.js":function(module,exports,__webpack_require__){eval(`module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/index.js?`)},"./node_modules/axios/lib/adapters/xhr.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/adapters/xhr.js?`)},"./node_modules/axios/lib/axios.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/axios.js?`)},"./node_modules/axios/lib/cancel/Cancel.js":function(module,exports,__webpack_require__){eval(`

/**
 * A \`Cancel\` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/cancel/Cancel.js?`)},"./node_modules/axios/lib/cancel/CancelToken.js":function(module,exports,__webpack_require__){eval(`

var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A \`CancelToken\` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a \`Cancel\` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new \`CancelToken\` and a function that, when called,
 * cancels the \`CancelToken\`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/cancel/CancelToken.js?`)},"./node_modules/axios/lib/cancel/isCancel.js":function(module,exports,__webpack_require__){eval(`

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/cancel/isCancel.js?`)},"./node_modules/axios/lib/core/Axios.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/Axios.js?`)},"./node_modules/axios/lib/core/InterceptorManager.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle \`then\` for a \`Promise\`
 * @param {Function} rejected The function to handle \`reject\` for a \`Promise\`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by \`use\`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become \`null\` calling \`eject\`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/InterceptorManager.js?`)},"./node_modules/axios/lib/core/buildFullPath.js":function(module,exports,__webpack_require__){eval(`

var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/buildFullPath.js?`)},"./node_modules/axios/lib/core/createError.js":function(module,exports,__webpack_require__){eval(`

var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/createError.js?`)},"./node_modules/axios/lib/core/dispatchRequest.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a \`Cancel\` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/dispatchRequest.js?`)},"./node_modules/axios/lib/core/enhanceError.js":function(module,exports,__webpack_require__){eval(`

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/enhanceError.js?`)},"./node_modules/axios/lib/core/mergeConfig.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/mergeConfig.js?`)},"./node_modules/axios/lib/core/settle.js":function(module,exports,__webpack_require__){eval(`

var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/settle.js?`)},"./node_modules/axios/lib/core/transformData.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/core/transformData.js?`)},"./node_modules/axios/lib/defaults.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/defaults.js?`)},"./node_modules/axios/lib/helpers/bind.js":function(module,exports,__webpack_require__){eval(`

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/bind.js?`)},"./node_modules/axios/lib/helpers/buildURL.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/buildURL.js?`)},"./node_modules/axios/lib/helpers/combineURLs.js":function(module,exports,__webpack_require__){eval(`

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')
    : baseURL;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/combineURLs.js?`)},"./node_modules/axios/lib/helpers/cookies.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/cookies.js?`)},"./node_modules/axios/lib/helpers/isAbsoluteURL.js":function(module,exports,__webpack_require__){eval(`

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/isAbsoluteURL.js?`)},"./node_modules/axios/lib/helpers/isAxiosError.js":function(module,exports,__webpack_require__){eval(`

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/isAxiosError.js?`)},"./node_modules/axios/lib/helpers/isURLSameOrigin.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/isURLSameOrigin.js?`)},"./node_modules/axios/lib/helpers/normalizeHeaderName.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/normalizeHeaderName.js?`)},"./node_modules/axios/lib/helpers/parseHeaders.js":function(module,exports,__webpack_require__){eval(`

var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * \`\`\`
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * \`\`\`
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/parseHeaders.js?`)},"./node_modules/axios/lib/helpers/spread.js":function(module,exports,__webpack_require__){eval(`

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use \`Function.prototype.apply\`.
 *
 *  \`\`\`js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  \`\`\`
 *
 * With \`spread\` this example can be re-written.
 *
 *  \`\`\`js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  \`\`\`
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/helpers/spread.js?`)},"./node_modules/axios/lib/utils.js":function(module,exports,__webpack_require__){eval(`

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If \`obj\` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * \`\`\`js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * \`\`\`
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/axios/lib/utils.js?`)},"./node_modules/base64-js/index.js":function(module,exports,__webpack_require__){eval(`

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/base64-js/index.js?`)},"./node_modules/buffer/index.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If \`Buffer.TYPED_ARRAY_SUPPORT\`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to \`Uint8Array\` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the \`TypedArray.prototype.subarray\` function.
 *
 *   - IE10 has a broken \`TypedArray.prototype.subarray\` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set \`Buffer.TYPED_ARRAY_SUPPORT\` to \`false\` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack \`subarray\`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken \`subarray\`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of \`Uint8Array\` that have their
 * prototype changed to \`Buffer.prototype\`. Furthermore, \`Buffer\` is a subclass of
 * \`Uint8Array\`, so the returned instances will have all the node \`Buffer\` methods
 * and the \`Uint8Array\` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The \`Uint8Array\` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if \`array\` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\\'offset\\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\\'length\\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use \`length < kMaxLength()\` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by \`Buffer.isBuffer\` and \`is-buffer\` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of \`val\` in \`buffer\` at offset >= \`byteOffset\`,
// OR the last index of \`val\` in \`buffer\` at offset <= \`byteOffset\`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into \`buffer\`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\\s+|\\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/buffer/index.js?`)},"./node_modules/dompurify/dist/purify.js":function(module,exports,__webpack_require__){eval(`/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.0.8/LICENSE */

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, function () { 'use strict';

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      objectKeys = Object.keys;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayIndexOf = unapply(Array.prototype.indexOf);
  var arrayJoin = unapply(Array.prototype.join);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var arraySlice = unapply(Array.prototype.slice);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);
  var regExpCreate = unconstruct(RegExp);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create(null);

    var property = void 0;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  var text = freeze(['#text']);

  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex
  );

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.0.17';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;
    var removeTitle = false;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        Text = window.Text,
        Comment = window.Comment,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.

    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        getElementsByTagName = _document.getElementsByTagName,
        createDocumentFragment = _document.createDocumentFragment;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for jQuery's $() factory? */
    var SAFE_FOR_JQUERY = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM \`HTMLBodyElement\` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If \`WHOLE_DOCUMENT\` is enabled a \`HTMLHtmlElement\` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM \`DocumentFragment\` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* If \`RETURN_DOM\` or \`RETURN_DOM_FRAGMENT\` is enabled, decide if the returned DOM
     * \`Node\` is imported into the current \`Document\`. If this flag is not enabled the
     * \`Node\` will belong (its ownerDocument) to a fresh \`HTMLDocument\`, created by
     * DOMPurify. */
    var RETURN_DOM_IMPORT = false;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a \`Node\` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html);
          addToSet(ALLOWED_ATTR, html$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        node.parentNode.removeChild(node);
      } catch (_) {
        node.outerHTML = emptyHTML;
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /* Use the DOMParser API by default, fallback later if needs be */
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
      } catch (_) {}

      /* Remove title to fix a mXSS bug in older MS Edge */
      if (removeTitle) {
        addToSet(FORBID_TAGS, ['title']);
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createHTMLDocument('');
        var _doc = doc,
            body = _doc.body;

        body.parentNode.removeChild(body.parentNode.firstElementChild);
        body.outerHTML = dirtyPayload;
      }

      if (dirty && leadingWhitespace) {
        doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    };

    /* Here we test for a broken feature in Edge that might cause mXSS */
    if (DOMPurify.isSupported) {
      (function () {
        try {
          var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');
          if (regExpTest(/<\\/title/, doc.querySelector('title').innerHTML)) {
            removeTitle = true;
          }
        } catch (_) {}
      })();
    }

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
        return NodeFilter.FILTER_ACCEPT;
      }, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false;
      }

      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string') {
        return true;
      }

      return false;
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    // eslint-disable-next-line complexity
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = stringToLowerCase(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Take care of an mXSS pattern using p, br inside svg, math */
      if ((tagName === 'svg' || tagName === 'math') && currentNode.querySelectorAll('p, br, form, table').length !== 0) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {
          try {
            var htmlToInsert = currentNode.innerHTML;
            currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);
          } catch (_) {}
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Remove in case a noscript/noembed XSS is suspected */
      if (tagName === 'noscript' && regExpTest(/<\\/noscript/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      if (tagName === 'noembed' && regExpTest(/<\\/noembed/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Convert markup to cover jQuery behavior */
      if (SAFE_FOR_JQUERY && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/</g, currentNode.textContent)) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        if (currentNode.innerHTML) {
          currentNode.innerHTML = stringReplace(currentNode.innerHTML, /</g, '&lt;');
        } else {
          currentNode.innerHTML = stringReplace(currentNode.textContent, /</g, '&lt;');
        }
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if \`value\` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        return false;

        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    // eslint-disable-next-line complexity
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var idAttr = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim(attr.value);
        lcName = stringToLowerCase(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
        // remove a "name" attribute from an <img> tag that has an "id"
        // attribute at the time.
        if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {
          idAttr = attributes.id;
          attributes = arraySlice(attributes, []);
          _removeAttribute('id', currentNode);
          _removeAttribute(name, currentNode);
          if (arrayIndexOf(attributes, idAttr) > l) {
            currentNode.setAttribute('id', idAttr.value);
          }
        } else if (
        // This works around a bug in Safari, where input[type=file]
        // cannot be dynamically set after type has been removed
        currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
          continue;
        } else {
          // This avoids a crash in Safari v9.0 with double-ids.
          // The trick is to first set the id to be empty and then to
          // remove the attribute
          if (name === 'id') {
            currentNode.setAttribute(name, '');
          }

          _removeAttribute(name, currentNode);
        }

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (SAFE_FOR_JQUERY && regExpTest(/\\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Take care of an mXSS pattern using namespace switches */
        if (regExpTest(/svg|math/i, currentNode.namespaceURI) && regExpTest(regExpCreate('</(' + arrayJoin(objectKeys(FORBID_CONTENTS), '|') + ')', 'i'), value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is \`value\` valid for this attribute? */
        var lcTag = currentNode.nodeName.toLowerCase();
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      if (!dirty) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) ; else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!-->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : emptyHTML;
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized \`dirty\` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (RETURN_DOM_IMPORT) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if \`value\` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = stringToLowerCase(tag);
      var lcName = stringToLowerCase(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
//# sourceMappingURL=purify.js.map


//# sourceURL=webpack://%5Bname%5D/./node_modules/dompurify/dist/purify.js?`)},"./node_modules/esprima/dist/esprima.js":function(module,exports,__webpack_require__){eval(`(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  \`function a() {/** comments **\\/}\`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // \`
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\\r' && this.scanner.source[this.scanner.index] === '\\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements  AssignmentTargets  AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with \`new\`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \\'use strict\\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \\'%1\\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \\'%0\\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // \`<!--\`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \\0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\\n';
	                            break;
	                        case 'r':
	                            str += '\\r';
	                            break;
	                        case 't':
	                            str += '\\t';
	                            break;
	                        case 'b':
	                            str += '\\b';
	                            break;
	                        case 'f':
	                            str += '\\f';
	                            break;
	                        case 'v':
	                            str += '\\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\\r' && this.source[this.index] === '\\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '\`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '\`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('\${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\\n';
	                            break;
	                        case 'r':
	                            cooked += '\\r';
	                            break;
	                        case 't':
	                            cooked += '\\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\\b';
	                            break;
	                        case 'f':
	                            cooked += '\\f';
	                            break;
	                        case 'v':
	                            cooked += '\\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \\01 \\02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \\1 \\2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\\r' && this.source[this.index] === '\\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\\r' && this.source[this.index] === '\\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\\uFFFF' enables false positives in unlikely
	        // scenarios. For example, \`[\\u{1044f}-\\u{10440}]\` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // \`null\` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with \` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '\${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\\u0022',
	    amp: '\\u0026',
	    apos: '\\u0027',
	    gt: '\\u003E',
	    nbsp: '\\u00A0',
	    iexcl: '\\u00A1',
	    cent: '\\u00A2',
	    pound: '\\u00A3',
	    curren: '\\u00A4',
	    yen: '\\u00A5',
	    brvbar: '\\u00A6',
	    sect: '\\u00A7',
	    uml: '\\u00A8',
	    copy: '\\u00A9',
	    ordf: '\\u00AA',
	    laquo: '\\u00AB',
	    not: '\\u00AC',
	    shy: '\\u00AD',
	    reg: '\\u00AE',
	    macr: '\\u00AF',
	    deg: '\\u00B0',
	    plusmn: '\\u00B1',
	    sup2: '\\u00B2',
	    sup3: '\\u00B3',
	    acute: '\\u00B4',
	    micro: '\\u00B5',
	    para: '\\u00B6',
	    middot: '\\u00B7',
	    cedil: '\\u00B8',
	    sup1: '\\u00B9',
	    ordm: '\\u00BA',
	    raquo: '\\u00BB',
	    frac14: '\\u00BC',
	    frac12: '\\u00BD',
	    frac34: '\\u00BE',
	    iquest: '\\u00BF',
	    Agrave: '\\u00C0',
	    Aacute: '\\u00C1',
	    Acirc: '\\u00C2',
	    Atilde: '\\u00C3',
	    Auml: '\\u00C4',
	    Aring: '\\u00C5',
	    AElig: '\\u00C6',
	    Ccedil: '\\u00C7',
	    Egrave: '\\u00C8',
	    Eacute: '\\u00C9',
	    Ecirc: '\\u00CA',
	    Euml: '\\u00CB',
	    Igrave: '\\u00CC',
	    Iacute: '\\u00CD',
	    Icirc: '\\u00CE',
	    Iuml: '\\u00CF',
	    ETH: '\\u00D0',
	    Ntilde: '\\u00D1',
	    Ograve: '\\u00D2',
	    Oacute: '\\u00D3',
	    Ocirc: '\\u00D4',
	    Otilde: '\\u00D5',
	    Ouml: '\\u00D6',
	    times: '\\u00D7',
	    Oslash: '\\u00D8',
	    Ugrave: '\\u00D9',
	    Uacute: '\\u00DA',
	    Ucirc: '\\u00DB',
	    Uuml: '\\u00DC',
	    Yacute: '\\u00DD',
	    THORN: '\\u00DE',
	    szlig: '\\u00DF',
	    agrave: '\\u00E0',
	    aacute: '\\u00E1',
	    acirc: '\\u00E2',
	    atilde: '\\u00E3',
	    auml: '\\u00E4',
	    aring: '\\u00E5',
	    aelig: '\\u00E6',
	    ccedil: '\\u00E7',
	    egrave: '\\u00E8',
	    eacute: '\\u00E9',
	    ecirc: '\\u00EA',
	    euml: '\\u00EB',
	    igrave: '\\u00EC',
	    iacute: '\\u00ED',
	    icirc: '\\u00EE',
	    iuml: '\\u00EF',
	    eth: '\\u00F0',
	    ntilde: '\\u00F1',
	    ograve: '\\u00F2',
	    oacute: '\\u00F3',
	    ocirc: '\\u00F4',
	    otilde: '\\u00F5',
	    ouml: '\\u00F6',
	    divide: '\\u00F7',
	    oslash: '\\u00F8',
	    ugrave: '\\u00F9',
	    uacute: '\\u00FA',
	    ucirc: '\\u00FB',
	    uuml: '\\u00FC',
	    yacute: '\\u00FD',
	    thorn: '\\u00FE',
	    yuml: '\\u00FF',
	    OElig: '\\u0152',
	    oelig: '\\u0153',
	    Scaron: '\\u0160',
	    scaron: '\\u0161',
	    Yuml: '\\u0178',
	    fnof: '\\u0192',
	    circ: '\\u02C6',
	    tilde: '\\u02DC',
	    Alpha: '\\u0391',
	    Beta: '\\u0392',
	    Gamma: '\\u0393',
	    Delta: '\\u0394',
	    Epsilon: '\\u0395',
	    Zeta: '\\u0396',
	    Eta: '\\u0397',
	    Theta: '\\u0398',
	    Iota: '\\u0399',
	    Kappa: '\\u039A',
	    Lambda: '\\u039B',
	    Mu: '\\u039C',
	    Nu: '\\u039D',
	    Xi: '\\u039E',
	    Omicron: '\\u039F',
	    Pi: '\\u03A0',
	    Rho: '\\u03A1',
	    Sigma: '\\u03A3',
	    Tau: '\\u03A4',
	    Upsilon: '\\u03A5',
	    Phi: '\\u03A6',
	    Chi: '\\u03A7',
	    Psi: '\\u03A8',
	    Omega: '\\u03A9',
	    alpha: '\\u03B1',
	    beta: '\\u03B2',
	    gamma: '\\u03B3',
	    delta: '\\u03B4',
	    epsilon: '\\u03B5',
	    zeta: '\\u03B6',
	    eta: '\\u03B7',
	    theta: '\\u03B8',
	    iota: '\\u03B9',
	    kappa: '\\u03BA',
	    lambda: '\\u03BB',
	    mu: '\\u03BC',
	    nu: '\\u03BD',
	    xi: '\\u03BE',
	    omicron: '\\u03BF',
	    pi: '\\u03C0',
	    rho: '\\u03C1',
	    sigmaf: '\\u03C2',
	    sigma: '\\u03C3',
	    tau: '\\u03C4',
	    upsilon: '\\u03C5',
	    phi: '\\u03C6',
	    chi: '\\u03C7',
	    psi: '\\u03C8',
	    omega: '\\u03C9',
	    thetasym: '\\u03D1',
	    upsih: '\\u03D2',
	    piv: '\\u03D6',
	    ensp: '\\u2002',
	    emsp: '\\u2003',
	    thinsp: '\\u2009',
	    zwnj: '\\u200C',
	    zwj: '\\u200D',
	    lrm: '\\u200E',
	    rlm: '\\u200F',
	    ndash: '\\u2013',
	    mdash: '\\u2014',
	    lsquo: '\\u2018',
	    rsquo: '\\u2019',
	    sbquo: '\\u201A',
	    ldquo: '\\u201C',
	    rdquo: '\\u201D',
	    bdquo: '\\u201E',
	    dagger: '\\u2020',
	    Dagger: '\\u2021',
	    bull: '\\u2022',
	    hellip: '\\u2026',
	    permil: '\\u2030',
	    prime: '\\u2032',
	    Prime: '\\u2033',
	    lsaquo: '\\u2039',
	    rsaquo: '\\u203A',
	    oline: '\\u203E',
	    frasl: '\\u2044',
	    euro: '\\u20AC',
	    image: '\\u2111',
	    weierp: '\\u2118',
	    real: '\\u211C',
	    trade: '\\u2122',
	    alefsym: '\\u2135',
	    larr: '\\u2190',
	    uarr: '\\u2191',
	    rarr: '\\u2192',
	    darr: '\\u2193',
	    harr: '\\u2194',
	    crarr: '\\u21B5',
	    lArr: '\\u21D0',
	    uArr: '\\u21D1',
	    rArr: '\\u21D2',
	    dArr: '\\u21D3',
	    hArr: '\\u21D4',
	    forall: '\\u2200',
	    part: '\\u2202',
	    exist: '\\u2203',
	    empty: '\\u2205',
	    nabla: '\\u2207',
	    isin: '\\u2208',
	    notin: '\\u2209',
	    ni: '\\u220B',
	    prod: '\\u220F',
	    sum: '\\u2211',
	    minus: '\\u2212',
	    lowast: '\\u2217',
	    radic: '\\u221A',
	    prop: '\\u221D',
	    infin: '\\u221E',
	    ang: '\\u2220',
	    and: '\\u2227',
	    or: '\\u2228',
	    cap: '\\u2229',
	    cup: '\\u222A',
	    int: '\\u222B',
	    there4: '\\u2234',
	    sim: '\\u223C',
	    cong: '\\u2245',
	    asymp: '\\u2248',
	    ne: '\\u2260',
	    equiv: '\\u2261',
	    le: '\\u2264',
	    ge: '\\u2265',
	    sub: '\\u2282',
	    sup: '\\u2283',
	    nsub: '\\u2284',
	    sube: '\\u2286',
	    supe: '\\u2287',
	    oplus: '\\u2295',
	    otimes: '\\u2297',
	    perp: '\\u22A5',
	    sdot: '\\u22C5',
	    lceil: '\\u2308',
	    rceil: '\\u2309',
	    lfloor: '\\u230A',
	    rfloor: '\\u230B',
	    loz: '\\u25CA',
	    spades: '\\u2660',
	    clubs: '\\u2663',
	    hearts: '\\u2665',
	    diams: '\\u2666',
	    lang: '\\u27E8',
	    rang: '\\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;

//# sourceURL=webpack://%5Bname%5D/./node_modules/esprima/dist/esprima.js?`)},"./node_modules/events/events.js":function(module,exports,__webpack_require__){eval(`// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the \`throw\` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign \`events\` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/events/events.js?`)},"./node_modules/fast-deep-equal/index.js":function(module,exports,__webpack_require__){eval(`

// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/fast-deep-equal/index.js?`)},"./node_modules/fast-json-stable-stringify/index.js":function(module,exports,__webpack_require__){eval(`

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/fast-json-stable-stringify/index.js?`)},"./node_modules/file-saver/FileSaver.js":function(module,exports,__webpack_require__){eval(`var __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// \`self\` is undefined in Firefox for Android content script context
// while \`this\` is nsIContentFrameMessageManager
// with an attribute \`content\` that corresponds to the window

if ( true && module.exports) {
  module.exports.saveAs = saveAs;
} else if (( true && __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") !== null) && (__webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") !== null)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return saveAs;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/file-saver/FileSaver.js?`)},"./node_modules/ieee754/index.js":function(module,exports){eval(`exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/ieee754/index.js?`)},"./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js":function(module,exports,__webpack_require__){eval(`(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/socketIOMain.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js":
/*!***********************************************************************************!*\\
  !*** ./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!
  \\***********************************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/*
 * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
var encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
var decode = function (base64) {
    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};


//# sourceMappingURL=base64-arraybuffer.es5.js.map


/***/ }),

/***/ "./node_modules/@socket.io/component-emitter/index.js":
/*!************************************************************!*\\
  !*** ./node_modules/@socket.io/component-emitter/index.js ***!
  \\************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose \`Emitter\`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new \`Emitter\`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given \`event\` with \`fn\`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an \`event\` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for \`event\` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit \`event\` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for \`event\`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has \`event\` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\\
  !*** ./node_modules/backo2/index.js ***!
  \\**************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose \`Backoff\`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with \`opts\`.
 *
 * - \`min\` initial timeout in milliseconds [100]
 * - \`max\` max timeout [10000]
 * - \`jitter\` [0]
 * - \`factor\` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\\
  !*** ./node_modules/base64-js/index.js ***!
  \\*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\\
  !*** ./node_modules/buffer/index.js ***!
  \\**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If \`Buffer.TYPED_ARRAY_SUPPORT\`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to \`Uint8Array\` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the \`TypedArray.prototype.subarray\` function.
 *
 *   - IE10 has a broken \`TypedArray.prototype.subarray\` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set \`Buffer.TYPED_ARRAY_SUPPORT\` to \`false\` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack \`subarray\`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken \`subarray\`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of \`Uint8Array\` that have their
 * prototype changed to \`Buffer.prototype\`. Furthermore, \`Buffer\` is a subclass of
 * \`Uint8Array\`, so the returned instances will have all the node \`Buffer\` methods
 * and the \`Uint8Array\` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The \`Uint8Array\` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if \`array\` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\\'offset\\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\\'length\\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use \`length < kMaxLength()\` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by \`Buffer.isBuffer\` and \`is-buffer\` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of \`val\` in \`buffer\` at offset >= \`byteOffset\`,
// OR the last index of \`val\` in \`buffer\` at offset <= \`byteOffset\`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into \`buffer\`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\\s+|\\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/globalThis.browser.js":
/*!***********************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/globalThis.browser.js ***!
  \\***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ((() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})());


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/index.js":
/*!**********************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/index.js ***!
  \\**********************************************************/
/*! exports provided: Socket, protocol, Transport, transports, installTimerFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return protocol; });
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./socket.js */ "./node_modules/engine.io-client/build/esm/socket.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return _socket_js__WEBPACK_IMPORTED_MODULE_0__["Socket"]; });

/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transport.js */ "./node_modules/engine.io-client/build/esm/transport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transport", function() { return _transport_js__WEBPACK_IMPORTED_MODULE_1__["Transport"]; });

/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transports/index.js */ "./node_modules/engine.io-client/build/esm/transports/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transports", function() { return _transports_index_js__WEBPACK_IMPORTED_MODULE_2__["transports"]; });

/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "installTimerFunctions", function() { return _util_js__WEBPACK_IMPORTED_MODULE_3__["installTimerFunctions"]; });



const protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__["Socket"].protocol;





/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/socket.js":
/*!***********************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/socket.js ***!
  \\***********************************************************/
/*! exports provided: Socket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return Socket; });
/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transports/index.js */ "./node_modules/engine.io-client/build/esm/transports/index.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(parseqs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(parseuri__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");






class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__["Emitter"] {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri or options
     * @param {Object} opts - options
     * @api public
     */
    constructor(uri, opts = {}) {
        super();
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            uri = parseuri__WEBPACK_IMPORTED_MODULE_3___default()(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol === "https" || uri.protocol === "wss";
            opts.port = uri.port;
            if (uri.query)
                opts.query = uri.query;
        }
        else if (opts.host) {
            opts.hostname = parseuri__WEBPACK_IMPORTED_MODULE_3___default()(opts.host).host;
        }
        Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["installTimerFunctions"])(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
            opts.port ||
                (typeof location !== "undefined" && location.port
                    ? location.port
                    : this.secure
                        ? "443"
                        : "80");
        this.transports = opts.transports || ["polling", "websocket"];
        this.readyState = "";
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: true
        }, opts);
        this.opts.path = this.opts.path.replace(/\\/$/, "") + "/";
        if (typeof this.opts.query === "string") {
            this.opts.query = parseqs__WEBPACK_IMPORTED_MODULE_2___default.a.decode(this.opts.query);
        }
        // set on handshake
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        // set on heartbeat
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                addEventListener("beforeunload", () => {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                }, false);
            }
            if (this.hostname !== "localhost") {
                this.offlineEventListener = () => {
                    this.onClose("transport close");
                };
                addEventListener("offline", this.offlineEventListener, false);
            }
        }
        this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} transport name
     * @return {Transport}
     * @api private
     */
    createTransport(name) {
        const query = clone(this.opts.query);
        // append engine.io protocol identifier
        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__["protocol"];
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
        });
        return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__["transports"][name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @api private
     */
    open() {
        let transport;
        if (this.opts.rememberUpgrade &&
            Socket.priorWebsocketSuccess &&
            this.transports.indexOf("websocket") !== -1) {
            transport = "websocket";
        }
        else if (0 === this.transports.length) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        else {
            transport = this.transports[0];
        }
        this.readyState = "opening";
        // Retry with the next transport if the transport is disabled (jsonp: false)
        try {
            transport = this.createTransport(transport);
        }
        catch (e) {
            this.transports.shift();
            this.open();
            return;
        }
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @api private
     */
    setTransport(transport) {
        if (this.transport) {
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on("drain", this.onDrain.bind(this))
            .on("packet", this.onPacket.bind(this))
            .on("error", this.onError.bind(this))
            .on("close", () => {
            this.onClose("transport close");
        });
    }
    /**
     * Probes a transport.
     *
     * @param {String} transport name
     * @api private
     */
    probe(name) {
        let transport = this.createTransport(name);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
            if (failed)
                return;
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", msg => {
                if (failed)
                    return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport)
                        return;
                    Socket.priorWebsocketSuccess = "websocket" === transport.name;
                    this.transport.pause(() => {
                        if (failed)
                            return;
                        if ("closed" === this.readyState)
                            return;
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: "upgrade" }]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = err => {
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
    }
    /**
     * Called when connection is deemed open.
     *
     * @api private
     */
    onOpen() {
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
        // we check for \`readyState\` in case an \`open\`
        // listener already closed the socket
        if ("open" === this.readyState &&
            this.opts.upgrade &&
            this.transport.pause) {
            let i = 0;
            const l = this.upgrades.length;
            for (; i < l; i++) {
                this.probe(this.upgrades[i]);
            }
        }
    }
    /**
     * Handles a packet.
     *
     * @api private
     */
    onPacket(packet) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            switch (packet.type) {
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this.resetPingTimeout();
                    this.sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this.onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
        else {
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @api private
     */
    onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState)
            return;
        this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @api private
     */
    resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
            this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
            this.pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on \`drain\` event
     *
     * @api private
     */
    onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on \`drain\`
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @api private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length) {
            this.transport.send(this.writeBuffer);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on \`drain\`
            this.prevBufferLen = this.writeBuffer.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Sends a message.
     *
     * @param {String} message.
     * @param {Function} callback function.
     * @param {Object} options.
     * @return {Socket} for chaining.
     * @api public
     */
    write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} callback function.
     * @api private
     */
    sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     *
     * @api public
     */
    close() {
        const close = () => {
            this.onClose("forced close");
            this.transport.close();
        };
        const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = () => {
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", () => {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @api private
     */
    onError(err) {
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @api private
     */
    onClose(reason, desc) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            // clear timers
            this.clearTimeoutFn(this.pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (typeof removeEventListener === "function") {
                removeEventListener("offline", this.offlineEventListener, false);
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, desc);
            // clean buffers after, so users can still
            // grab the buffers on \`close\` event
            this.writeBuffer = [];
            this.prevBufferLen = 0;
        }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} server upgrades
     * @api private
     *
     */
    filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
Socket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__["protocol"];
function clone(obj) {
    const o = {};
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            o[i] = obj[i];
        }
    }
    return o;
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transport.js":
/*!**************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transport.js ***!
  \\**************************************************************/
/*! exports provided: Transport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transport", function() { return Transport; });
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/engine.io-client/build/esm/util.js");



class Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__["Emitter"] {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */
    constructor(opts) {
        super();
        this.writable = false;
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["installTimerFunctions"])(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.readyState = "";
        this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} str
     * @return {Transport} for chaining
     * @api protected
     */
    onError(msg, desc) {
        const err = new Error(msg);
        // @ts-ignore
        err.type = "TransportError";
        // @ts-ignore
        err.description = desc;
        super.emit("error", err);
        return this;
    }
    /**
     * Opens the transport.
     *
     * @api public
     */
    open() {
        if ("closed" === this.readyState || "" === this.readyState) {
            this.readyState = "opening";
            this.doOpen();
        }
        return this;
    }
    /**
     * Closes the transport.
     *
     * @api public
     */
    close() {
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api public
     */
    send(packets) {
        if ("open" === this.readyState) {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
        }
    }
    /**
     * Called upon open
     *
     * @api protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emit("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @api protected
     */
    onData(data) {
        const packet = Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_0__["decodePacket"])(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @api protected
     */
    onPacket(packet) {
        super.emit("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @api protected
     */
    onClose() {
        this.readyState = "closed";
        super.emit("close");
    }
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/index.js":
/*!*********************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/index.js ***!
  \\*********************************************************************/
/*! exports provided: transports */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transports", function() { return transports; });
/* harmony import */ var _polling_xhr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling-xhr.js */ "./node_modules/engine.io-client/build/esm/transports/polling-xhr.js");
/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket.js */ "./node_modules/engine.io-client/build/esm/transports/websocket.js");


const transports = {
    websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__["WS"],
    polling: _polling_xhr_js__WEBPACK_IMPORTED_MODULE_0__["XHR"]
};


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/polling-xhr.js":
/*!***************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/polling-xhr.js ***!
  \\***************************************************************************/
/*! exports provided: XHR, Request */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHR", function() { return XHR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony import */ var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xmlhttprequest.js */ "./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js");
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polling.js */ "./node_modules/engine.io-client/build/esm/transports/polling.js");
/* global attachEvent */





/**
 * Empty function
 */
function empty() { }
const hasXHR2 = (function () {
    const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
        xdomain: false
    });
    return null != xhr.responseType;
})();
class XHR extends _polling_js__WEBPACK_IMPORTED_MODULE_4__["Polling"] {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @api public
     */
    constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty \`location.port\`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
            this.xs = opts.secure !== isSSL;
        }
        /**
         * XHR supports binary
         */
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @api private
     */
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @api private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data
        });
        req.on("success", fn);
        req.on("error", err => {
            this.onError("xhr post error", err);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @api private
     */
    doPoll() {
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", err => {
            this.onError("xhr poll error", err);
        });
        this.pollXhr = req;
    }
}
class Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_3__["Emitter"] {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @api public
     */
    constructor(uri, opts) {
        super();
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["installTimerFunctions"])(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = false !== opts.async;
        this.data = undefined !== opts.data ? opts.data : null;
        this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @api private
     */
    create() {
        const opts = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["pick"])(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        const xhr = (this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_0__["default"](opts));
        try {
            xhr.open(this.method, this.uri, this.async);
            try {
                if (this.opts.extraHeaders) {
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this.opts.extraHeaders) {
                        if (this.opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this.method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this.opts.withCredentials;
            }
            if (this.opts.requestTimeout) {
                xhr.timeout = this.opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this.onLoad();
                }
                else {
                    // make sure the \`error\` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            xhr.send(this.data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this.onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
        }
    }
    /**
     * Called upon successful response.
     *
     * @api private
     */
    onSuccess() {
        this.emit("success");
        this.cleanup();
    }
    /**
     * Called if we have data.
     *
     * @api private
     */
    onData(data) {
        this.emit("data", data);
        this.onSuccess();
    }
    /**
     * Called upon error.
     *
     * @api private
     */
    onError(err) {
        this.emit("error", err);
        this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @api private
     */
    cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
            return;
        }
        this.xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this.xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this.index];
        }
        this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @api private
     */
    onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
            this.onData(data);
        }
    }
    /**
     * Aborts the request.
     *
     * @api public
     */
    abort() {
        this.cleanup();
    }
}
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in _globalThis_js__WEBPACK_IMPORTED_MODULE_1__["default"] ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/polling.js":
/*!***********************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/polling.js ***!
  \\***********************************************************************/
/*! exports provided: Polling */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polling", function() { return Polling; });
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ "./node_modules/engine.io-client/build/esm/transport.js");
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(yeast__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(parseqs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");




class Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__["Transport"] {
    constructor() {
        super(...arguments);
        this.polling = false;
    }
    /**
     * Transport name.
     */
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */
    doOpen() {
        this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            this.readyState = "paused";
            onPause();
        };
        if (this.polling || !this.writable) {
            let total = 0;
            if (this.polling) {
                total++;
                this.once("pollComplete", function () {
                    --total || pause();
                });
            }
            if (!this.writable) {
                total++;
                this.once("drain", function () {
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @api public
     */
    poll() {
        this.polling = true;
        this.doPoll();
        this.emit("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @api private
     */
    onData(data) {
        const callback = packet => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose();
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__["decodePayload"])(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this.polling = false;
            this.emit("pollComplete");
            if ("open" === this.readyState) {
                this.poll();
            }
            else {
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @api private
     */
    doClose() {
        const close = () => {
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */
    write(packets) {
        this.writable = false;
        Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__["encodePayload"])(packets, data => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emit("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */
    uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = yeast__WEBPACK_IMPORTED_MODULE_1___default()();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        // avoid port if default for schema
        if (this.opts.port &&
            (("https" === schema && Number(this.opts.port) !== 443) ||
                ("http" === schema && Number(this.opts.port) !== 80))) {
            port = ":" + this.opts.port;
        }
        const encodedQuery = parseqs__WEBPACK_IMPORTED_MODULE_2___default.a.encode(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (schema +
            "://" +
            (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
            port +
            this.opts.path +
            (encodedQuery.length ? "?" + encodedQuery : ""));
    }
}


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js":
/*!*********************************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js ***!
  \\*********************************************************************************************/
/*! exports provided: nextTick, WebSocket, usingBrowserWebSocket, defaultBinaryType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextTick", function() { return nextTick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocket", function() { return WebSocket; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "usingBrowserWebSocket", function() { return usingBrowserWebSocket; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultBinaryType", function() { return defaultBinaryType; });
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");

const nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return cb => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
const WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"].WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"].MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/websocket.js":
/*!*************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/websocket.js ***!
  \\*************************************************************************/
/*! exports provided: WS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WS", function() { return WS; });
/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ "./node_modules/engine.io-client/build/esm/transport.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
/* harmony import */ var parseqs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(parseqs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
/* harmony import */ var yeast__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(yeast__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./node_modules/engine.io-client/build/esm/util.js");
/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./websocket-constructor.js */ "./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js");
/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/esm/index.js");






// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__["Transport"] {
    /**
     * WebSocket transport constructor.
     *
     * @api {Object} connection options
     * @api public
     */
    constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Transport name.
     *
     * @api public
     */
    get name() {
        return "websocket";
    }
    /**
     * Opens socket.
     *
     * @api private
     */
    doOpen() {
        if (!this.check()) {
            // let probe timeout
            return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : Object(_util_js__WEBPACK_IMPORTED_MODULE_3__["pick"])(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws =
                _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["usingBrowserWebSocket"] && !isReactNative
                    ? protocols
                        ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"](uri, protocols)
                        : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"](uri)
                    : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"](uri, protocols, opts);
        }
        catch (err) {
            return this.emit("error", err);
        }
        this.ws.binaryType = this.socket.binaryType || _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["defaultBinaryType"];
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @api private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = this.onClose.bind(this);
        this.ws.onmessage = ev => this.onData(ev.data);
        this.ws.onerror = e => this.onError("websocket error", e);
    }
    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_5__["encodePacket"])(packet, this.supportsBinary, data => {
                // always create a new object (GH-437)
                const opts = {};
                if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["usingBrowserWebSocket"]) {
                    if (packet.options) {
                        opts.compress = packet.options.compress;
                    }
                    if (this.opts.perMessageDeflate) {
                        const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
                        if (len < this.opts.perMessageDeflate.threshold) {
                            opts.compress = false;
                        }
                    }
                }
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["usingBrowserWebSocket"]) {
                        // TypeError is thrown when passing the second argument on Safari
                        this.ws.send(data);
                    }
                    else {
                        this.ws.send(data, opts);
                    }
                }
                catch (e) {
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    Object(_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["nextTick"])(() => {
                        this.writable = true;
                        this.emit("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    /**
     * Closes socket.
     *
     * @api private
     */
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */
    uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";
        // avoid port if default for schema
        if (this.opts.port &&
            (("wss" === schema && Number(this.opts.port) !== 443) ||
                ("ws" === schema && Number(this.opts.port) !== 80))) {
            port = ":" + this.opts.port;
        }
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = yeast__WEBPACK_IMPORTED_MODULE_2___default()();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        const encodedQuery = parseqs__WEBPACK_IMPORTED_MODULE_1___default.a.encode(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (schema +
            "://" +
            (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
            port +
            this.opts.path +
            (encodedQuery.length ? "?" + encodedQuery : ""));
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */
    check() {
        return (!!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"] &&
            !("__initialize" in _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__["WebSocket"] && this.name === WS.prototype.name));
    }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js":
/*!**************************************************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js ***!
  \\**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var has_cors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! has-cors */ "./node_modules/has-cors/index.js");
/* harmony import */ var has_cors__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(has_cors__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");
// browser shim for xmlhttprequest module


/* harmony default export */ __webpack_exports__["default"] = (function (opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors__WEBPACK_IMPORTED_MODULE_0___default.a)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__["default"][["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
});


/***/ }),

/***/ "./node_modules/engine.io-client/build/esm/util.js":
/*!*********************************************************!*\\
  !*** ./node_modules/engine.io-client/build/esm/util.js ***!
  \\*********************************************************/
/*! exports provided: pick, installTimerFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return pick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "installTimerFunctions", function() { return installTimerFunctions; });
/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globalThis.js */ "./node_modules/engine.io-client/build/esm/globalThis.browser.js");

function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = setTimeout;
const NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
    else {
        obj.setTimeoutFn = setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
        obj.clearTimeoutFn = clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
}


/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/commons.js":
/*!************************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/commons.js ***!
  \\************************************************************/
/*! exports provided: PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PACKET_TYPES", function() { return PACKET_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PACKET_TYPES_REVERSE", function() { return PACKET_TYPES_REVERSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR_PACKET", function() { return ERROR_PACKET; });
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach(key => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };



/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/decodePacket.browser.js":
/*!*************************************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/decodePacket.browser.js ***!
  \\*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/esm/commons.js");
/* harmony import */ var _socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/base64-arraybuffer */ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js");


const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType)
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
    }
    const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES_REVERSE"][type];
    if (!packetType) {
        return _commons_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_PACKET"];
    }
    return encodedPacket.length > 1
        ? {
            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES_REVERSE"][type],
            data: encodedPacket.substring(1)
        }
        : {
            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES_REVERSE"][type]
        };
};
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = Object(_socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__["decode"])(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
            return data; // assuming the data is already an ArrayBuffer
    }
};
/* harmony default export */ __webpack_exports__["default"] = (decodePacket);


/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/encodePacket.browser.js":
/*!*************************************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/encodePacket.browser.js ***!
  \\*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/esm/commons.js");

const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = obj => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__["PACKET_TYPES"][type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + content);
    };
    return fileReader.readAsDataURL(data);
};
/* harmony default export */ __webpack_exports__["default"] = (encodePacket);


/***/ }),

/***/ "./node_modules/engine.io-parser/build/esm/index.js":
/*!**********************************************************!*\\
  !*** ./node_modules/engine.io-parser/build/esm/index.js ***!
  \\**********************************************************/
/*! exports provided: protocol, encodePacket, encodePayload, decodePacket, decodePayload */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return protocol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodePayload", function() { return encodePayload; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePayload", function() { return decodePayload; });
/* harmony import */ var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encodePacket.js */ "./node_modules/engine.io-parser/build/esm/encodePacket.browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodePacket", function() { return _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decodePacket.js */ "./node_modules/engine.io-parser/build/esm/decodePacket.browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodePacket", function() { return _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });



const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        Object(_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__["default"])(packet, false, encodedPacket => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = Object(_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__["default"])(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
const protocol = 4;



/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\\
  !*** ./node_modules/has-cors/index.js ***!
  \\****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\\
  !*** ./node_modules/ieee754/index.js ***!
  \\***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\\
  !*** ./node_modules/isarray/index.js ***!
  \\***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\\
  !*** ./node_modules/parseqs/index.js ***!
  \\***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\\
  !*** ./node_modules/parseuri/index.js ***!
  \\****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/index.js":
/*!**********************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/index.js ***!
  \\**********************************************************/
/*! exports provided: protocol, Manager, Socket, io, connect, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return lookup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connect", function() { return lookup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lookup; });
/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.js */ "./node_modules/socket.io-client/build/esm/url.js");
/* harmony import */ var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./manager.js */ "./node_modules/socket.io-client/build/esm/manager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Manager", function() { return _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"]; });

/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./socket.js */ "./node_modules/socket.io-client/build/esm/socket.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return _socket_js__WEBPACK_IMPORTED_MODULE_2__["Socket"]; });

/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return socket_io_parser__WEBPACK_IMPORTED_MODULE_3__["protocol"]; });




/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = Object(_url_js__WEBPACK_IMPORTED_MODULE_0__["url"])(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"](source, opts);
    }
    else {
        if (!cache[id]) {
            cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"](source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. \`io(...)\`) and as a
// namespace (e.g. \`io.connect(...)\`), for backward compatibility
Object.assign(lookup, {
    Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__["Manager"],
    Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__["Socket"],
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */

/**
 * Expose constructors for standalone build.
 *
 * @public
 */



/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/manager.js":
/*!************************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/manager.js ***!
  \\************************************************************/
/*! exports provided: Manager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Manager", function() { return Manager; });
/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-client */ "./node_modules/engine.io-client/build/esm/index.js");
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./socket.js */ "./node_modules/socket.io-client/build/esm/socket.js");
/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./on.js */ "./node_modules/socket.io-client/build/esm/on.js");
/* harmony import */ var backo2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");
/* harmony import */ var backo2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(backo2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__);






class Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__["Emitter"] {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__["installTimerFunctions"])(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2__WEBPACK_IMPORTED_MODULE_4___default.a({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport \`socket\`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__["Socket"](this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit \`open\`
        const openSubDestroy = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        // emit \`error\`
        const errorSub = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "error", (err) => {
            self.cleanup();
            self._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                self.maybeReconnectOnOpen();
            }
        });
        if (false !== this._timeout) {
            const timeout = this._timeout;
            if (timeout === 0) {
                openSubDestroy(); // prevents a race condition with the 'open' event
            }
            // set timer
            const timer = this.setTimeoutFn(() => {
                openSubDestroy();
                socket.close();
                // @ts-ignore
                socket.emit("error", new Error("timeout"));
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(function subDestroy() {
                clearTimeout(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push(Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "ping", this.onping.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "data", this.ondata.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "error", this.onerror.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(socket, "close", this.onclose.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__["on"])(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        this.decoder.add(data);
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        this.emitReserved("packet", packet);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given \`nsp\`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__["Socket"](this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine)
            this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason) {
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(function subDestroy() {
                clearTimeout(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/on.js":
/*!*******************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/on.js ***!
  \\*******************************************************/
/*! exports provided: on */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/socket.js":
/*!***********************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/socket.js ***!
  \\***********************************************************/
/*! exports provided: Socket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Socket", function() { return Socket; });
/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./on.js */ "./node_modules/socket.io-client/build/esm/on.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__);



/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__["Emitter"] {
    /**
     * \`Socket\` constructor.
     *
     * @public
     */
    constructor(io, nsp, opts) {
        super();
        this.connected = false;
        this.disconnected = true;
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "open", this.onopen.bind(this)),
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "packet", this.onpacket.bind(this)),
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "error", this.onerror.bind(this)),
            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__["on"])(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @public
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for connect()
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a \`message\` event.
     *
     * @return self
     * @public
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override \`emit\`.
     * If the event is in \`events\`, it's emitted normally.
     *
     * @return self
     * @public
     */
    emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev + '" is a reserved event name');
        }
        args.unshift(ev);
        const packet = {
            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = this.io.engine &&
            this.io.engine.transport &&
            this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
        }
        else if (this.connected) {
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    this.sendBuffer.splice(i, 1);
                }
            }
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks[id] = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, [null, ...args]);
        };
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine \`open\`.
     *
     * @private
     */
    onopen() {
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT, data });
            });
        }
        else {
            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT, data: this.auth });
        }
    }
    /**
     * Called upon engine or manager \`error\`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine \`close\`.
     *
     * @param reason
     * @private
     */
    onclose(reason) {
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emitReserved("disconnect", reason);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT:
                if (packet.data && packet.data.sid) {
                    const id = packet.data.sid;
                    this.onconnect(id);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].ACK:
                this.onack(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        if (null != packet.id) {
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            self.packet({
                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if ("function" === typeof ack) {
            ack.apply(this, packet.data);
            delete this.acks[packet.id];
        }
        else {
        }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id) {
        this.id = id;
        this.connected = true;
        this.disconnected = false;
        this.emitBuffered();
        this.emitReserved("connect");
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => this.packet(packet));
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually.
     *
     * @return self
     * @public
     */
    disconnect() {
        if (this.connected) {
            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__["PacketType"].DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for disconnect()
     *
     * @return self
     * @public
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if \`true\`, compresses the sending data
     * @return self
     * @public
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @returns self
     * @public
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * \`\`\`
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     * \`\`\`
     *
     * @returns self
     * @public
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */
    listenersAny() {
        return this._anyListeners || [];
    }
}


/***/ }),

/***/ "./node_modules/socket.io-client/build/esm/url.js":
/*!********************************************************!*\\
  !*** ./node_modules/socket.io-client/build/esm/url.js ***!
  \\********************************************************/
/*! exports provided: url */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "url", function() { return url; });
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
/* harmony import */ var parseuri__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(parseuri__WEBPACK_IMPORTED_MODULE_0__);

/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\\/\\//.test(uri)) {
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        obj = parseuri__WEBPACK_IMPORTED_MODULE_0___default()(uri);
    }
    // make sure we treat \`localhost:80\` and \`localhost\` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/binary.js":
/*!*****************************************************************************************!*\\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/binary.js ***!
  \\*****************************************************************************************/
/*! exports provided: deconstructPacket, reconstructPacket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deconstructPacket", function() { return deconstructPacket; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reconstructPacket", function() { return reconstructPacket; });
/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-binary.js */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js");

/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_0__["isBinary"])(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    packet.attachments = undefined; // no longer useful
    return packet;
}
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder) {
        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js":
/*!****************************************************************************************!*\\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/index.js ***!
  \\****************************************************************************************/
/*! exports provided: protocol, PacketType, Encoder, Decoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return protocol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PacketType", function() { return PacketType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Encoder", function() { return Encoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Decoder", function() { return Decoder; });
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @socket.io/component-emitter */ "./node_modules/@socket.io/component-emitter/index.js");
/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/binary.js");
/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-binary.js */ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js");



/**
 * Protocol version.
 *
 * @public
 */
const protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__["hasBinary"])(obj)) {
                obj.type =
                    obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK;
                return this.encodeAsBinary(obj);
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than \`/\`
        // we append it followed by a comma \`,\`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data);
        }
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__["deconstructPacket"])(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__["Emitter"] {
    constructor() {
        super();
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            packet = this.decodeString(obj);
            if (packet.type === PacketType.BINARY_EVENT ||
                packet.type === PacketType.BINARY_ACK) {
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__["isBinary"])(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        return p;
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return typeof payload === "object";
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || typeof payload === "object";
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return Array.isArray(payload) && payload.length > 0;
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
        }
    }
}
function tryParse(str) {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        return false;
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__["reconstructPacket"])(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js":
/*!********************************************************************************************!*\\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/build/esm/is-binary.js ***!
  \\********************************************************************************************/
/*! exports provided: isBinary, hasBinary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBinary", function() { return isBinary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasBinary", function() { return hasBinary; });
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\\
  !*** (webpack)/buildin/global.js ***!
  \\***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \\*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\\
  !*** ./node_modules/yeast/index.js ***!
  \\*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the \`yeast\`, \`encode\` and \`decode\` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ "./package.json":
/*!**********************!*\\
  !*** ./package.json ***!
  \\**********************/
/*! exports provided: name, version, description, module, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */
/***/ (function(module) {

module.exports = JSON.parse("{\\"name\\":\\"imjoy-rpc\\",\\"version\\":\\"0.5.9\\",\\"description\\":\\"Remote procedure calls for ImJoy.\\",\\"module\\":\\"index.js\\",\\"scripts\\":{\\"build\\":\\"rm -rf dist && npm run build-umd\\",\\"build-umd\\":\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\",\\"watch\\":\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\",\\"publish-npm\\":\\"npm install && npm run build && npm publish\\",\\"serve\\":\\"webpack-dev-server\\",\\"stats\\":\\"webpack --profile --json > stats.json\\",\\"stats-prod\\":\\"webpack --profile --json --mode production > stats-prod.json\\",\\"analyze\\":\\"webpack-bundle-analyzer -p 9999 stats.json\\",\\"analyze-prod\\":\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\",\\"clean\\":\\"rimraf dist/*\\",\\"deploy\\":\\"npm run build && node deploy-site.js\\",\\"format\\":\\"prettier --write \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"check-format\\":\\"prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"test\\":\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\",\\"test-watch\\":\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\"},\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\"},\\"keywords\\":[\\"imjoy\\",\\"rpc\\"],\\"author\\":\\"imjoy-team <imjoy.team@gmail.com>\\",\\"license\\":\\"MIT\\",\\"bugs\\":{\\"url\\":\\"https://github.com/imjoy-team/imjoy-rpc/issues\\"},\\"homepage\\":\\"https://github.com/imjoy-team/imjoy-rpc\\",\\"dependencies\\":{\\"@msgpack/msgpack\\":\\"^2.7.1\\",\\"socket.io-client\\":\\"^4.4.1\\"},\\"devDependencies\\":{\\"@babel/core\\":\\"^7.16.12\\",\\"@babel/plugin-syntax-dynamic-import\\":\\"^7.8.3\\",\\"@babel/polyfill\\":\\"^7.12.1\\",\\"@babel/preset-env\\":\\"^7.16.11\\",\\"@types/requirejs\\":\\"^2.1.34\\",\\"babel-core\\":\\"^6.26.0\\",\\"babel-eslint\\":\\"^10.1.0\\",\\"babel-loader\\":\\"^8.2.3\\",\\"babel-runtime\\":\\"^6.26.0\\",\\"chai\\":\\"^4.3.6\\",\\"clean-webpack-plugin\\":\\"^0.1.19\\",\\"copy-webpack-plugin\\":\\"^5.1.2\\",\\"eslint\\":\\"^6.8.0\\",\\"eslint-config-prettier\\":\\"^4.2.0\\",\\"eslint-loader\\":\\"^4.0.2\\",\\"file-loader\\":\\"^0.11.2\\",\\"fs-extra\\":\\"^0.30.0\\",\\"gh-pages\\":\\"^2.0.1\\",\\"html-loader\\":\\"^0.5.5\\",\\"html-webpack-plugin\\":\\"^3.2.0\\",\\"json-loader\\":\\"^0.5.4\\",\\"karma\\":\\"^6.3.12\\",\\"karma-chrome-launcher\\":\\"^3.1.0\\",\\"karma-firefox-launcher\\":\\"^1.3.0\\",\\"karma-mocha\\":\\"^1.3.0\\",\\"karma-sourcemap-loader\\":\\"^0.3.8\\",\\"karma-spec-reporter\\":\\"0.0.32\\",\\"karma-webpack\\":\\"^4.0.2\\",\\"lerna\\":\\"^3.22.1\\",\\"lodash.debounce\\":\\"^4.0.8\\",\\"mocha\\":\\"^7.2.0\\",\\"postcss\\":\\"^7.0.36\\",\\"prettier\\":\\"^1.6.1\\",\\"rimraf\\":\\"^2.6.2\\",\\"schema-utils\\":\\"^0.4.3\\",\\"style-loader\\":\\"^0.18.1\\",\\"url-loader\\":\\"^0.5.9\\",\\"webpack\\":\\"^4.46.0\\",\\"webpack-bundle-analyzer\\":\\"^3.9.0\\",\\"webpack-cli\\":\\"^3.3.12\\",\\"webpack-dev-server\\":\\"^3.11.3\\",\\"webpack-merge\\":\\"^4.1.1\\",\\"workbox-webpack-plugin\\":\\"^4.3.1\\",\\"worker-loader\\":\\"^2.0.0\\",\\"write-file-webpack-plugin\\":\\"^4.5.1\\"},\\"eslintConfig\\":{\\"globals\\":{\\"document\\":true,\\"window\\":true}}}");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\\
  !*** ./src/main.js ***!
  \\*********************/
/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitForInitialization", function() { return waitForInitialization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupRPC", function() { return setupRPC; });
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.webworker.js */ "./src/plugin.webworker.js");
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginIframe.js */ "./src/pluginIframe.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirements"]; });

/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["RPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["API_VERSION"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_4__["version"]; });

/**
 * Contains the code executed in the sandboxed frame under web-browser
 *
 * Tries to create a Web-Worker inside the frame and set up the
 * communication between the worker and the parent window. Some
 * browsers restrict creating a worker inside a sandboxed iframe - if
 * this happens, the plugin initialized right inside the frame (in the
 * same thread)
 */







function _inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

function _inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
/**
 * Initializes the plugin inside a web worker. May throw an exception
 * in case this was not permitted by the browser.
 */


function setupWebWorker(config) {
  if (!config.allow_execution) throw new Error("web-worker plugin can only work with allow_execution=true");
  let broadcastChannel = null;

  if (config.broadcastChannel) {
    broadcastChannel = new BroadcastChannel(config.broadcastChannel);
  }

  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker
  // initialization without exception, handling this with timeout

  const fallbackTimeout = setTimeout(function () {
    worker.terminate();
    console.warn(\`Plugin failed to start as a web-worker, running in an iframe instead.\`);
    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
  }, 2000);
  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])(); // forwarding messages between the worker and parent window

  worker.addEventListener("message", function (e) {
    let transferables = undefined;
    const m = e.data;

    if (m.type === "worker-ready") {
      // send config to the worker
      worker.postMessage({
        type: "connectRPC",
        config: config
      });
      clearTimeout(fallbackTimeout);
      return;
    } else if (m.type === "initialized") {
      // complete the missing fields
      m.config = Object.assign({}, config, m.config);
      m.origin = window.location.origin;
      m.peer_id = peer_id;
    } else if (m.type === "imjoy_remote_api_ready") {
      // if it's a webworker, there will be no api object returned
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: null
      }));
    } else if (m.type === "cacheRequirements" && typeof cache_requirements === "function") {
      cache_requirements(m.requirements);
    } else if (m.type === "disconnect") {
      worker.terminate();
    } else {
      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }
    }

    if (broadcastChannel) broadcastChannel.postMessage(m);else parent.postMessage(m, config.target_origin || "*", transferables);
  });
  (broadcastChannel || window).addEventListener("message", function (e) {
    if (e.type === "message" && (broadcastChannel || config.target_origin === "*" || e.origin === config.target_origin)) {
      let transferables = undefined;
      const m = e.data;

      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }

      if (m.peer_id === peer_id) {
        worker.postMessage(m, transferables);
      } else if (config.debug) {
        console.log(\`connection peer id mismatch \${m.peer_id} !== \${peer_id}\`);
      }
    }
  });
}

function waitForInitialization(config) {
  if (_inWebWorker()) {
    globalThis.parent = self;
  }

  config = config || {};

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
    config.enable_service_worker = false;
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  const targetOrigin = config.target_origin || "*";

  if (config.credential_required && typeof config.verify_credential !== "function") {
    throw new Error("Please also provide the \`verify_credential\` function with \`credential_required\`.");
  }

  if (config.credential_required && targetOrigin === "*") {
    throw new Error("\`target_origin\` was set to \`*\` with \`credential_required=true\`, there is a security risk that you may leak the credential to website from other origin. Please specify the \`target_origin\` explicitly.");
  }

  const done = () => {
    globalThis.removeEventListener("message", handleEvent);
  };

  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();

  const handleEvent = e => {
    if (e.type === "message" && (!e.origin || targetOrigin === "*" || e.origin === targetOrigin)) {
      if (e.data.type === "initialize") {
        done();

        if (e.data.peer_id !== peer_id) {
          // TODO: throw an error when we are sure all the peers will send the peer_id
          console.warn(\`\${e.data.config && e.data.config.name}: connection peer id mismatch \${e.data.peer_id} !== \${peer_id}\`);
        }

        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client
        // otherwise take the setting from the core

        if (targetOrigin !== "*") {
          cfg.target_origin = targetOrigin;
        }

        if (config.credential_required) {
          config.verify_credential(cfg.credential).then(result => {
            if (result && result.auth && !result.error) {
              // pass the authentication information with tokens
              cfg.auth = result.auth;
              setupRPC(cfg).then(() => {
                console.log("ImJoy RPC loaded successfully!");
              });
            } else {
              throw new Error("Failed to verify the credentail:" + (result && result.error));
            }
          });
        } else {
          setupRPC(cfg).then(() => {
            console.log("ImJoy RPC loaded successfully!");
          });
        }
      } else {
        throw new Error(\`unrecognized message: \${e.data}\`);
      }
    }
  };

  globalThis.addEventListener("message", handleEvent);

  if (_inWebWorker()) {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    });
  } else {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    }, "*");
  }
}
function setupRPC(config) {
  config = config || {};
  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["normalizeConfig"])(config);

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  return new Promise((resolve, reject) => {
    const handleEvent = e => {
      const api = e.detail;

      if (config.expose_api_globally) {
        globalThis.api = api;
      } // imjoy plugin api


      resolve(api);
      globalThis.removeEventListener("imjoy_remote_api_ready", handleEvent);
    };

    if (_inIframe()) {
      if (config.type === "web-worker") {
        try {
          setupWebWorker(config);
        } catch (e) {
          // fallback to iframe
          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
        }
      } else if (["rpc-window", "rpc-worker", "iframe", "window"].includes(config.type)) {
        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
      } else {
        console.error("Unsupported plugin type: " + config.type);
        reject("Unsupported plugin type: " + config.type);
        return;
      }

      globalThis.addEventListener("imjoy_remote_api_ready", handleEvent);
    } else if (_inWebWorker()) {
      // inside a webworker
      Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
    } else {
      reject(new Error("imjoy-rpc should only run inside an iframe or a webworker."));
    }
  });
}

/***/ }),

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\\
  !*** ./src/plugin.webworker.js ***!
  \\*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\"\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\"./src/plugin.webworker.js\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\"./src/plugin.webworker.js\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\"./src/pluginCore.js\\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \\"undefined\\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\\"This script can only loaded in a webworker\\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \\"data:text/javascript;charset=utf-8,\\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"MessageEmitter\\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\\"message\\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \\"initialized\\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\\"beforeDisconnect\\");\\n    self.close();\\n    this._fire(\\"disconnected\\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \\"requirements\\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"loadRequirementsInWebworker\\"])(code.requirements);\\n    } else if (code.type === \\"script\\") {\\n      try {\\n        if (code.attrs.type === \\"module\\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \\"unsupported code type.\\";\\n    }\\n    if (code.type === \\"requirements\\") {\\n      self.postMessage({\\n        type: \\"cacheRequirements\\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \\"web-worker\\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \\"javascript\\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\"API_VERSION\\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\\"connectRPC\\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\"connectRPC\\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \\"worker-ready\\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \\"./src/pluginCore.js\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"connectRPC\\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\"RPC\\"](connection, config, codecs);\\n  rpc.on(\\"getInterface\\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\\"remoteReady\\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\\"name\\"] || !config[\\"encoder\\"] && !config[\\"decoder\\"]) {\\n        throw new Error(\\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\\"Remove duplicated codec: \\" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\\"name\\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \\"imjoy_remote_api_ready\\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \\"function\\") {\\n      const msg = \\"A function may only be subsribed to the event, \\" + type + \\" was provided instead\\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/rpc.js\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"API_VERSION\\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"RPC\\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \\"0.2.3\\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\\"undefined index\\");\\n  if (typeof is === \\"string\\") return indexObject(obj, is.split(\\".\\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"MessageEmitter\\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(\`connection.execute not implemented (in \\"\${name}\\")\`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\\"remoteIdle\\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\\"remoteBusy\\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \\"initialized\\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\\"interfaceAvailable\\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\\"interfaceSetAsRemote\\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\\"interface is not set.\\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \\"setInterface\\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(\`Object (id=\${objectId}) not found.\`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\\"disposed\\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \\"disposeObject\\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\\"Invalid object\\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\\"init\\", this.init);\\n\\n    this._connection.on(\\"execute\\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \\"executed\\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"executed\\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\\"method\\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\\".\\")) {\\n          const tmp = data.name.split(\\".\\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\\".\\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"callback\\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"disposeObject\\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"setInterface\\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\\"getInterface\\", () => {\\n      this._fire(\\"getInterface\\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\\"interfaceAvailable\\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"interfaceSetAsRemote\\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\\"interfaceSetAsRemote\\");\\n    });\\n\\n    this._connection.on(\\"disconnect\\", () => {\\n      this._fire(\\"beforeDisconnect\\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\\"disconnected\\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \\"getInterface\\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \\"dtype doesn't match the type of the array: \\" + _dtype + \\" != \\" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \\"ndarray\\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\\"remoteReady\\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \\"/\\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \\"register\\" || name === \\"registerService\\" || name === \\"register_service\\" || name === \\"export\\" || name === \\"on\\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \\"method\\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \\"interfaceSetAsRemote\\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \\"number\\" || aType === \\"string\\" || aType === \\"boolean\\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \\"function\\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\\"objectId is not specified.\\");\\n        bObject = {\\n          _rtype: \\"interface\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \\"callback\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \\"undefined\\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \\"undefined\\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \\"error\\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \\"undefined\\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \\"undefined\\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \\"undefined\\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \\"undefined\\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \\"undefined\\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \\"blob\\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject);\\n      bObject = {\\n        _rtype: \\"typedarray\\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"memoryview\\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \\"set\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \\"orderedmap\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\\"Please instantiate the class before exportting it.\\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\\"Unsupported interface type\\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \\"string\\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \\"constructor\\") continue;\\n\\n          if (k.startsWith(\\"_\\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \\"string\\" ? asInterface + \\".\\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \\"function\\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \\"function\\") {\\n          aObject.on(\\"close\\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \\"object\\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n\\n      for (let k of keys) {\\n        if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \\"imjoy-rpc: Unsupported data type:\\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\\"Failed to encode object\\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\\"_rtype\\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \\"callback\\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \\"interface\\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \\"ndarray\\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \\"undefined\\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \\"undefined\\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \\"error\\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \\"file\\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \\"typedarray\\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\\"unsupported dtype: \\" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \\"memoryview\\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \\"blob\\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \\"orderedmap\\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \\"set\\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\\"Failed to decode object\\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \\"callback\\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \\"callback\\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \\"disconnect\\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/utils.js\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"randId\\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"dtypeToTypedArray\\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWindow\\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWebworker\\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirements\\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"normalizeConfig\\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtypeMapping\\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtype\\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"cacheRequirements\\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"setupServiceWorker\\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"urlJoin\\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"MessageEmitter\\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\\"script\\");\\n      scriptTag.src = url;\\n      scriptTag.type = \\"text/javascript\\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \\"loaded\\" || this.readyState === \\"complete\\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \\"string\\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n            if (requirements[i].startsWith(\\"css:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\\"link\\");\\n            link_node.rel = \\"stylesheet\\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".mjs\\") || requirements[i].startsWith(\\"mjs:\\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\\"mjs:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n            if (requirements[i].startsWith(\\"js:\\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"http\\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n          } else {\\n            console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \\"unsupported requirements definition\\";\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n          throw \\"unable to import css in a webworker\\";\\n        } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n          if (requirements[i].startsWith(\\"js:\\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"http\\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n        } else {\\n          console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \\"0.1.0\\";\\n  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;\\n  config.type = config.type || \\"rpc-window\\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \\"*\\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \\"function\\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \\"int8\\",\\n  Int16Array: \\"int16\\",\\n  Int32Array: \\"int32\\",\\n  Uint8Array: \\"uint8\\",\\n  Uint16Array: \\"uint16\\",\\n  Uint32Array: \\"uint32\\",\\n  Float32Array: \\"float32\\",\\n  Float64Array: \\"float64\\",\\n  Array: \\"array\\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \\"add\\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\\"Service worker is not supported.\\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\\"Service worker controller is not available\\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\\"js:\\")) req = req.slice(3);\\n    if (req.startsWith(\\"css:\\")) req = req.slice(4);\\n    if (req.startsWith(\\"cache:\\")) req = req.slice(6);\\n    if (!req.startsWith(\\"http\\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\\"serviceWorker\\" in navigator) {\\n    baseUrl = baseUrl || \\"/\\";\\n    navigator.serviceWorker.register(baseUrl + \\"plugin-service-worker.js\\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\\"ServiceWorker registration successful with scope: \\", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\\"ServiceWorker registration failed: \\", err);\\n    });\\n    targetOrigin = targetOrigin || \\"*\\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \\"function\\") {\\n      throw new Error(\\"config.cache_requirements must be a function\\");\\n    }\\n\\n    window.addEventListener(\\"message\\", function (e) {\\n      if (targetOrigin === \\"*\\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \\"cacheRequirements\\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\\"/\\").replace(/[\\\\/]+/g, \\"/\\").replace(/^(.+):\\\\//, \\"$1://\\").replace(/^file:/, \\"file:/\\").replace(/\\\\/(\\\\?|&|#[^!])/g, \\"$1\\").replace(/\\\\?/g, \\"&\\").replace(\\"&\\", \\"?\\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\\"emit is not implemented\\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\\"unhandled event\\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map", null);
};

/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\\
  !*** ./src/pluginCore.js ***!
  \\***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectRPC", function() { return connectRPC; });
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/**
 * Core plugin script loaded into the plugin process/thread.
 *
 * Initializes the plugin-site API global methods.
 */

function connectRPC(connection, config) {
  config = config || {};
  const codecs = {};
  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__["RPC"](connection, config, codecs);
  rpc.on("getInterface", function () {
    launchConnected();
  });
  rpc.on("remoteReady", function () {
    const api = rpc.getRemote() || {};

    api.registerCodec = function (config) {
      if (!config["name"] || !config["encoder"] && !config["decoder"]) {
        throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");
      } else {
        if (config.type) {
          for (let k of Object.keys(codecs)) {
            if (codecs[k].type === config.type || k === config.name) {
              delete codecs[k];
              console.warn("Remove duplicated codec: " + k);
            }
          }
        }

        codecs[config["name"]] = config;
      }
    };

    api.init = function (config) {
      // register a minimal plugin api
      rpc.setInterface({
        setup() {}

      }, config);
    };

    api.disposeObject = function (obj) {
      rpc.disposeObject(obj);
    };

    api.export = function (_interface, config) {
      rpc.setInterface(_interface, config);
    };

    api.onLoad = function (handler) {
      handler = checkHandler(handler);

      if (connected) {
        handler();
      } else {
        connectedHandlers.push(handler);
      }
    };

    api.dispose = function (_interface) {
      rpc.disconnect();
    };

    api._rpc = rpc;

    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
      self.api = api;
      self.postMessage({
        type: "imjoy_remote_api_ready"
      });
      self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    } else if (typeof window) {
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    }
  });
  let connected = false;
  const connectedHandlers = [];

  const launchConnected = function () {
    if (!connected) {
      connected = true;
      let handler;

      while (handler = connectedHandlers.pop()) {
        handler();
      }
    }
  };

  const checkHandler = function (handler) {
    const type = typeof handler;

    if (type !== "function") {
      const msg = "A function may only be subsribed to the event, " + type + " was provided instead";
      throw new Error(msg);
    }

    return handler;
  };

  return rpc;
}

/***/ }),

/***/ "./src/pluginIframe.js":
/*!*****************************!*\\
  !*** ./src/pluginIframe.js ***!
  \\*****************************/
/*! exports provided: Connection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return setupIframe; });
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the routines loaded by the plugin iframe under web-browser
 * in case when worker failed to initialize
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */


 // Create a new, plain <span> element

function _htmlToElement(html) {
  var template = document.createElement("template");
  html = html.trim(); // Never return a text node of whitespace as the result

  template.innerHTML = html;
  return template.content.firstChild;
}

const _inWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;

async function executeEsModule(content) {
  const dataUri = "data:text/javascript;charset=utf-8," + encodeURIComponent(content);
  await import(
  /* webpackIgnore: true */
  dataUri);
}

class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  }

  connect() {
    this.config.target_origin = this.config.target_origin || "*"; // this will call handleEvent function

    if (this.config.broadcastChannel) {
      this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);
    } else {
      this.broadcastChannel = null;
    }

    if (this.broadcastChannel) this.broadcastChannel.addEventListener("message", this);else globalThis.addEventListener("message", this);
    this.emit({
      type: "initialized",
      config: this.config,
      origin: globalThis.location.origin,
      peer_id: this.peer_id
    });

    this._fire("connected");
  }

  handleEvent(e) {
    if (e.type === "message" && (this.broadcastChannel || this.config.target_origin === "*" || !e.origin || e.origin === this.config.target_origin)) {
      if (e.data.peer_id === this.peer_id) {
        this._fire(e.data.type, e.data);
      } else if (this.config.debug) {
        console.log(\`connection peer id mismatch \${e.data.peer_id} !== \${this.peer_id}\`);
      }
    }
  }

  disconnect() {
    this._fire("beforeDisconnect");

    globalThis.removeEventListener("message", this);

    this._fire("disconnected");
  }

  emit(data) {
    let transferables;
    if (this.broadcastChannel) this.broadcastChannel.postMessage(data);else {
      if (data.__transferables__) {
        transferables = data.__transferables__;
        delete data.__transferables__;
      } else if (_inWebWorker) self.postMessage(data, transferables);else parent.postMessage(data, this.config.target_origin, transferables);
    }
  }

  async execute(code) {
    try {
      if (code.type === "requirements") {
        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirementsInWindow"])(code.requirements);
      } else if (code.type === "script") {
        if (code.src) {
          var script_node = document.createElement("script");
          script_node.setAttribute("type", code.attrs.type);
          script_node.setAttribute("src", code.src);
          document.head.appendChild(script_node);
        } else {
          if (code.content && code.attrs.lang === "javascript") {
            // document.addEventListener("DOMContentLoaded", function(){
            if (code.attrs.type === "module") {
              await executeEsModule(code.content);
            } else {
              eval(code.content);
            } // });

          } else {
            var node = document.createElement("script");

            for (let k in code.attrs) {
              node.setAttribute(k, code.attrs[k]);
            }

            node.appendChild(document.createTextNode(code.content));
            document.body.appendChild(node);
          }
        }
      } else if (code.type === "style") {
        const style_node = document.createElement("style");

        if (code.src) {
          style_node.src = code.src;
        }

        style_node.innerHTML = code.content;
        document.head.appendChild(style_node);
      } else if (code.type === "link") {
        const link_node_ = document.createElement("link");

        if (code.rel) {
          link_node_.rel = code.rel;
        }

        if (code.href) {
          link_node_.href = code.href;
        }

        if (code.attrs && code.attrs.type) {
          link_node_.type = code.attrs.type;
        }

        document.head.appendChild(link_node_);
      } else if (code.type === "html") {
        document.body.appendChild(_htmlToElement(code.content));
      } else {
        throw "unsupported code type.";
      }

      if (_inWebWorker) self.postMessage({
        type: "executed"
      });else parent.postMessage({
        type: "executed"
      }, this.config.target_origin);
    } catch (e) {
      console.error("failed to execute scripts: ", code, e);
      if (_inWebWorker) self.postMessage({
        type: "executed",
        error: e.stack || String(e)
      });else parent.postMessage({
        type: "executed",
        error: e.stack || String(e)
      }, this.config.target_origin);
    }
  }

}
function setupIframe(config) {
  config = config || {};
  config.dedicated_thread = false;
  config.lang = "javascript";
  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"];
  const conn = new Connection(config);
  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(conn, config);
  conn.connect();
}

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\\
  !*** ./src/rpc.js ***!
  \\********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return API_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return RPC; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the RPC object used both by the application
 * site, and by each plugin
 */

const API_VERSION = "0.2.3";
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;

function _appendBuffer(buffer1, buffer2) {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
}

function indexObject(obj, is) {
  if (!is) throw new Error("undefined index");
  if (typeof is === "string") return indexObject(obj, is.split("."));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));
}
/**
 * RPC object represents a single site in the
 * communication protocol between the application and the plugin
 *
 * @param {Object} connection a special object allowing to send
 * and receive messages from the opposite site (basically it
 * should only provide send() and onMessage() methods)
 */


class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(connection, config, codecs) {
    super(config && config.debug);
    this._connection = connection;
    this.config = config || {};
    this._codecs = codecs || {};
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._remote_set = false; // make sure there is an execute function

    const name = this.config.name;

    this._connection.execute = this._connection.execute || function () {
      throw new Error(\`connection.execute not implemented (in "\${name}")\`);
    };

    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();

    this._method_refs.onReady(() => {
      this._fire("remoteIdle");
    });

    this._method_refs.onBusy(() => {
      this._fire("remoteBusy");
    });

    this._setupMessageHanlders();
  }

  init() {
    this._connection.emit({
      type: "initialized",
      config: this.config,
      peer_id: this._connection.peer_id
    });
  }

  setConfig(config) {
    if (config) for (const k of Object.keys(config)) {
      this.config[k] = config[k];
    }
  }
  /**
   * Set a handler to be called when received a responce from the
   * remote site reporting that the previously provided interface
   * has been successfully set as remote for that site
   *
   * @param {Function} handler
   */


  getRemoteCallStack() {
    return this._method_refs.getStack();
  }
  /**
   * @returns {Object} set of remote interface methods
   */


  getRemote() {
    return this._remote_interface;
  }
  /**
   * Sets the interface of this site making it available to the
   * remote site by sending a message with a set of methods names
   *
   * @param {Object} _interface to set
   */


  setInterface(_interface, config) {
    config = config || {};
    this.config.name = config.name || this.config.name;
    this.config.description = config.description || this.config.description;

    if (this.config.forwarding_functions) {
      for (let func_name of this.config.forwarding_functions) {
        const _remote = this._remote_interface;

        if (_remote[func_name]) {
          if (_interface.constructor === Object) {
            if (!_interface[func_name]) {
              _interface[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          } else if (_interface.constructor.constructor === Function) {
            if (!_interface.constructor.prototype[func_name]) {
              _interface.constructor.prototype[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          }
        }
      }
    }

    this._local_api = _interface;
    if (!this._remote_set) this._fire("interfaceAvailable");else this.sendInterface();
    return new Promise(resolve => {
      this.once("interfaceSetAsRemote", resolve);
    });
  }
  /**
   * Sends the actual interface to the remote site upon it was
   * updated or by a special request of the remote site
   */


  sendInterface() {
    if (!this._local_api) {
      throw new Error("interface is not set.");
    }

    this._encode(this._local_api, true).then(api => {
      this._connection.emit({
        type: "setInterface",
        api: api
      });
    });
  }

  _disposeObject(objectId) {
    if (this._object_store[objectId]) {
      delete this._object_store[objectId];
    } else {
      throw new Error(\`Object (id=\${objectId}) not found.\`);
    }
  }

  disposeObject(obj) {
    return new Promise((resolve, reject) => {
      if (this._object_weakmap.has(obj)) {
        const objectId = this._object_weakmap.get(obj);

        this._connection.once("disposed", data => {
          if (data.error) reject(new Error(data.error));else resolve();
        });

        this._connection.emit({
          type: "disposeObject",
          object_id: objectId
        });
      } else {
        throw new Error("Invalid object");
      }
    });
  }
  /**
   * Handles a message from the remote site
   */


  _setupMessageHanlders() {
    this._connection.on("init", this.init);

    this._connection.on("execute", data => {
      Promise.resolve(this._connection.execute(data.code)).then(() => {
        this._connection.emit({
          type: "executed"
        });
      }).catch(e => {
        console.error(e);

        this._connection.emit({
          type: "executed",
          error: String(e)
        });
      });
    });

    this._connection.on("method", async data => {
      let resolve, reject, method, method_this, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        const _interface = this._object_store[data.object_id];
        method = indexObject(_interface, data.name);

        if (data.name.includes(".")) {
          const tmp = data.name.split(".");
          const intf_index = tmp.slice(0, tmp.length - 1).join(".");
          method_this = indexObject(_interface, intf_index);
        } else {
          method_this = _interface;
        }

        args = await this._unwrap(data.args, true);

        if (data.promise) {
          result = method.apply(method_this, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method.apply(method_this, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("callback", async data => {
      let resolve, reject, method, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        if (data.promise) {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          result = method.apply(null, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          method.apply(null, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("disposeObject", data => {
      try {
        this._disposeObject(data.object_id);

        this._connection.emit({
          type: "disposed"
        });
      } catch (e) {
        console.error(e);

        this._connection.emit({
          type: "disposed",
          error: String(e)
        });
      }
    });

    this._connection.on("setInterface", data => {
      this._setRemoteInterface(data.api);
    });

    this._connection.on("getInterface", () => {
      this._fire("getInterface");

      if (this._local_api) {
        this.sendInterface();
      } else {
        this.once("interfaceAvailable", () => {
          this.sendInterface();
        });
      }
    });

    this._connection.on("interfaceSetAsRemote", () => {
      this._remote_set = true;

      this._fire("interfaceSetAsRemote");
    });

    this._connection.on("disconnect", () => {
      this._fire("beforeDisconnect");

      this._connection.disconnect();

      this._fire("disconnected");
    });
  }
  /**
   * Sends a requests to the remote site asking it to provide its
   * current interface
   */


  requestRemote() {
    this._connection.emit({
      type: "getInterface"
    });
  }

  _ndarray(typedArray, shape, dtype) {
    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(typedArray);

    if (dtype && dtype !== _dtype) {
      throw "dtype doesn't match the type of the array: " + _dtype + " != " + dtype;
    }

    shape = shape || [typedArray.length];
    return {
      _rtype: "ndarray",
      _rvalue: typedArray.buffer,
      _rshape: shape,
      _rdtype: _dtype
    };
  }
  /**
   * Sets the new remote interface provided by the other site
   *
   * @param {Array} names list of function names
   */


  _setRemoteInterface(api) {
    this._decode(api).then(intf => {
      // update existing interface instead of recreating it
      // this will preserve the object reference
      if (this._remote_interface) {
        // clear the interface
        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces


        Object.assign(this._remote_interface, intf);
      } else this._remote_interface = intf;

      this._fire("remoteReady");

      this._reportRemoteSet();
    });
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * method. When the generated function is called, it will send the
   * corresponding message to the remote site asking it to execute
   * the particular method of its interface
   *
   * @param {String} name of the remote method
   *
   * @returns {Function} wrapped remote method
   */


  _genRemoteMethod(targetId, name, objectId) {
    const me = this;

    const remoteMethod = function () {
      return new Promise(async (resolve, reject) => {
        let id = null;

        try {
          id = me._method_refs.put(objectId ? objectId + "/" + name : name);

          const wrapped_resolve = function () {
            if (id !== null) me._method_refs.fetch(id);
            return resolve.apply(this, arguments);
          };

          const wrapped_reject = function () {
            if (id !== null) me._method_refs.fetch(id);
            return reject.apply(this, arguments);
          };

          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together

          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;
          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;
          let args = Array.prototype.slice.call(arguments);
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;

          if (name === "register" || name === "registerService" || name === "register_service" || name === "export" || name === "on") {
            args = await me._wrap(args, true);
          } else {
            args = await me._wrap(args);
          }

          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;

          me._connection.emit({
            type: "method",
            target_id: targetId,
            name: name,
            object_id: objectId,
            args: args,
            promise: encodedPromise,
            with_kwargs: withKwargs
          }, transferables);
        } catch (e) {
          if (id) me._method_refs.fetch(id);
          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);
        }
      });
    };

    remoteMethod.__remote_method = true;
    return remoteMethod;
  }
  /**
   * Sends a responce reporting that interface just provided by the
   * remote site was successfully set by this site as remote
   */


  _reportRemoteSet() {
    this._connection.emit({
      type: "interfaceSetAsRemote"
    });
  }
  /**
   * Prepares the provided set of remote method arguments for
   * sending to the remote site, replaces all the callbacks with
   * identifiers
   *
   * @param {Array} args to wrap
   *
   * @returns {Array} wrapped arguments
   */


  async _encode(aObject, asInterface, objectId) {
    const aType = typeof aObject;

    if (aType === "number" || aType === "string" || aType === "boolean" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {
      return aObject;
    }

    let bObject;

    if (typeof aObject === "function") {
      if (asInterface) {
        if (!objectId) throw new Error("objectId is not specified.");
        bObject = {
          _rtype: "interface",
          _rtarget_id: this._connection.peer_id,
          _rintf: objectId,
          _rvalue: asInterface
        };

        this._method_weakmap.set(aObject, bObject);
      } else if (this._method_weakmap.has(aObject)) {
        bObject = this._method_weakmap.get(aObject);
      } else {
        const cid = this._store.put(aObject);

        bObject = {
          _rtype: "callback",
          _rtarget_id: this._connection.peer_id,
          _rname: aObject.constructor && aObject.constructor.name || cid,
          _rvalue: cid
        };
      }

      return bObject;
    } // skip if already encoded


    if (aObject.constructor instanceof Object && aObject._rtype) {
      // make sure the interface functions are encoded
      if (aObject._rintf) {
        const temp = aObject._rtype;
        delete aObject._rtype;
        bObject = await this._encode(aObject, asInterface, objectId);
        bObject._rtype = temp;
      } else {
        bObject = aObject;
      }

      return bObject;
    }

    const transferables = [];
    const _transfer = aObject._transfer;
    const isarray = Array.isArray(aObject);

    for (let tp of Object.keys(this._codecs)) {
      const codec = this._codecs[tp];

      if (codec.encoder && aObject instanceof codec.type) {
        // TODO: what if multiple encoders found
        let encodedObj = await Promise.resolve(codec.encoder(aObject));
        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object

        if (encodedObj && encodedObj._rintf) {
          const temp = encodedObj._rtype;
          delete encodedObj._rtype;
          encodedObj = await this._encode(encodedObj, asInterface, objectId);
          encodedObj._rtype = temp;
        }

        bObject = encodedObj;
        return bObject;
      }
    }

    if (
    /*global tf*/
    typeof tf !== "undefined" && tf.Tensor && aObject instanceof tf.Tensor) {
      const v_buffer = aObject.dataSync();

      if (aObject._transfer || _transfer) {
        transferables.push(v_buffer.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: v_buffer.buffer,
        _rshape: aObject.shape,
        _rdtype: aObject.dtype
      };
    } else if (
    /*global nj*/
    typeof nj !== "undefined" && nj.NdArray && aObject instanceof nj.NdArray) {
      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject.selection.data);

      if (aObject._transfer || _transfer) {
        transferables.push(aObject.selection.data.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: aObject.selection.data.buffer,
        _rshape: aObject.shape,
        _rdtype: dtype
      };
    } else if (aObject instanceof Error) {
      console.error(aObject);
      bObject = {
        _rtype: "error",
        _rvalue: aObject.toString()
      };
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } // send objects supported by structure clone algorithm
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== "undefined" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== "undefined" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== "undefined" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== "undefined" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== "undefined" && aObject instanceof FileSystemWritableFileStream) {
      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rname: aObject.name,
        _rmime: aObject.type,
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } else if (aObject instanceof Blob) {
      bObject = {
        _rtype: "blob",
        _rvalue: aObject
      };
    } else if (aObject instanceof ArrayBufferView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject);
      bObject = {
        _rtype: "typedarray",
        _rvalue: aObject.buffer,
        _rdtype: dtype
      };
    } else if (aObject instanceof DataView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "memoryview",
        _rvalue: aObject.buffer
      };
    } else if (aObject instanceof Set) {
      bObject = {
        _rtype: "set",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject instanceof Map) {
      bObject = {
        _rtype: "orderedmap",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {
      bObject = isarray ? [] : {};
      let keys; // an object/array

      if (aObject.constructor === Object || Array.isArray(aObject)) {
        keys = Object.keys(aObject);
      } // a class
      else if (aObject.constructor === Function) {
        throw new Error("Please instantiate the class before exportting it.");
      } // instance of a class
      else if (aObject.constructor.constructor === Function) {
        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object
        // always encode class instance as interface

        asInterface = true;
      } else {
        throw Error("Unsupported interface type");
      }

      let hasFunction = false; // encode interfaces

      if (aObject._rintf || asInterface) {
        if (!objectId) {
          if (typeof aObject._rintf === "string" && aObject._rintf.length > 0) {
            objectId = aObject._rintf; // enable custom object id
          } else {
            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
          } // Note: object with the same id will be overwritten


          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);
          this._object_store[objectId] = aObject;
        }

        for (let k of keys) {
          if (k === "constructor") continue;

          if (k.startsWith("_")) {
            continue;
          }

          bObject[k] = await this._encode(aObject[k], typeof asInterface === "string" ? asInterface + "." + k : k, objectId);

          if (typeof aObject[k] === "function") {
            hasFunction = true;
          }
        } // object id for dispose the object remotely


        if (hasFunction) bObject._rintf = objectId; // remove interface when closed

        if (aObject.on && typeof aObject.on === "function") {
          aObject.on("close", () => {
            delete this._object_store[objectId];
          });
        }
      } else {
        for (let k of keys) {
          if (["hasOwnProperty", "constructor"].includes(k)) continue;
          bObject[k] = await this._encode(aObject[k]);
        }
      } // for example, browserFS object

    } else if (typeof aObject === "object") {
      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));
      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();

      for (let k of keys) {
        if (["hasOwnProperty", "constructor"].includes(k)) continue; // encode as interface

        bObject[k] = await this._encode(aObject[k], k, bObject);
      } // object id, used for dispose the object


      bObject._rintf = objectId;
    } else {
      throw "imjoy-rpc: Unsupported data type:" + aObject;
    }

    if (transferables.length > 0) {
      bObject.__transferables__ = transferables;
    }

    if (!bObject) {
      throw new Error("Failed to encode object");
    }

    return bObject;
  }

  async _decode(aObject, withPromise) {
    if (!aObject) {
      return aObject;
    }

    let bObject;

    if (aObject["_rtype"]) {
      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          aObject = await this._decode(aObject, withPromise);
          aObject._rtype = temp;
        }

        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));
      } else if (aObject._rtype === "callback") {
        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);
      } else if (aObject._rtype === "interface") {
        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);
      } else if (aObject._rtype === "ndarray") {
        /*global nj tf*/
        //create build array/tensor if used in the plugin
        if (typeof nj !== "undefined" && nj.array) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);
        } else if (typeof tf !== "undefined" && tf.Tensor) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);
        } else {
          //keep it as regular if transfered to the main app
          bObject = aObject;
        }
      } else if (aObject._rtype === "error") {
        bObject = new Error(aObject._rvalue);
      } else if (aObject._rtype === "file") {
        if (aObject._rvalue instanceof File) {
          bObject = aObject._rvalue; //patch _path

          bObject._path = aObject._rpath;
        } else {
          bObject = new File([aObject._rvalue], aObject._rname, {
            type: aObject._rmime
          });
          bObject._path = aObject._rpath;
        }
      } else if (aObject._rtype === "typedarray") {
        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
        if (!arraytype) throw new Error("unsupported dtype: " + aObject._rdtype);
        bObject = new arraytype(aObject._rvalue);
      } else if (aObject._rtype === "memoryview") {
        bObject = new DataView(aObject._rvalue);
      } else if (aObject._rtype === "blob") {
        if (aObject._rvalue instanceof Blob) {
          bObject = aObject._rvalue;
        } else {
          bObject = new Blob([aObject._rvalue], {
            type: aObject._rmime
          });
        }
      } else if (aObject._rtype === "orderedmap") {
        bObject = new Map(await this._decode(aObject._rvalue, withPromise));
      } else if (aObject._rtype === "set") {
        bObject = new Set(await this._decode(aObject._rvalue, withPromise));
      } else {
        // make sure all the interface functions are decoded
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          bObject = await this._decode(aObject, withPromise);
          bObject._rtype = temp;
        } else bObject = aObject;
      }
    } else if (aObject.constructor === Object || Array.isArray(aObject)) {
      const isarray = Array.isArray(aObject);
      bObject = isarray ? [] : {};

      for (let k of Object.keys(aObject)) {
        if (isarray || aObject.hasOwnProperty(k)) {
          const v = aObject[k];
          bObject[k] = await this._decode(v, withPromise);
        }
      }
    } else {
      bObject = aObject;
    }

    if (bObject === undefined) {
      throw new Error("Failed to decode object");
    } // store the object id for dispose


    if (aObject._rintf) {
      this._object_weakmap.set(bObject, aObject._rintf);
    }

    return bObject;
  }

  async _wrap(args, asInterface) {
    return await this._encode(args, asInterface);
  }
  /**
   * Unwraps the set of arguments delivered from the remote site,
   * replaces all callback identifiers with a function which will
   * initiate sending that callback identifier back to other site
   *
   * @param {Object} args to unwrap
   *
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Array} unwrapped args
   */


  async _unwrap(args, withPromise) {
    return await this._decode(args, withPromise);
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * callback. When the generated function is called, it will send
   * the corresponding message to the remote site asking it to
   * execute the particular callback previously saved during a call
   * by the remote site a method from the interface of this site
   *
   * @param {Number} id of the remote callback to execute
   * @param {Number} argNum argument index of the callback
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Function} wrapped remote callback
   */


  _genRemoteCallback(targetId, cid, withPromise) {
    const me = this;
    let remoteCallback;

    if (withPromise) {
      remoteCallback = function () {
        return new Promise(async (resolve, reject) => {
          const args = await me._wrap(Array.prototype.slice.call(arguments));
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;
          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;
          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together

          resolve.__promise_pair = encodedPromise[1]._rvalue;
          reject.__promise_pair = encodedPromise[0]._rvalue;

          try {
            me._connection.emit({
              type: "callback",
              target_id: targetId,
              id: cid,
              args: args,
              promise: encodedPromise,
              with_kwargs: withKwargs
            }, transferables);
          } catch (e) {
            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);
          }
        });
      };

      return remoteCallback;
    } else {
      remoteCallback = async function () {
        const args = await me._wrap(Array.prototype.slice.call(arguments));
        const argLength = args.length; // if the last argument is an object, mark it as kwargs

        const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
        if (withKwargs) delete args[argLength - 1]._rkwargs;
        const transferables = args.__transferables__;
        if (transferables) delete args.__transferables__;
        return me._connection.emit({
          type: "callback",
          target_id: targetId,
          id: cid,
          args: args,
          with_kwargs: withKwargs
        }, transferables);
      };

      return remoteCallback;
    }
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
    this._remote_interface = null;
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();
  }
  /**
   * Sends the notification message and breaks the connection
   */


  disconnect() {
    this._connection.emit({
      type: "disconnect"
    });

    this.reset();
    setTimeout(() => {
      this._connection.disconnect();
    }, 2000);
  }

}
/**
 * ReferenceStore is a special object which stores other objects
 * and provides the references (number) instead. This reference
 * may then be sent over a json-based communication channel (IPC
 * to another Node.js process or a message to the Worker). Other
 * site may then provide the reference in the responce message
 * implying the given object should be activated.
 *
 * Primary usage for the ReferenceStore is a storage for the
 * callbacks, which therefore makes it possible to initiate a
 * callback execution by the opposite site (which normally cannot
 * directly execute functions over the communication channel).
 *
 * Each stored object can only be fetched once and is not
 * available for the second time. Each stored object must be
 * fetched, since otherwise it will remain stored forever and
 * consume memory.
 *
 * Stored object indeces are simply the numbers, which are however
 * released along with the objects, and are later reused again (in
 * order to postpone the overflow, which should not likely happen,
 * but anyway).
 */

class ReferenceStore {
  constructor() {
    this._store = {}; // stored object

    this._indices = [0]; // smallest available indices

    this._readyHandler = function () {};

    this._busyHandler = function () {};

    this._readyHandler();
  }
  /**
   * call handler when the store is empty
   *
   * @param {FUNCTION} id of a handler
   */


  onReady(readyHandler) {
    this._readyHandler = readyHandler || function () {};
  }
  /**
   * call handler when the store is not empty
   *
   * @param {FUNCTION} id of a handler
   */


  onBusy(busyHandler) {
    this._busyHandler = busyHandler || function () {};
  }
  /**
   * get the length of the store
   *
   */


  getStack() {
    return Object.keys(this._store).length;
  }
  /**
   * @function _genId() generates the new reference id
   *
   * @returns {Number} smallest available id and reserves it
   */


  _genId() {
    let id;

    if (this._indices.length === 1) {
      id = this._indices[0]++;
    } else {
      id = this._indices.shift();
    }

    return id;
  }
  /**
   * Releases the given reference id so that it will be available by
   * another object stored
   *
   * @param {Number} id to release
   */


  _releaseId(id) {
    for (let i = 0; i < this._indices.length; i++) {
      if (id < this._indices[i]) {
        this._indices.splice(i, 0, id);

        break;
      }
    } // cleaning-up the sequence tail


    for (let i = this._indices.length - 1; i >= 0; i--) {
      if (this._indices[i] - 1 === this._indices[i - 1]) {
        this._indices.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Stores the given object and returns the refernce id instead
   *
   * @param {Object} obj to store
   *
   * @returns {Number} reference id of the stored object
   */


  put(obj) {
    if (this._busyHandler && Object.keys(this._store).length === 0) {
      this._busyHandler();
    }

    const id = this._genId();

    this._store[id] = obj;
    return id;
  }
  /**
   * Retrieves previously stored object and releases its reference
   *
   * @param {Number} id of an object to retrieve
   */


  fetch(id) {
    const obj = this._store[id];

    if (obj && !obj.__remote_method) {
      delete this._store[id];

      this._releaseId(id);

      if (this._readyHandler && Object.keys(this._store).length === 0) {
        this._readyHandler();
      }
    }

    if (obj && obj.__promise_pair) {
      this.fetch(obj.__promise_pair);
    }

    return obj;
  }

}

/***/ }),

/***/ "./src/socketIOMain.js":
/*!*****************************!*\\
  !*** ./src/socketIOMain.js ***!
  \\*****************************/
/*! exports provided: setupRPC, waitForInitialization, VERSION, RPC, API_VERSION, loadRequirements, Connection, connectToServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectToServer", function() { return connectToServer; });
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_1__["RPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"]; });

/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirements"]; });

/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-client */ "./node_modules/socket.io-client/build/esm/index.js");
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main.js */ "./src/main.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setupRPC", function() { return _main_js__WEBPACK_IMPORTED_MODULE_4__["setupRPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "waitForInitialization", function() { return _main_js__WEBPACK_IMPORTED_MODULE_4__["waitForInitialization"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_5__["version"]; });

/**
 * Contains the routines loaded by the plugin iframe under web-browser
 * in case when worker failed to initialize
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */








class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  }

  init() {
    return new Promise((resolve, reject) => {
      const config = this.config;
      const url = config.server_url;
      const extraHeaders = {};

      if (config.token) {
        extraHeaders.Authorization = "Bearer " + config.token;
      }

      const basePath = new URL(url).pathname; // Note: extraHeaders only works for polling transport (the default)
      // If we switch to websocket only, the headers won't be respected

      const socket = Object(socket_io_client__WEBPACK_IMPORTED_MODULE_3__["default"])(url, {
        withCredentials: true,
        extraHeaders,
        path: (basePath.endsWith("/") ? basePath.slice(0, -1) : basePath) + "/socket.io"
      });
      let connected = false;
      socket.on("connect", () => {
        if (connected) {
          console.warn("Skipping reconnect to the server");
          return;
        }

        socket.emit("register_plugin", config, result => {
          if (!result.success) {
            console.error(result.detail);
            reject(result.detail);
            return;
          }

          connected = true;
          this.plugin_id = result.plugin_id;
          socket.on("plugin_message", data => {
            if (data.peer_id === this.peer_id) {
              this._fire(data.type, data);
            } else if (this.config.debug) {
              console.log(\`connection peer id mismatch \${data.peer_id} !== \${this.peer_id}\`);
            }
          });
          this.once("initialize", () => {
            if (!this.rpc) {
              this.rpc = Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(this, config);
            } else {
              this.rpc.once("remoteReady", () => {
                this.rpc.sendInterface();
              });
            }

            this.connect();
            resolve();
          });
          this.emit({
            type: "imjoyRPCReady",
            config: config,
            peer_id: this.peer_id
          });
        });
        this._disconnected = false;
      });
      socket.on("connect_error", () => {
        reject("connection error");

        this._fire("connectFailure");
      });
      socket.on("disconnect", () => {
        reject("disconnected");
        this.disconnect();

        this._fire("disconnected");
      });
      this.socket = socket;
    });
  }

  connect() {
    this.emit({
      type: "initialized",
      config: this.config,
      origin: globalThis.location.origin,
      peer_id: this.peer_id
    });

    this._fire("connected");
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
  }

  execute() {
    throw new Error("Execution is not allowed for socketio connection");
  }

  disconnect() {
    this._fire("beforeDisconnect");

    this.socket.disconnect();
    this.init();

    this._fire("disconnected");
  }

  emit(data) {
    data.plugin_id = this.plugin_id;
    this.socket.emit("plugin_message", data, result => {
      if (!result.success) this._fire("error", data.detail);
    });
  }

}
function connectToServer(config) {
  config = config || {};
  if (!config.server_url) throw new Error("Server URL is not specified.");
  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["normalizeConfig"])(config);
  return new Promise((resolve, reject) => {
    const handleEvent = e => {
      const api = e.detail;

      if (config.expose_api_globally) {
        globalThis.api = api;
      } // imjoy plugin api


      resolve(api);
      globalThis.removeEventListener("imjoy_remote_api_ready", handleEvent);
    };

    globalThis.addEventListener("imjoy_remote_api_ready", handleEvent);
    config = config || {};
    config.dedicated_thread = false;
    config.lang = "javascript";
    config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"];
    const conn = new Connection(config);
    conn.init().catch(reject);
  });
}

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\\
  !*** ./src/utils.js ***!
  \\**********************/
/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dtypeToTypedArray", function() { return dtypeToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWindow", function() { return loadRequirementsInWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWebworker", function() { return loadRequirementsInWebworker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return loadRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeConfig", function() { return normalizeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtypeMapping", function() { return typedArrayToDtypeMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtype", function() { return typedArrayToDtype; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheRequirements", function() { return cacheRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupServiceWorker", function() { return setupServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlJoin", function() { return urlJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
function randId() {
  return Math.random().toString(36).substr(2, 10) + new Date().getTime();
}
const dtypeToTypedArray = {
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  float32: Float32Array,
  float64: Float64Array,
  array: Array
};
async function loadRequirementsInWindow(requirements) {
  function _importScript(url) {
    //url is URL of external file, implementationCode is the code
    //to be called from the file, location is the location to
    //insert the <script> element
    return new Promise((resolve, reject) => {
      var scriptTag = document.createElement("script");
      scriptTag.src = url;
      scriptTag.type = "text/javascript";
      scriptTag.onload = resolve;

      scriptTag.onreadystatechange = function () {
        if (this.readyState === "loaded" || this.readyState === "complete") {
          resolve();
        }
      };

      scriptTag.onerror = reject;
      document.head.appendChild(scriptTag);
    });
  } // support importScripts outside web worker


  async function importScripts() {
    var args = Array.prototype.slice.call(arguments),
        len = args.length,
        i = 0;

    for (; i < len; i++) {
      await _importScript(args[i]);
    }
  }

  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      var link_node;
      requirements = typeof requirements === "string" ? [requirements] : requirements;

      if (Array.isArray(requirements)) {
        for (var i = 0; i < requirements.length; i++) {
          if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
            if (requirements[i].startsWith("css:")) {
              requirements[i] = requirements[i].slice(4);
            }

            link_node = document.createElement("link");
            link_node.rel = "stylesheet";
            link_node.href = requirements[i];
            document.head.appendChild(link_node);
          } else if (requirements[i].toLowerCase().endsWith(".mjs") || requirements[i].startsWith("mjs:")) {
            // import esmodule
            if (requirements[i].startsWith("mjs:")) {
              requirements[i] = requirements[i].slice(4);
            }

            await import(
            /* webpackIgnore: true */
            requirements[i]);
          } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
            if (requirements[i].startsWith("js:")) {
              requirements[i] = requirements[i].slice(3);
            }

            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("http")) {
            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("cache:")) {//ignore cache
          } else {
            console.log("Unprocessed requirements url: " + requirements[i]);
          }
        }
      } else {
        throw "unsupported requirements definition";
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
async function loadRequirementsInWebworker(requirements) {
  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      if (!Array.isArray(requirements)) {
        requirements = [requirements];
      }

      for (var i = 0; i < requirements.length; i++) {
        if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
          throw "unable to import css in a webworker";
        } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
          if (requirements[i].startsWith("js:")) {
            requirements[i] = requirements[i].slice(3);
          }

          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("http")) {
          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("cache:")) {//ignore cache
        } else {
          console.log("Unprocessed requirements url: " + requirements[i]);
        }
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
function loadRequirements(requirements) {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return loadRequirementsInWebworker(requirements);
  } else {
    return loadRequirementsInWindow(requirements);
  }
}
function normalizeConfig(config) {
  config.version = config.version || "0.1.0";
  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;
  config.type = config.type || "rpc-window";
  config.id = config.id || randId();
  config.target_origin = config.target_origin || "*";
  config.allow_execution = config.allow_execution || false; // remove functions

  config = Object.keys(config).reduce((p, c) => {
    if (typeof config[c] !== "function") p[c] = config[c];
    return p;
  }, {});
  return config;
}
const typedArrayToDtypeMapping = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};
const typedArrayToDtypeKeys = [];

for (const arrType of Object.keys(typedArrayToDtypeMapping)) {
  typedArrayToDtypeKeys.push(eval(arrType));
}

function typedArrayToDtype(obj) {
  let dtype = typedArrayToDtypeMapping[obj.constructor.name];

  if (!dtype) {
    const pt = Object.getPrototypeOf(obj);

    for (const arrType of typedArrayToDtypeKeys) {
      if (pt instanceof arrType) {
        dtype = typedArrayToDtypeMapping[arrType.name];
        break;
      }
    }
  }

  return dtype;
}

function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}

async function cacheRequirements(requirements) {
  requirements = requirements || [];

  if (!Array.isArray(requirements)) {
    requirements = [requirements];
  }

  for (let req of requirements) {
    //remove prefix
    if (req.startsWith("js:")) req = req.slice(3);
    if (req.startsWith("css:")) req = req.slice(4);
    if (req.startsWith("cache:")) req = req.slice(6);
    if (!req.startsWith("http")) continue;
    await cacheUrlInServiceWorker(req).catch(e => {
      console.error(e);
    });
  }
}
function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {
  // register service worker for offline access
  if ("serviceWorker" in navigator) {
    baseUrl = baseUrl || "/";
    navigator.serviceWorker.register(baseUrl + "plugin-service-worker.js").then(function (registration) {
      // Registration was successful
      console.log("ServiceWorker registration successful with scope: ", registration.scope);
    }, function (err) {
      // registration failed :(
      console.log("ServiceWorker registration failed: ", err);
    });
    targetOrigin = targetOrigin || "*";
    cacheCallback = cacheCallback || cacheRequirements;

    if (cacheCallback && typeof cacheCallback !== "function") {
      throw new Error("config.cache_requirements must be a function");
    }

    window.addEventListener("message", function (e) {
      if (targetOrigin === "*" || e.origin === targetOrigin) {
        const m = e.data;

        if (m.type === "cacheRequirements") {
          cacheCallback(m.requirements);
        }
      }
    });
  }
} //#Source https://bit.ly/2neWfJ2

function urlJoin(...args) {
  return args.join("/").replace(/[\\/]+/g, "/").replace(/^(.+):\\//, "$1://").replace(/^file:/, "file:/").replace(/\\/(\\?|&|#[^!])/g, "$1").replace(/\\?/g, "&").replace("&", "?");
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}

/***/ })

/******/ });
});
//# sourceMappingURL=imjoy-rpc-socketio.js.map

//# sourceURL=webpack://%5Bname%5D/./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js?`)},"./node_modules/imjoy-rpc/dist/imjoy-rpc.js":function(module,exports,__webpack_require__){eval(`(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \\*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./package.json":
/*!**********************!*\\
  !*** ./package.json ***!
  \\**********************/
/*! exports provided: name, version, description, module, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */
/***/ (function(module) {

module.exports = JSON.parse("{\\"name\\":\\"imjoy-rpc\\",\\"version\\":\\"0.5.9\\",\\"description\\":\\"Remote procedure calls for ImJoy.\\",\\"module\\":\\"index.js\\",\\"scripts\\":{\\"build\\":\\"rm -rf dist && npm run build-umd\\",\\"build-umd\\":\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\",\\"watch\\":\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\",\\"publish-npm\\":\\"npm install && npm run build && npm publish\\",\\"serve\\":\\"webpack-dev-server\\",\\"stats\\":\\"webpack --profile --json > stats.json\\",\\"stats-prod\\":\\"webpack --profile --json --mode production > stats-prod.json\\",\\"analyze\\":\\"webpack-bundle-analyzer -p 9999 stats.json\\",\\"analyze-prod\\":\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\",\\"clean\\":\\"rimraf dist/*\\",\\"deploy\\":\\"npm run build && node deploy-site.js\\",\\"format\\":\\"prettier --write \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"check-format\\":\\"prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"test\\":\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\",\\"test-watch\\":\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\"},\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\"},\\"keywords\\":[\\"imjoy\\",\\"rpc\\"],\\"author\\":\\"imjoy-team <imjoy.team@gmail.com>\\",\\"license\\":\\"MIT\\",\\"bugs\\":{\\"url\\":\\"https://github.com/imjoy-team/imjoy-rpc/issues\\"},\\"homepage\\":\\"https://github.com/imjoy-team/imjoy-rpc\\",\\"dependencies\\":{\\"@msgpack/msgpack\\":\\"^2.7.1\\",\\"socket.io-client\\":\\"^4.4.1\\"},\\"devDependencies\\":{\\"@babel/core\\":\\"^7.16.12\\",\\"@babel/plugin-syntax-dynamic-import\\":\\"^7.8.3\\",\\"@babel/polyfill\\":\\"^7.12.1\\",\\"@babel/preset-env\\":\\"^7.16.11\\",\\"@types/requirejs\\":\\"^2.1.34\\",\\"babel-core\\":\\"^6.26.0\\",\\"babel-eslint\\":\\"^10.1.0\\",\\"babel-loader\\":\\"^8.2.3\\",\\"babel-runtime\\":\\"^6.26.0\\",\\"chai\\":\\"^4.3.6\\",\\"clean-webpack-plugin\\":\\"^0.1.19\\",\\"copy-webpack-plugin\\":\\"^5.1.2\\",\\"eslint\\":\\"^6.8.0\\",\\"eslint-config-prettier\\":\\"^4.2.0\\",\\"eslint-loader\\":\\"^4.0.2\\",\\"file-loader\\":\\"^0.11.2\\",\\"fs-extra\\":\\"^0.30.0\\",\\"gh-pages\\":\\"^2.0.1\\",\\"html-loader\\":\\"^0.5.5\\",\\"html-webpack-plugin\\":\\"^3.2.0\\",\\"json-loader\\":\\"^0.5.4\\",\\"karma\\":\\"^6.3.12\\",\\"karma-chrome-launcher\\":\\"^3.1.0\\",\\"karma-firefox-launcher\\":\\"^1.3.0\\",\\"karma-mocha\\":\\"^1.3.0\\",\\"karma-sourcemap-loader\\":\\"^0.3.8\\",\\"karma-spec-reporter\\":\\"0.0.32\\",\\"karma-webpack\\":\\"^4.0.2\\",\\"lerna\\":\\"^3.22.1\\",\\"lodash.debounce\\":\\"^4.0.8\\",\\"mocha\\":\\"^7.2.0\\",\\"postcss\\":\\"^7.0.36\\",\\"prettier\\":\\"^1.6.1\\",\\"rimraf\\":\\"^2.6.2\\",\\"schema-utils\\":\\"^0.4.3\\",\\"style-loader\\":\\"^0.18.1\\",\\"url-loader\\":\\"^0.5.9\\",\\"webpack\\":\\"^4.46.0\\",\\"webpack-bundle-analyzer\\":\\"^3.9.0\\",\\"webpack-cli\\":\\"^3.3.12\\",\\"webpack-dev-server\\":\\"^3.11.3\\",\\"webpack-merge\\":\\"^4.1.1\\",\\"workbox-webpack-plugin\\":\\"^4.3.1\\",\\"worker-loader\\":\\"^2.0.0\\",\\"write-file-webpack-plugin\\":\\"^4.5.1\\"},\\"eslintConfig\\":{\\"globals\\":{\\"document\\":true,\\"window\\":true}}}");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\\
  !*** ./src/main.js ***!
  \\*********************/
/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitForInitialization", function() { return waitForInitialization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupRPC", function() { return setupRPC; });
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.webworker.js */ "./src/plugin.webworker.js");
/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginIframe.js */ "./src/pluginIframe.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirements"]; });

/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["RPC"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__["API_VERSION"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_4__["version"]; });

/**
 * Contains the code executed in the sandboxed frame under web-browser
 *
 * Tries to create a Web-Worker inside the frame and set up the
 * communication between the worker and the parent window. Some
 * browsers restrict creating a worker inside a sandboxed iframe - if
 * this happens, the plugin initialized right inside the frame (in the
 * same thread)
 */







function _inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

function _inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
/**
 * Initializes the plugin inside a web worker. May throw an exception
 * in case this was not permitted by the browser.
 */


function setupWebWorker(config) {
  if (!config.allow_execution) throw new Error("web-worker plugin can only work with allow_execution=true");
  let broadcastChannel = null;

  if (config.broadcastChannel) {
    broadcastChannel = new BroadcastChannel(config.broadcastChannel);
  }

  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker
  // initialization without exception, handling this with timeout

  const fallbackTimeout = setTimeout(function () {
    worker.terminate();
    console.warn(\`Plugin failed to start as a web-worker, running in an iframe instead.\`);
    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
  }, 2000);
  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])(); // forwarding messages between the worker and parent window

  worker.addEventListener("message", function (e) {
    let transferables = undefined;
    const m = e.data;

    if (m.type === "worker-ready") {
      // send config to the worker
      worker.postMessage({
        type: "connectRPC",
        config: config
      });
      clearTimeout(fallbackTimeout);
      return;
    } else if (m.type === "initialized") {
      // complete the missing fields
      m.config = Object.assign({}, config, m.config);
      m.origin = window.location.origin;
      m.peer_id = peer_id;
    } else if (m.type === "imjoy_remote_api_ready") {
      // if it's a webworker, there will be no api object returned
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: null
      }));
    } else if (m.type === "cacheRequirements" && typeof cache_requirements === "function") {
      cache_requirements(m.requirements);
    } else if (m.type === "disconnect") {
      worker.terminate();
    } else {
      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }
    }

    if (broadcastChannel) broadcastChannel.postMessage(m);else parent.postMessage(m, config.target_origin || "*", transferables);
  });
  (broadcastChannel || window).addEventListener("message", function (e) {
    if (e.type === "message" && (broadcastChannel || config.target_origin === "*" || e.origin === config.target_origin)) {
      let transferables = undefined;
      const m = e.data;

      if (m.__transferables__) {
        transferables = m.__transferables__;
        delete m.__transferables__;
      }

      if (m.peer_id === peer_id) {
        worker.postMessage(m, transferables);
      } else if (config.debug) {
        console.log(\`connection peer id mismatch \${m.peer_id} !== \${peer_id}\`);
      }
    }
  });
}

function waitForInitialization(config) {
  if (_inWebWorker()) {
    globalThis.parent = self;
  }

  config = config || {};

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
    config.enable_service_worker = false;
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  const targetOrigin = config.target_origin || "*";

  if (config.credential_required && typeof config.verify_credential !== "function") {
    throw new Error("Please also provide the \`verify_credential\` function with \`credential_required\`.");
  }

  if (config.credential_required && targetOrigin === "*") {
    throw new Error("\`target_origin\` was set to \`*\` with \`credential_required=true\`, there is a security risk that you may leak the credential to website from other origin. Please specify the \`target_origin\` explicitly.");
  }

  const done = () => {
    globalThis.removeEventListener("message", handleEvent);
  };

  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();

  const handleEvent = e => {
    if (e.type === "message" && (!e.origin || targetOrigin === "*" || e.origin === targetOrigin)) {
      if (e.data.type === "initialize") {
        done();

        if (e.data.peer_id !== peer_id) {
          // TODO: throw an error when we are sure all the peers will send the peer_id
          console.warn(\`\${e.data.config && e.data.config.name}: connection peer id mismatch \${e.data.peer_id} !== \${peer_id}\`);
        }

        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client
        // otherwise take the setting from the core

        if (targetOrigin !== "*") {
          cfg.target_origin = targetOrigin;
        }

        if (config.credential_required) {
          config.verify_credential(cfg.credential).then(result => {
            if (result && result.auth && !result.error) {
              // pass the authentication information with tokens
              cfg.auth = result.auth;
              setupRPC(cfg).then(() => {
                console.log("ImJoy RPC loaded successfully!");
              });
            } else {
              throw new Error("Failed to verify the credentail:" + (result && result.error));
            }
          });
        } else {
          setupRPC(cfg).then(() => {
            console.log("ImJoy RPC loaded successfully!");
          });
        }
      } else {
        throw new Error(\`unrecognized message: \${e.data}\`);
      }
    }
  };

  globalThis.addEventListener("message", handleEvent);

  if (_inWebWorker()) {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    });
  } else {
    parent.postMessage({
      type: "imjoyRPCReady",
      config: config,
      peer_id: peer_id
    }, "*");
  }
}
function setupRPC(config) {
  config = config || {};
  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["normalizeConfig"])(config);

  if (config.enable_service_worker) {
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["setupServiceWorker"])(config.base_url, config.target_origin, config.cache_requirements);
  }

  if (config.cache_requirements) {
    delete config.cache_requirements;
  }

  return new Promise((resolve, reject) => {
    const handleEvent = e => {
      const api = e.detail;

      if (config.expose_api_globally) {
        globalThis.api = api;
      } // imjoy plugin api


      resolve(api);
      globalThis.removeEventListener("imjoy_remote_api_ready", handleEvent);
    };

    if (_inIframe()) {
      if (config.type === "web-worker") {
        try {
          setupWebWorker(config);
        } catch (e) {
          // fallback to iframe
          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
        }
      } else if (["rpc-window", "rpc-worker", "iframe", "window"].includes(config.type)) {
        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
      } else {
        console.error("Unsupported plugin type: " + config.type);
        reject("Unsupported plugin type: " + config.type);
        return;
      }

      globalThis.addEventListener("imjoy_remote_api_ready", handleEvent);
    } else if (_inWebWorker()) {
      // inside a webworker
      Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__["default"])(config);
    } else {
      reject(new Error("imjoy-rpc should only run inside an iframe or a webworker."));
    }
  });
}

/***/ }),

/***/ "./src/plugin.webworker.js":
/*!*********************************!*\\
  !*** ./src/plugin.webworker.js ***!
  \\*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\"\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\"./src/plugin.webworker.js\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\"./src/plugin.webworker.js\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\"./src/pluginCore.js\\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \\"undefined\\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\\"This script can only loaded in a webworker\\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \\"data:text/javascript;charset=utf-8,\\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"MessageEmitter\\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\\"message\\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \\"initialized\\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\\"beforeDisconnect\\");\\n    self.close();\\n    this._fire(\\"disconnected\\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \\"requirements\\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\\"loadRequirementsInWebworker\\"])(code.requirements);\\n    } else if (code.type === \\"script\\") {\\n      try {\\n        if (code.attrs.type === \\"module\\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \\"unsupported code type.\\";\\n    }\\n    if (code.type === \\"requirements\\") {\\n      self.postMessage({\\n        type: \\"cacheRequirements\\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \\"web-worker\\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \\"javascript\\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\"API_VERSION\\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\\"connectRPC\\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\"connectRPC\\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \\"worker-ready\\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \\"./src/pluginCore.js\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"connectRPC\\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\"./src/rpc.js\\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\"RPC\\"](connection, config, codecs);\\n  rpc.on(\\"getInterface\\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\\"remoteReady\\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\\"name\\"] || !config[\\"encoder\\"] && !config[\\"decoder\\"]) {\\n        throw new Error(\\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\\"Remove duplicated codec: \\" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\\"name\\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \\"imjoy_remote_api_ready\\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\\"imjoy_remote_api_ready\\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \\"function\\") {\\n      const msg = \\"A function may only be subsribed to the event, \\" + type + \\" was provided instead\\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/rpc.js\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"API_VERSION\\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"RPC\\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\"./src/utils.js\\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \\"0.2.3\\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\\"undefined index\\");\\n  if (typeof is === \\"string\\") return indexObject(obj, is.split(\\".\\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"MessageEmitter\\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(\`connection.execute not implemented (in \\"\${name}\\")\`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\\"remoteIdle\\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\\"remoteBusy\\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \\"initialized\\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\\"interfaceAvailable\\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\\"interfaceSetAsRemote\\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\\"interface is not set.\\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \\"setInterface\\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(\`Object (id=\${objectId}) not found.\`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\\"disposed\\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \\"disposeObject\\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\\"Invalid object\\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\\"init\\", this.init);\\n\\n    this._connection.on(\\"execute\\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \\"executed\\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"executed\\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\\"method\\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\\".\\")) {\\n          const tmp = data.name.split(\\".\\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\\".\\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"callback\\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\"AsyncFunction\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\"disposeObject\\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\"disposed\\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"setInterface\\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\\"getInterface\\", () => {\\n      this._fire(\\"getInterface\\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\\"interfaceAvailable\\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\"interfaceSetAsRemote\\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\\"interfaceSetAsRemote\\");\\n    });\\n\\n    this._connection.on(\\"disconnect\\", () => {\\n      this._fire(\\"beforeDisconnect\\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\\"disconnected\\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \\"getInterface\\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \\"dtype doesn't match the type of the array: \\" + _dtype + \\" != \\" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \\"ndarray\\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\\"remoteReady\\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \\"/\\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \\"register\\" || name === \\"registerService\\" || name === \\"register_service\\" || name === \\"export\\" || name === \\"on\\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \\"method\\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \\"interfaceSetAsRemote\\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \\"number\\" || aType === \\"string\\" || aType === \\"boolean\\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \\"function\\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\\"objectId is not specified.\\");\\n        bObject = {\\n          _rtype: \\"interface\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \\"callback\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \\"undefined\\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \\"undefined\\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"ndarray\\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \\"error\\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \\"undefined\\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \\"undefined\\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \\"undefined\\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \\"undefined\\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \\"undefined\\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \\"undefined\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\"file\\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \\"blob\\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"typedArrayToDtype\\"])(aObject);\\n      bObject = {\\n        _rtype: \\"typedarray\\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\"memoryview\\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \\"set\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \\"orderedmap\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\\"Please instantiate the class before exportting it.\\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\\"Unsupported interface type\\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \\"string\\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \\"constructor\\") continue;\\n\\n          if (k.startsWith(\\"_\\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \\"string\\" ? asInterface + \\".\\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \\"function\\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \\"function\\") {\\n          aObject.on(\\"close\\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \\"object\\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"randId\\"])();\\n\\n      for (let k of keys) {\\n        if ([\\"hasOwnProperty\\", \\"constructor\\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \\"imjoy-rpc: Unsupported data type:\\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\\"Failed to encode object\\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\\"_rtype\\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \\"callback\\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \\"interface\\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \\"ndarray\\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \\"undefined\\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \\"undefined\\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \\"error\\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \\"file\\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \\"typedarray\\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\"dtypeToTypedArray\\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\\"unsupported dtype: \\" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \\"memoryview\\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \\"blob\\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \\"orderedmap\\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \\"set\\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\\"Failed to decode object\\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \\"callback\\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\"object\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \\"callback\\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \\"disconnect\\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \\"./src/utils.js\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\"use strict\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"randId\\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"dtypeToTypedArray\\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWindow\\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirementsInWebworker\\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"loadRequirements\\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"normalizeConfig\\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtypeMapping\\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"typedArrayToDtype\\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"cacheRequirements\\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"setupServiceWorker\\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"urlJoin\\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\"MessageEmitter\\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\\"script\\");\\n      scriptTag.src = url;\\n      scriptTag.type = \\"text/javascript\\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \\"loaded\\" || this.readyState === \\"complete\\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \\"string\\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n            if (requirements[i].startsWith(\\"css:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\\"link\\");\\n            link_node.rel = \\"stylesheet\\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".mjs\\") || requirements[i].startsWith(\\"mjs:\\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\\"mjs:\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n            if (requirements[i].startsWith(\\"js:\\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"http\\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n          } else {\\n            console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \\"unsupported requirements definition\\";\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\"string\\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\\".css\\") || requirements[i].startsWith(\\"css:\\")) {\\n          throw \\"unable to import css in a webworker\\";\\n        } else if (requirements[i].toLowerCase().endsWith(\\".js\\") || requirements[i].startsWith(\\"js:\\")) {\\n          if (requirements[i].startsWith(\\"js:\\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"http\\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\"cache:\\")) {//ignore cache\\n        } else {\\n          console.log(\\"Unprocessed requirements url: \\" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \\"failed to import required scripts: \\" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \\"undefined\\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \\"0.1.0\\";\\n  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;\\n  config.type = config.type || \\"rpc-window\\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \\"*\\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \\"function\\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \\"int8\\",\\n  Int16Array: \\"int16\\",\\n  Int32Array: \\"int32\\",\\n  Uint8Array: \\"uint8\\",\\n  Uint16Array: \\"uint16\\",\\n  Uint32Array: \\"uint32\\",\\n  Float32Array: \\"float32\\",\\n  Float64Array: \\"float64\\",\\n  Array: \\"array\\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \\"add\\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\\"Service worker is not supported.\\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\\"Service worker controller is not available\\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\\"js:\\")) req = req.slice(3);\\n    if (req.startsWith(\\"css:\\")) req = req.slice(4);\\n    if (req.startsWith(\\"cache:\\")) req = req.slice(6);\\n    if (!req.startsWith(\\"http\\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\\"serviceWorker\\" in navigator) {\\n    baseUrl = baseUrl || \\"/\\";\\n    navigator.serviceWorker.register(baseUrl + \\"plugin-service-worker.js\\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\\"ServiceWorker registration successful with scope: \\", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\\"ServiceWorker registration failed: \\", err);\\n    });\\n    targetOrigin = targetOrigin || \\"*\\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \\"function\\") {\\n      throw new Error(\\"config.cache_requirements must be a function\\");\\n    }\\n\\n    window.addEventListener(\\"message\\", function (e) {\\n      if (targetOrigin === \\"*\\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \\"cacheRequirements\\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\\"/\\").replace(/[\\\\/]+/g, \\"/\\").replace(/^(.+):\\\\//, \\"$1://\\").replace(/^file:/, \\"file:/\\").replace(/\\\\/(\\\\?|&|#[^!])/g, \\"$1\\").replace(/\\\\?/g, \\"&\\").replace(\\"&\\", \\"?\\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\\"emit is not implemented\\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\\"unhandled event\\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map", null);
};

/***/ }),

/***/ "./src/pluginCore.js":
/*!***************************!*\\
  !*** ./src/pluginCore.js ***!
  \\***************************/
/*! exports provided: connectRPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectRPC", function() { return connectRPC; });
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/**
 * Core plugin script loaded into the plugin process/thread.
 *
 * Initializes the plugin-site API global methods.
 */

function connectRPC(connection, config) {
  config = config || {};
  const codecs = {};
  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__["RPC"](connection, config, codecs);
  rpc.on("getInterface", function () {
    launchConnected();
  });
  rpc.on("remoteReady", function () {
    const api = rpc.getRemote() || {};

    api.registerCodec = function (config) {
      if (!config["name"] || !config["encoder"] && !config["decoder"]) {
        throw new Error("Invalid codec format, please make sure you provide a name, type, encoder and decoder.");
      } else {
        if (config.type) {
          for (let k of Object.keys(codecs)) {
            if (codecs[k].type === config.type || k === config.name) {
              delete codecs[k];
              console.warn("Remove duplicated codec: " + k);
            }
          }
        }

        codecs[config["name"]] = config;
      }
    };

    api.init = function (config) {
      // register a minimal plugin api
      rpc.setInterface({
        setup() {}

      }, config);
    };

    api.disposeObject = function (obj) {
      rpc.disposeObject(obj);
    };

    api.export = function (_interface, config) {
      rpc.setInterface(_interface, config);
    };

    api.onLoad = function (handler) {
      handler = checkHandler(handler);

      if (connected) {
        handler();
      } else {
        connectedHandlers.push(handler);
      }
    };

    api.dispose = function (_interface) {
      rpc.disconnect();
    };

    api._rpc = rpc;

    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
      self.api = api;
      self.postMessage({
        type: "imjoy_remote_api_ready"
      });
      self.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    } else if (typeof window) {
      window.dispatchEvent(new CustomEvent("imjoy_remote_api_ready", {
        detail: api
      }));
    }
  });
  let connected = false;
  const connectedHandlers = [];

  const launchConnected = function () {
    if (!connected) {
      connected = true;
      let handler;

      while (handler = connectedHandlers.pop()) {
        handler();
      }
    }
  };

  const checkHandler = function (handler) {
    const type = typeof handler;

    if (type !== "function") {
      const msg = "A function may only be subsribed to the event, " + type + " was provided instead";
      throw new Error(msg);
    }

    return handler;
  };

  return rpc;
}

/***/ }),

/***/ "./src/pluginIframe.js":
/*!*****************************!*\\
  !*** ./src/pluginIframe.js ***!
  \\*****************************/
/*! exports provided: Connection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return setupIframe; });
/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ "./src/pluginCore.js");
/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ "./src/rpc.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the routines loaded by the plugin iframe under web-browser
 * in case when worker failed to initialize
 *
 * Initializes the web environment version of the platform-dependent
 * connection object for the plugin site
 */


 // Create a new, plain <span> element

function _htmlToElement(html) {
  var template = document.createElement("template");
  html = html.trim(); // Never return a text node of whitespace as the result

  template.innerHTML = html;
  return template.content.firstChild;
}

const _inWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;

async function executeEsModule(content) {
  const dataUri = "data:text/javascript;charset=utf-8," + encodeURIComponent(content);
  await import(
  /* webpackIgnore: true */
  dataUri);
}

class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__["MessageEmitter"] {
  constructor(config) {
    super(config && config.debug);
    this.config = config || {};
    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["randId"])();
  }

  connect() {
    this.config.target_origin = this.config.target_origin || "*"; // this will call handleEvent function

    if (this.config.broadcastChannel) {
      this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);
    } else {
      this.broadcastChannel = null;
    }

    if (this.broadcastChannel) this.broadcastChannel.addEventListener("message", this);else globalThis.addEventListener("message", this);
    this.emit({
      type: "initialized",
      config: this.config,
      origin: globalThis.location.origin,
      peer_id: this.peer_id
    });

    this._fire("connected");
  }

  handleEvent(e) {
    if (e.type === "message" && (this.broadcastChannel || this.config.target_origin === "*" || !e.origin || e.origin === this.config.target_origin)) {
      if (e.data.peer_id === this.peer_id) {
        this._fire(e.data.type, e.data);
      } else if (this.config.debug) {
        console.log(\`connection peer id mismatch \${e.data.peer_id} !== \${this.peer_id}\`);
      }
    }
  }

  disconnect() {
    this._fire("beforeDisconnect");

    globalThis.removeEventListener("message", this);

    this._fire("disconnected");
  }

  emit(data) {
    let transferables;
    if (this.broadcastChannel) this.broadcastChannel.postMessage(data);else {
      if (data.__transferables__) {
        transferables = data.__transferables__;
        delete data.__transferables__;
      } else if (_inWebWorker) self.postMessage(data, transferables);else parent.postMessage(data, this.config.target_origin, transferables);
    }
  }

  async execute(code) {
    try {
      if (code.type === "requirements") {
        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["loadRequirementsInWindow"])(code.requirements);
      } else if (code.type === "script") {
        if (code.src) {
          var script_node = document.createElement("script");
          script_node.setAttribute("type", code.attrs.type);
          script_node.setAttribute("src", code.src);
          document.head.appendChild(script_node);
        } else {
          if (code.content && code.attrs.lang === "javascript") {
            // document.addEventListener("DOMContentLoaded", function(){
            if (code.attrs.type === "module") {
              await executeEsModule(code.content);
            } else {
              eval(code.content);
            } // });

          } else {
            var node = document.createElement("script");

            for (let k in code.attrs) {
              node.setAttribute(k, code.attrs[k]);
            }

            node.appendChild(document.createTextNode(code.content));
            document.body.appendChild(node);
          }
        }
      } else if (code.type === "style") {
        const style_node = document.createElement("style");

        if (code.src) {
          style_node.src = code.src;
        }

        style_node.innerHTML = code.content;
        document.head.appendChild(style_node);
      } else if (code.type === "link") {
        const link_node_ = document.createElement("link");

        if (code.rel) {
          link_node_.rel = code.rel;
        }

        if (code.href) {
          link_node_.href = code.href;
        }

        if (code.attrs && code.attrs.type) {
          link_node_.type = code.attrs.type;
        }

        document.head.appendChild(link_node_);
      } else if (code.type === "html") {
        document.body.appendChild(_htmlToElement(code.content));
      } else {
        throw "unsupported code type.";
      }

      if (_inWebWorker) self.postMessage({
        type: "executed"
      });else parent.postMessage({
        type: "executed"
      }, this.config.target_origin);
    } catch (e) {
      console.error("failed to execute scripts: ", code, e);
      if (_inWebWorker) self.postMessage({
        type: "executed",
        error: e.stack || String(e)
      });else parent.postMessage({
        type: "executed",
        error: e.stack || String(e)
      }, this.config.target_origin);
    }
  }

}
function setupIframe(config) {
  config = config || {};
  config.dedicated_thread = false;
  config.lang = "javascript";
  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__["API_VERSION"];
  const conn = new Connection(config);
  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__["connectRPC"])(conn, config);
  conn.connect();
}

/***/ }),

/***/ "./src/rpc.js":
/*!********************!*\\
  !*** ./src/rpc.js ***!
  \\********************/
/*! exports provided: API_VERSION, RPC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_VERSION", function() { return API_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RPC", function() { return RPC; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * Contains the RPC object used both by the application
 * site, and by each plugin
 */

const API_VERSION = "0.2.3";
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;

function _appendBuffer(buffer1, buffer2) {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
}

function indexObject(obj, is) {
  if (!is) throw new Error("undefined index");
  if (typeof is === "string") return indexObject(obj, is.split("."));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));
}
/**
 * RPC object represents a single site in the
 * communication protocol between the application and the plugin
 *
 * @param {Object} connection a special object allowing to send
 * and receive messages from the opposite site (basically it
 * should only provide send() and onMessage() methods)
 */


class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(connection, config, codecs) {
    super(config && config.debug);
    this._connection = connection;
    this.config = config || {};
    this._codecs = codecs || {};
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._remote_set = false; // make sure there is an execute function

    const name = this.config.name;

    this._connection.execute = this._connection.execute || function () {
      throw new Error(\`connection.execute not implemented (in "\${name}")\`);
    };

    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();

    this._method_refs.onReady(() => {
      this._fire("remoteIdle");
    });

    this._method_refs.onBusy(() => {
      this._fire("remoteBusy");
    });

    this._setupMessageHanlders();
  }

  init() {
    this._connection.emit({
      type: "initialized",
      config: this.config,
      peer_id: this._connection.peer_id
    });
  }

  setConfig(config) {
    if (config) for (const k of Object.keys(config)) {
      this.config[k] = config[k];
    }
  }
  /**
   * Set a handler to be called when received a responce from the
   * remote site reporting that the previously provided interface
   * has been successfully set as remote for that site
   *
   * @param {Function} handler
   */


  getRemoteCallStack() {
    return this._method_refs.getStack();
  }
  /**
   * @returns {Object} set of remote interface methods
   */


  getRemote() {
    return this._remote_interface;
  }
  /**
   * Sets the interface of this site making it available to the
   * remote site by sending a message with a set of methods names
   *
   * @param {Object} _interface to set
   */


  setInterface(_interface, config) {
    config = config || {};
    this.config.name = config.name || this.config.name;
    this.config.description = config.description || this.config.description;

    if (this.config.forwarding_functions) {
      for (let func_name of this.config.forwarding_functions) {
        const _remote = this._remote_interface;

        if (_remote[func_name]) {
          if (_interface.constructor === Object) {
            if (!_interface[func_name]) {
              _interface[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          } else if (_interface.constructor.constructor === Function) {
            if (!_interface.constructor.prototype[func_name]) {
              _interface.constructor.prototype[func_name] = (...args) => {
                _remote[func_name](...args);
              };
            }
          }
        }
      }
    }

    this._local_api = _interface;
    if (!this._remote_set) this._fire("interfaceAvailable");else this.sendInterface();
    return new Promise(resolve => {
      this.once("interfaceSetAsRemote", resolve);
    });
  }
  /**
   * Sends the actual interface to the remote site upon it was
   * updated or by a special request of the remote site
   */


  sendInterface() {
    if (!this._local_api) {
      throw new Error("interface is not set.");
    }

    this._encode(this._local_api, true).then(api => {
      this._connection.emit({
        type: "setInterface",
        api: api
      });
    });
  }

  _disposeObject(objectId) {
    if (this._object_store[objectId]) {
      delete this._object_store[objectId];
    } else {
      throw new Error(\`Object (id=\${objectId}) not found.\`);
    }
  }

  disposeObject(obj) {
    return new Promise((resolve, reject) => {
      if (this._object_weakmap.has(obj)) {
        const objectId = this._object_weakmap.get(obj);

        this._connection.once("disposed", data => {
          if (data.error) reject(new Error(data.error));else resolve();
        });

        this._connection.emit({
          type: "disposeObject",
          object_id: objectId
        });
      } else {
        throw new Error("Invalid object");
      }
    });
  }
  /**
   * Handles a message from the remote site
   */


  _setupMessageHanlders() {
    this._connection.on("init", this.init);

    this._connection.on("execute", data => {
      Promise.resolve(this._connection.execute(data.code)).then(() => {
        this._connection.emit({
          type: "executed"
        });
      }).catch(e => {
        console.error(e);

        this._connection.emit({
          type: "executed",
          error: String(e)
        });
      });
    });

    this._connection.on("method", async data => {
      let resolve, reject, method, method_this, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        const _interface = this._object_store[data.object_id];
        method = indexObject(_interface, data.name);

        if (data.name.includes(".")) {
          const tmp = data.name.split(".");
          const intf_index = tmp.slice(0, tmp.length - 1).join(".");
          method_this = indexObject(_interface, intf_index);
        } else {
          method_this = _interface;
        }

        args = await this._unwrap(data.args, true);

        if (data.promise) {
          result = method.apply(method_this, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method.apply(method_this, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("callback", async data => {
      let resolve, reject, method, args, result;

      try {
        if (data.promise) {
          [resolve, reject] = await this._unwrap(data.promise, false);
        }

        if (data.promise) {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          result = method.apply(null, args);

          if (result instanceof Promise || method.constructor && method.constructor.name === "AsyncFunction") {
            result.then(resolve).catch(reject);
          } else {
            resolve(result);
          }
        } else {
          method = this._store.fetch(data.id);
          args = await this._unwrap(data.args, true);

          if (!method) {
            throw new Error("Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.");
          }

          method.apply(null, args);
        }
      } catch (err) {
        console.error(this.config.name, err);

        if (reject) {
          reject(err);
        }
      }
    });

    this._connection.on("disposeObject", data => {
      try {
        this._disposeObject(data.object_id);

        this._connection.emit({
          type: "disposed"
        });
      } catch (e) {
        console.error(e);

        this._connection.emit({
          type: "disposed",
          error: String(e)
        });
      }
    });

    this._connection.on("setInterface", data => {
      this._setRemoteInterface(data.api);
    });

    this._connection.on("getInterface", () => {
      this._fire("getInterface");

      if (this._local_api) {
        this.sendInterface();
      } else {
        this.once("interfaceAvailable", () => {
          this.sendInterface();
        });
      }
    });

    this._connection.on("interfaceSetAsRemote", () => {
      this._remote_set = true;

      this._fire("interfaceSetAsRemote");
    });

    this._connection.on("disconnect", () => {
      this._fire("beforeDisconnect");

      this._connection.disconnect();

      this._fire("disconnected");
    });
  }
  /**
   * Sends a requests to the remote site asking it to provide its
   * current interface
   */


  requestRemote() {
    this._connection.emit({
      type: "getInterface"
    });
  }

  _ndarray(typedArray, shape, dtype) {
    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(typedArray);

    if (dtype && dtype !== _dtype) {
      throw "dtype doesn't match the type of the array: " + _dtype + " != " + dtype;
    }

    shape = shape || [typedArray.length];
    return {
      _rtype: "ndarray",
      _rvalue: typedArray.buffer,
      _rshape: shape,
      _rdtype: _dtype
    };
  }
  /**
   * Sets the new remote interface provided by the other site
   *
   * @param {Array} names list of function names
   */


  _setRemoteInterface(api) {
    this._decode(api).then(intf => {
      // update existing interface instead of recreating it
      // this will preserve the object reference
      if (this._remote_interface) {
        // clear the interface
        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces


        Object.assign(this._remote_interface, intf);
      } else this._remote_interface = intf;

      this._fire("remoteReady");

      this._reportRemoteSet();
    });
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * method. When the generated function is called, it will send the
   * corresponding message to the remote site asking it to execute
   * the particular method of its interface
   *
   * @param {String} name of the remote method
   *
   * @returns {Function} wrapped remote method
   */


  _genRemoteMethod(targetId, name, objectId) {
    const me = this;

    const remoteMethod = function () {
      return new Promise(async (resolve, reject) => {
        let id = null;

        try {
          id = me._method_refs.put(objectId ? objectId + "/" + name : name);

          const wrapped_resolve = function () {
            if (id !== null) me._method_refs.fetch(id);
            return resolve.apply(this, arguments);
          };

          const wrapped_reject = function () {
            if (id !== null) me._method_refs.fetch(id);
            return reject.apply(this, arguments);
          };

          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together

          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;
          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;
          let args = Array.prototype.slice.call(arguments);
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;

          if (name === "register" || name === "registerService" || name === "register_service" || name === "export" || name === "on") {
            args = await me._wrap(args, true);
          } else {
            args = await me._wrap(args);
          }

          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;

          me._connection.emit({
            type: "method",
            target_id: targetId,
            name: name,
            object_id: objectId,
            args: args,
            promise: encodedPromise,
            with_kwargs: withKwargs
          }, transferables);
        } catch (e) {
          if (id) me._method_refs.fetch(id);
          reject(\`Failed to exectue remote method (interface: \${objectId || me.id}, method: \${name}), error: \${e}\`);
        }
      });
    };

    remoteMethod.__remote_method = true;
    return remoteMethod;
  }
  /**
   * Sends a responce reporting that interface just provided by the
   * remote site was successfully set by this site as remote
   */


  _reportRemoteSet() {
    this._connection.emit({
      type: "interfaceSetAsRemote"
    });
  }
  /**
   * Prepares the provided set of remote method arguments for
   * sending to the remote site, replaces all the callbacks with
   * identifiers
   *
   * @param {Array} args to wrap
   *
   * @returns {Array} wrapped arguments
   */


  async _encode(aObject, asInterface, objectId) {
    const aType = typeof aObject;

    if (aType === "number" || aType === "string" || aType === "boolean" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {
      return aObject;
    }

    let bObject;

    if (typeof aObject === "function") {
      if (asInterface) {
        if (!objectId) throw new Error("objectId is not specified.");
        bObject = {
          _rtype: "interface",
          _rtarget_id: this._connection.peer_id,
          _rintf: objectId,
          _rvalue: asInterface
        };

        this._method_weakmap.set(aObject, bObject);
      } else if (this._method_weakmap.has(aObject)) {
        bObject = this._method_weakmap.get(aObject);
      } else {
        const cid = this._store.put(aObject);

        bObject = {
          _rtype: "callback",
          _rtarget_id: this._connection.peer_id,
          _rname: aObject.constructor && aObject.constructor.name || cid,
          _rvalue: cid
        };
      }

      return bObject;
    } // skip if already encoded


    if (aObject.constructor instanceof Object && aObject._rtype) {
      // make sure the interface functions are encoded
      if (aObject._rintf) {
        const temp = aObject._rtype;
        delete aObject._rtype;
        bObject = await this._encode(aObject, asInterface, objectId);
        bObject._rtype = temp;
      } else {
        bObject = aObject;
      }

      return bObject;
    }

    const transferables = [];
    const _transfer = aObject._transfer;
    const isarray = Array.isArray(aObject);

    for (let tp of Object.keys(this._codecs)) {
      const codec = this._codecs[tp];

      if (codec.encoder && aObject instanceof codec.type) {
        // TODO: what if multiple encoders found
        let encodedObj = await Promise.resolve(codec.encoder(aObject));
        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object

        if (encodedObj && encodedObj._rintf) {
          const temp = encodedObj._rtype;
          delete encodedObj._rtype;
          encodedObj = await this._encode(encodedObj, asInterface, objectId);
          encodedObj._rtype = temp;
        }

        bObject = encodedObj;
        return bObject;
      }
    }

    if (
    /*global tf*/
    typeof tf !== "undefined" && tf.Tensor && aObject instanceof tf.Tensor) {
      const v_buffer = aObject.dataSync();

      if (aObject._transfer || _transfer) {
        transferables.push(v_buffer.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: v_buffer.buffer,
        _rshape: aObject.shape,
        _rdtype: aObject.dtype
      };
    } else if (
    /*global nj*/
    typeof nj !== "undefined" && nj.NdArray && aObject instanceof nj.NdArray) {
      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject.selection.data);

      if (aObject._transfer || _transfer) {
        transferables.push(aObject.selection.data.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "ndarray",
        _rvalue: aObject.selection.data.buffer,
        _rshape: aObject.shape,
        _rdtype: dtype
      };
    } else if (aObject instanceof Error) {
      console.error(aObject);
      bObject = {
        _rtype: "error",
        _rvalue: aObject.toString()
      };
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } // send objects supported by structure clone algorithm
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== "undefined" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== "undefined" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== "undefined" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== "undefined" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== "undefined" && aObject instanceof FileSystemWritableFileStream) {
      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.
    } else if (typeof File !== "undefined" && aObject instanceof File) {
      bObject = {
        _rtype: "file",
        _rname: aObject.name,
        _rmime: aObject.type,
        _rvalue: aObject,
        _rpath: aObject._path || aObject.webkitRelativePath
      };
    } else if (aObject instanceof Blob) {
      bObject = {
        _rtype: "blob",
        _rvalue: aObject
      };
    } else if (aObject instanceof ArrayBufferView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["typedArrayToDtype"])(aObject);
      bObject = {
        _rtype: "typedarray",
        _rvalue: aObject.buffer,
        _rdtype: dtype
      };
    } else if (aObject instanceof DataView) {
      if (aObject._transfer || _transfer) {
        transferables.push(aObject.buffer);
        delete aObject._transfer;
      }

      bObject = {
        _rtype: "memoryview",
        _rvalue: aObject.buffer
      };
    } else if (aObject instanceof Set) {
      bObject = {
        _rtype: "set",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject instanceof Map) {
      bObject = {
        _rtype: "orderedmap",
        _rvalue: await this._encode(Array.from(aObject), asInterface)
      };
    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {
      bObject = isarray ? [] : {};
      let keys; // an object/array

      if (aObject.constructor === Object || Array.isArray(aObject)) {
        keys = Object.keys(aObject);
      } // a class
      else if (aObject.constructor === Function) {
        throw new Error("Please instantiate the class before exportting it.");
      } // instance of a class
      else if (aObject.constructor.constructor === Function) {
        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object
        // always encode class instance as interface

        asInterface = true;
      } else {
        throw Error("Unsupported interface type");
      }

      let hasFunction = false; // encode interfaces

      if (aObject._rintf || asInterface) {
        if (!objectId) {
          if (typeof aObject._rintf === "string" && aObject._rintf.length > 0) {
            objectId = aObject._rintf; // enable custom object id
          } else {
            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
          } // Note: object with the same id will be overwritten


          if (this._object_store[objectId]) console.warn(\`Overwritting interface object with the same id: \${objectId}\`);
          this._object_store[objectId] = aObject;
        }

        for (let k of keys) {
          if (k === "constructor") continue;

          if (k.startsWith("_")) {
            continue;
          }

          bObject[k] = await this._encode(aObject[k], typeof asInterface === "string" ? asInterface + "." + k : k, objectId);

          if (typeof aObject[k] === "function") {
            hasFunction = true;
          }
        } // object id for dispose the object remotely


        if (hasFunction) bObject._rintf = objectId; // remove interface when closed

        if (aObject.on && typeof aObject.on === "function") {
          aObject.on("close", () => {
            delete this._object_store[objectId];
          });
        }
      } else {
        for (let k of keys) {
          if (["hasOwnProperty", "constructor"].includes(k)) continue;
          bObject[k] = await this._encode(aObject[k]);
        }
      } // for example, browserFS object

    } else if (typeof aObject === "object") {
      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));
      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();

      for (let k of keys) {
        if (["hasOwnProperty", "constructor"].includes(k)) continue; // encode as interface

        bObject[k] = await this._encode(aObject[k], k, bObject);
      } // object id, used for dispose the object


      bObject._rintf = objectId;
    } else {
      throw "imjoy-rpc: Unsupported data type:" + aObject;
    }

    if (transferables.length > 0) {
      bObject.__transferables__ = transferables;
    }

    if (!bObject) {
      throw new Error("Failed to encode object");
    }

    return bObject;
  }

  async _decode(aObject, withPromise) {
    if (!aObject) {
      return aObject;
    }

    let bObject;

    if (aObject["_rtype"]) {
      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          aObject = await this._decode(aObject, withPromise);
          aObject._rtype = temp;
        }

        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));
      } else if (aObject._rtype === "callback") {
        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);
      } else if (aObject._rtype === "interface") {
        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);
      } else if (aObject._rtype === "ndarray") {
        /*global nj tf*/
        //create build array/tensor if used in the plugin
        if (typeof nj !== "undefined" && nj.array) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);
        } else if (typeof tf !== "undefined" && tf.Tensor) {
          if (Array.isArray(aObject._rvalue)) {
            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);
          }

          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);
        } else {
          //keep it as regular if transfered to the main app
          bObject = aObject;
        }
      } else if (aObject._rtype === "error") {
        bObject = new Error(aObject._rvalue);
      } else if (aObject._rtype === "file") {
        if (aObject._rvalue instanceof File) {
          bObject = aObject._rvalue; //patch _path

          bObject._path = aObject._rpath;
        } else {
          bObject = new File([aObject._rvalue], aObject._rname, {
            type: aObject._rmime
          });
          bObject._path = aObject._rpath;
        }
      } else if (aObject._rtype === "typedarray") {
        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__["dtypeToTypedArray"][aObject._rdtype];
        if (!arraytype) throw new Error("unsupported dtype: " + aObject._rdtype);
        bObject = new arraytype(aObject._rvalue);
      } else if (aObject._rtype === "memoryview") {
        bObject = new DataView(aObject._rvalue);
      } else if (aObject._rtype === "blob") {
        if (aObject._rvalue instanceof Blob) {
          bObject = aObject._rvalue;
        } else {
          bObject = new Blob([aObject._rvalue], {
            type: aObject._rmime
          });
        }
      } else if (aObject._rtype === "orderedmap") {
        bObject = new Map(await this._decode(aObject._rvalue, withPromise));
      } else if (aObject._rtype === "set") {
        bObject = new Set(await this._decode(aObject._rvalue, withPromise));
      } else {
        // make sure all the interface functions are decoded
        if (aObject._rintf) {
          const temp = aObject._rtype;
          delete aObject._rtype;
          bObject = await this._decode(aObject, withPromise);
          bObject._rtype = temp;
        } else bObject = aObject;
      }
    } else if (aObject.constructor === Object || Array.isArray(aObject)) {
      const isarray = Array.isArray(aObject);
      bObject = isarray ? [] : {};

      for (let k of Object.keys(aObject)) {
        if (isarray || aObject.hasOwnProperty(k)) {
          const v = aObject[k];
          bObject[k] = await this._decode(v, withPromise);
        }
      }
    } else {
      bObject = aObject;
    }

    if (bObject === undefined) {
      throw new Error("Failed to decode object");
    } // store the object id for dispose


    if (aObject._rintf) {
      this._object_weakmap.set(bObject, aObject._rintf);
    }

    return bObject;
  }

  async _wrap(args, asInterface) {
    return await this._encode(args, asInterface);
  }
  /**
   * Unwraps the set of arguments delivered from the remote site,
   * replaces all callback identifiers with a function which will
   * initiate sending that callback identifier back to other site
   *
   * @param {Object} args to unwrap
   *
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Array} unwrapped args
   */


  async _unwrap(args, withPromise) {
    return await this._decode(args, withPromise);
  }
  /**
   * Generates the wrapped function corresponding to a single remote
   * callback. When the generated function is called, it will send
   * the corresponding message to the remote site asking it to
   * execute the particular callback previously saved during a call
   * by the remote site a method from the interface of this site
   *
   * @param {Number} id of the remote callback to execute
   * @param {Number} argNum argument index of the callback
   * @param {Boolean} withPromise is true means this the callback should contain a promise
   *
   * @returns {Function} wrapped remote callback
   */


  _genRemoteCallback(targetId, cid, withPromise) {
    const me = this;
    let remoteCallback;

    if (withPromise) {
      remoteCallback = function () {
        return new Promise(async (resolve, reject) => {
          const args = await me._wrap(Array.prototype.slice.call(arguments));
          const argLength = args.length; // if the last argument is an object, mark it as kwargs

          const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
          if (withKwargs) delete args[argLength - 1]._rkwargs;
          const transferables = args.__transferables__;
          if (transferables) delete args.__transferables__;
          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together

          resolve.__promise_pair = encodedPromise[1]._rvalue;
          reject.__promise_pair = encodedPromise[0]._rvalue;

          try {
            me._connection.emit({
              type: "callback",
              target_id: targetId,
              id: cid,
              args: args,
              promise: encodedPromise,
              with_kwargs: withKwargs
            }, transferables);
          } catch (e) {
            reject(\`Failed to exectue remote callback ( id: \${cid}).\`);
          }
        });
      };

      return remoteCallback;
    } else {
      remoteCallback = async function () {
        const args = await me._wrap(Array.prototype.slice.call(arguments));
        const argLength = args.length; // if the last argument is an object, mark it as kwargs

        const withKwargs = argLength > 0 && typeof args[argLength - 1] === "object" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;
        if (withKwargs) delete args[argLength - 1]._rkwargs;
        const transferables = args.__transferables__;
        if (transferables) delete args.__transferables__;
        return me._connection.emit({
          type: "callback",
          target_id: targetId,
          id: cid,
          args: args,
          with_kwargs: withKwargs
        }, transferables);
      };

      return remoteCallback;
    }
  }

  reset() {
    this._event_handlers = {};
    this._once_handlers = {};
    this._remote_interface = null;
    this._object_store = {};
    this._method_weakmap = new WeakMap();
    this._object_weakmap = new WeakMap();
    this._local_api = null;
    this._store = new ReferenceStore();
    this._method_refs = new ReferenceStore();
  }
  /**
   * Sends the notification message and breaks the connection
   */


  disconnect() {
    this._connection.emit({
      type: "disconnect"
    });

    this.reset();
    setTimeout(() => {
      this._connection.disconnect();
    }, 2000);
  }

}
/**
 * ReferenceStore is a special object which stores other objects
 * and provides the references (number) instead. This reference
 * may then be sent over a json-based communication channel (IPC
 * to another Node.js process or a message to the Worker). Other
 * site may then provide the reference in the responce message
 * implying the given object should be activated.
 *
 * Primary usage for the ReferenceStore is a storage for the
 * callbacks, which therefore makes it possible to initiate a
 * callback execution by the opposite site (which normally cannot
 * directly execute functions over the communication channel).
 *
 * Each stored object can only be fetched once and is not
 * available for the second time. Each stored object must be
 * fetched, since otherwise it will remain stored forever and
 * consume memory.
 *
 * Stored object indeces are simply the numbers, which are however
 * released along with the objects, and are later reused again (in
 * order to postpone the overflow, which should not likely happen,
 * but anyway).
 */

class ReferenceStore {
  constructor() {
    this._store = {}; // stored object

    this._indices = [0]; // smallest available indices

    this._readyHandler = function () {};

    this._busyHandler = function () {};

    this._readyHandler();
  }
  /**
   * call handler when the store is empty
   *
   * @param {FUNCTION} id of a handler
   */


  onReady(readyHandler) {
    this._readyHandler = readyHandler || function () {};
  }
  /**
   * call handler when the store is not empty
   *
   * @param {FUNCTION} id of a handler
   */


  onBusy(busyHandler) {
    this._busyHandler = busyHandler || function () {};
  }
  /**
   * get the length of the store
   *
   */


  getStack() {
    return Object.keys(this._store).length;
  }
  /**
   * @function _genId() generates the new reference id
   *
   * @returns {Number} smallest available id and reserves it
   */


  _genId() {
    let id;

    if (this._indices.length === 1) {
      id = this._indices[0]++;
    } else {
      id = this._indices.shift();
    }

    return id;
  }
  /**
   * Releases the given reference id so that it will be available by
   * another object stored
   *
   * @param {Number} id to release
   */


  _releaseId(id) {
    for (let i = 0; i < this._indices.length; i++) {
      if (id < this._indices[i]) {
        this._indices.splice(i, 0, id);

        break;
      }
    } // cleaning-up the sequence tail


    for (let i = this._indices.length - 1; i >= 0; i--) {
      if (this._indices[i] - 1 === this._indices[i - 1]) {
        this._indices.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Stores the given object and returns the refernce id instead
   *
   * @param {Object} obj to store
   *
   * @returns {Number} reference id of the stored object
   */


  put(obj) {
    if (this._busyHandler && Object.keys(this._store).length === 0) {
      this._busyHandler();
    }

    const id = this._genId();

    this._store[id] = obj;
    return id;
  }
  /**
   * Retrieves previously stored object and releases its reference
   *
   * @param {Number} id of an object to retrieve
   */


  fetch(id) {
    const obj = this._store[id];

    if (obj && !obj.__remote_method) {
      delete this._store[id];

      this._releaseId(id);

      if (this._readyHandler && Object.keys(this._store).length === 0) {
        this._readyHandler();
      }
    }

    if (obj && obj.__promise_pair) {
      this.fetch(obj.__promise_pair);
    }

    return obj;
  }

}

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\\
  !*** ./src/utils.js ***!
  \\**********************/
/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dtypeToTypedArray", function() { return dtypeToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWindow", function() { return loadRequirementsInWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirementsInWebworker", function() { return loadRequirementsInWebworker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRequirements", function() { return loadRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeConfig", function() { return normalizeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtypeMapping", function() { return typedArrayToDtypeMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typedArrayToDtype", function() { return typedArrayToDtype; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheRequirements", function() { return cacheRequirements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupServiceWorker", function() { return setupServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "urlJoin", function() { return urlJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
function randId() {
  return Math.random().toString(36).substr(2, 10) + new Date().getTime();
}
const dtypeToTypedArray = {
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  float32: Float32Array,
  float64: Float64Array,
  array: Array
};
async function loadRequirementsInWindow(requirements) {
  function _importScript(url) {
    //url is URL of external file, implementationCode is the code
    //to be called from the file, location is the location to
    //insert the <script> element
    return new Promise((resolve, reject) => {
      var scriptTag = document.createElement("script");
      scriptTag.src = url;
      scriptTag.type = "text/javascript";
      scriptTag.onload = resolve;

      scriptTag.onreadystatechange = function () {
        if (this.readyState === "loaded" || this.readyState === "complete") {
          resolve();
        }
      };

      scriptTag.onerror = reject;
      document.head.appendChild(scriptTag);
    });
  } // support importScripts outside web worker


  async function importScripts() {
    var args = Array.prototype.slice.call(arguments),
        len = args.length,
        i = 0;

    for (; i < len; i++) {
      await _importScript(args[i]);
    }
  }

  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      var link_node;
      requirements = typeof requirements === "string" ? [requirements] : requirements;

      if (Array.isArray(requirements)) {
        for (var i = 0; i < requirements.length; i++) {
          if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
            if (requirements[i].startsWith("css:")) {
              requirements[i] = requirements[i].slice(4);
            }

            link_node = document.createElement("link");
            link_node.rel = "stylesheet";
            link_node.href = requirements[i];
            document.head.appendChild(link_node);
          } else if (requirements[i].toLowerCase().endsWith(".mjs") || requirements[i].startsWith("mjs:")) {
            // import esmodule
            if (requirements[i].startsWith("mjs:")) {
              requirements[i] = requirements[i].slice(4);
            }

            await import(
            /* webpackIgnore: true */
            requirements[i]);
          } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
            if (requirements[i].startsWith("js:")) {
              requirements[i] = requirements[i].slice(3);
            }

            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("http")) {
            await importScripts(requirements[i]);
          } else if (requirements[i].startsWith("cache:")) {//ignore cache
          } else {
            console.log("Unprocessed requirements url: " + requirements[i]);
          }
        }
      } else {
        throw "unsupported requirements definition";
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
async function loadRequirementsInWebworker(requirements) {
  if (requirements && (Array.isArray(requirements) || typeof requirements === "string")) {
    try {
      if (!Array.isArray(requirements)) {
        requirements = [requirements];
      }

      for (var i = 0; i < requirements.length; i++) {
        if (requirements[i].toLowerCase().endsWith(".css") || requirements[i].startsWith("css:")) {
          throw "unable to import css in a webworker";
        } else if (requirements[i].toLowerCase().endsWith(".js") || requirements[i].startsWith("js:")) {
          if (requirements[i].startsWith("js:")) {
            requirements[i] = requirements[i].slice(3);
          }

          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("http")) {
          importScripts(requirements[i]);
        } else if (requirements[i].startsWith("cache:")) {//ignore cache
        } else {
          console.log("Unprocessed requirements url: " + requirements[i]);
        }
      }
    } catch (e) {
      throw "failed to import required scripts: " + requirements.toString();
    }
  }
}
function loadRequirements(requirements) {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return loadRequirementsInWebworker(requirements);
  } else {
    return loadRequirementsInWindow(requirements);
  }
}
function normalizeConfig(config) {
  config.version = config.version || "0.1.0";
  config.description = config.description || \`[TODO: add description for \${config.name} ]\`;
  config.type = config.type || "rpc-window";
  config.id = config.id || randId();
  config.target_origin = config.target_origin || "*";
  config.allow_execution = config.allow_execution || false; // remove functions

  config = Object.keys(config).reduce((p, c) => {
    if (typeof config[c] !== "function") p[c] = config[c];
    return p;
  }, {});
  return config;
}
const typedArrayToDtypeMapping = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};
const typedArrayToDtypeKeys = [];

for (const arrType of Object.keys(typedArrayToDtypeMapping)) {
  typedArrayToDtypeKeys.push(eval(arrType));
}

function typedArrayToDtype(obj) {
  let dtype = typedArrayToDtypeMapping[obj.constructor.name];

  if (!dtype) {
    const pt = Object.getPrototypeOf(obj);

    for (const arrType of typedArrayToDtypeKeys) {
      if (pt instanceof arrType) {
        dtype = typedArrayToDtypeMapping[arrType.name];
        break;
      }
    }
  }

  return dtype;
}

function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}

async function cacheRequirements(requirements) {
  requirements = requirements || [];

  if (!Array.isArray(requirements)) {
    requirements = [requirements];
  }

  for (let req of requirements) {
    //remove prefix
    if (req.startsWith("js:")) req = req.slice(3);
    if (req.startsWith("css:")) req = req.slice(4);
    if (req.startsWith("cache:")) req = req.slice(6);
    if (!req.startsWith("http")) continue;
    await cacheUrlInServiceWorker(req).catch(e => {
      console.error(e);
    });
  }
}
function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {
  // register service worker for offline access
  if ("serviceWorker" in navigator) {
    baseUrl = baseUrl || "/";
    navigator.serviceWorker.register(baseUrl + "plugin-service-worker.js").then(function (registration) {
      // Registration was successful
      console.log("ServiceWorker registration successful with scope: ", registration.scope);
    }, function (err) {
      // registration failed :(
      console.log("ServiceWorker registration failed: ", err);
    });
    targetOrigin = targetOrigin || "*";
    cacheCallback = cacheCallback || cacheRequirements;

    if (cacheCallback && typeof cacheCallback !== "function") {
      throw new Error("config.cache_requirements must be a function");
    }

    window.addEventListener("message", function (e) {
      if (targetOrigin === "*" || e.origin === targetOrigin) {
        const m = e.data;

        if (m.type === "cacheRequirements") {
          cacheCallback(m.requirements);
        }
      }
    });
  }
} //#Source https://bit.ly/2neWfJ2

function urlJoin(...args) {
  return args.join("/").replace(/[\\/]+/g, "/").replace(/^(.+):\\//, "$1://").replace(/^file:/, "file:/").replace(/\\/(\\?|&|#[^!])/g, "$1").replace(/\\?/g, "&").replace("&", "?");
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}

/***/ })

/******/ });
});
//# sourceMappingURL=imjoy-rpc.js.map

//# sourceURL=webpack://%5Bname%5D/./node_modules/imjoy-rpc/dist/imjoy-rpc.js?`)},"./node_modules/imjoy-rpc/index.js":function(module,exports,__webpack_require__){eval(`module.exports = {imjoyRPC: __webpack_require__(/*! ./dist/imjoy-rpc.js */ "./node_modules/imjoy-rpc/dist/imjoy-rpc.js"), imjoyRPCSocketIO: __webpack_require__(/*! ./dist/imjoy-rpc-socketio */ "./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js")};

//# sourceURL=webpack://%5Bname%5D/./node_modules/imjoy-rpc/index.js?`)},"./node_modules/immediate/lib/index.js":function(module,exports,__webpack_require__){eval(`
var types = [
  __webpack_require__(/*! ./nextTick */ 0),
  __webpack_require__(/*! ./queueMicrotask */ "./node_modules/immediate/lib/queueMicrotask.js"),
  __webpack_require__(/*! ./mutation.js */ "./node_modules/immediate/lib/mutation.js"),
  __webpack_require__(/*! ./messageChannel */ "./node_modules/immediate/lib/messageChannel.js"),
  __webpack_require__(/*! ./stateChange */ "./node_modules/immediate/lib/stateChange.js"),
  __webpack_require__(/*! ./timeout */ "./node_modules/immediate/lib/timeout.js")
];
var draining;
var currentQueue;
var queueIndex = -1;
var queue = [];
var scheduled = false;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    nextTick();
  }
}

//named nextTick for less confusing stack traces
function nextTick() {
  if (draining) {
    return;
  }
  scheduled = false;
  draining = true;
  var len = queue.length;
  var timeout = setTimeout(cleanUpNextTick);
  while (len) {
    currentQueue = queue;
    queue = [];
    while (currentQueue && ++queueIndex < len) {
      currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  queueIndex = -1;
  draining = false;
  clearTimeout(timeout);
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  var fun = this.fun;
  var array = this.array;
  switch (array.length) {
  case 0:
    return fun();
  case 1:
    return fun(array[0]);
  case 2:
    return fun(array[0], array[1]);
  case 3:
    return fun(array[0], array[1], array[2]);
  default:
    return fun.apply(null, array);
  }

};
module.exports = immediate;
function immediate(task) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(task, args));
  if (!scheduled && !draining) {
    scheduled = true;
    scheduleDrain();
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/index.js?`)},"./node_modules/immediate/lib/messageChannel.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/messageChannel.js?`)},"./node_modules/immediate/lib/mutation.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/mutation.js?`)},"./node_modules/immediate/lib/queueMicrotask.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {
exports.test = function () {
  return typeof global.queueMicrotask === 'function';
};

exports.install = function (func) {
  return function () {
    global.queueMicrotask(func);
  };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/queueMicrotask.js?`)},"./node_modules/immediate/lib/stateChange.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/stateChange.js?`)},"./node_modules/immediate/lib/timeout.js":function(module,exports,__webpack_require__){eval(`
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};

//# sourceURL=webpack://%5Bname%5D/./node_modules/immediate/lib/timeout.js?`)},"./node_modules/isarray/index.js":function(module,exports){eval(`var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/isarray/index.js?`)},"./node_modules/js-yaml/index.js":function(module,exports,__webpack_require__){eval(`


var yaml = __webpack_require__(/*! ./lib/js-yaml.js */ "./node_modules/js-yaml/lib/js-yaml.js");


module.exports = yaml;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/index.js?`)},"./node_modules/js-yaml/lib/js-yaml.js":function(module,exports,__webpack_require__){eval(`


var loader = __webpack_require__(/*! ./js-yaml/loader */ "./node_modules/js-yaml/lib/js-yaml/loader.js");
var dumper = __webpack_require__(/*! ./js-yaml/dumper */ "./node_modules/js-yaml/lib/js-yaml/dumper.js");


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = __webpack_require__(/*! ./js-yaml/type */ "./node_modules/js-yaml/lib/js-yaml/type.js");
module.exports.Schema              = __webpack_require__(/*! ./js-yaml/schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");
module.exports.FAILSAFE_SCHEMA     = __webpack_require__(/*! ./js-yaml/schema/failsafe */ "./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js");
module.exports.JSON_SCHEMA         = __webpack_require__(/*! ./js-yaml/schema/json */ "./node_modules/js-yaml/lib/js-yaml/schema/json.js");
module.exports.CORE_SCHEMA         = __webpack_require__(/*! ./js-yaml/schema/core */ "./node_modules/js-yaml/lib/js-yaml/schema/core.js");
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = __webpack_require__(/*! ./js-yaml/exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/failsafe */ "./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js");
module.exports.SAFE_SCHEMA    = __webpack_require__(/*! ./js-yaml/schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
module.exports.DEFAULT_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml.js?`)},"./node_modules/js-yaml/lib/js-yaml/common.js":function(module,exports,__webpack_require__){eval(`


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/common.js?`)},"./node_modules/js-yaml/lib/js-yaml/dumper.js":function(module,exports,__webpack_require__){eval(`

/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");
var DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");
var DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* \` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\\\0';
ESCAPE_SEQUENCES[0x07]   = '\\\\a';
ESCAPE_SEQUENCES[0x08]   = '\\\\b';
ESCAPE_SEQUENCES[0x09]   = '\\\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\\\e';
ESCAPE_SEQUENCES[0x22]   = '\\\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\\\_';
ESCAPE_SEQUENCES[0x2028] = '\\\\L';
ESCAPE_SEQUENCES[0x2029] = '\\\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | # | & | * | ! | | | > | ' | "
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | % | @ | \`)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \\n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \\n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\\n';
  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\\n+)([^\\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \\n.
  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \\n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\\n' + line.slice(start, end);
      // skip the space that was output as \\n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \\n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes \`object\` and writes it to global \`result\`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/dumper.js?`)},"./node_modules/js-yaml/lib/js-yaml/exception.js":function(module,exports,__webpack_require__){eval(`// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/exception.js?`)},"./node_modules/js-yaml/lib/js-yaml/loader.js":function(module,exports,__webpack_require__){eval(`

/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");
var Mark                = __webpack_require__(/*! ./mark */ "./node_modules/js-yaml/lib/js-yaml/mark.js");
var DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./schema/default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
var DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./schema/default_full */ "./node_modules/js-yaml/lib/js-yaml/schema/default_full.js");


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\\x00' :
        (c === 0x61/* a */) ? '\\x07' :
        (c === 0x62/* b */) ? '\\x08' :
        (c === 0x74/* t */) ? '\\x09' :
        (c === 0x09/* Tab */) ? '\\x09' :
        (c === 0x6E/* n */) ? '\\x0A' :
        (c === 0x76/* v */) ? '\\x0B' :
        (c === 0x66/* f */) ? '\\x0C' :
        (c === 0x72/* r */) ? '\\x0D' :
        (c === 0x65/* e */) ? '\\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \\ */) ? '\\x5C' :
        (c === 0x4E/* N */) ? '\\x85' :
        (c === 0x5F/* _ */) ? '\\xA0' :
        (c === 0x4C/* L */) ? '\\u2028' :
        (c === 0x50/* P */) ? '\\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* \` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \\ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\\n';
        }
      }

      // Break this \`while\` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of \`composeNode\`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of \`composeNode\`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // \`state.result\` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // \`state.result\` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing \`\\n\` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/loader.js?`)},"./node_modules/js-yaml/lib/js-yaml/mark.js":function(module,exports,__webpack_require__){eval(`


var common = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/mark.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema.js":function(module,exports,__webpack_require__){eval(`

/*eslint-disable max-len*/

var common        = __webpack_require__(/*! ./common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");
var Type          = __webpack_require__(/*! ./type */ "./node_modules/js-yaml/lib/js-yaml/type.js");


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/core.js":function(module,exports,__webpack_require__){eval(`// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./json */ "./node_modules/js-yaml/lib/js-yaml/schema/json.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/core.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/default_full.js":function(module,exports,__webpack_require__){eval(`// JS-YAML's default schema for \`load\` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at \`Schema.create\` function.





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __webpack_require__(/*! ./default_safe */ "./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js")
  ],
  explicit: [
    __webpack_require__(/*! ../type/js/undefined */ "./node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"),
    __webpack_require__(/*! ../type/js/regexp */ "./node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"),
    __webpack_require__(/*! ../type/js/function */ "./node_modules/js-yaml/lib/js-yaml/type/js/function.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/default_full.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js":function(module,exports,__webpack_require__){eval(`// JS-YAML's default schema for \`safeLoad\` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./core */ "./node_modules/js-yaml/lib/js-yaml/schema/core.js")
  ],
  implicit: [
    __webpack_require__(/*! ../type/timestamp */ "./node_modules/js-yaml/lib/js-yaml/type/timestamp.js"),
    __webpack_require__(/*! ../type/merge */ "./node_modules/js-yaml/lib/js-yaml/type/merge.js")
  ],
  explicit: [
    __webpack_require__(/*! ../type/binary */ "./node_modules/js-yaml/lib/js-yaml/type/binary.js"),
    __webpack_require__(/*! ../type/omap */ "./node_modules/js-yaml/lib/js-yaml/type/omap.js"),
    __webpack_require__(/*! ../type/pairs */ "./node_modules/js-yaml/lib/js-yaml/type/pairs.js"),
    __webpack_require__(/*! ../type/set */ "./node_modules/js-yaml/lib/js-yaml/type/set.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/default_safe.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js":function(module,exports,__webpack_require__){eval(`// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  explicit: [
    __webpack_require__(/*! ../type/str */ "./node_modules/js-yaml/lib/js-yaml/type/str.js"),
    __webpack_require__(/*! ../type/seq */ "./node_modules/js-yaml/lib/js-yaml/type/seq.js"),
    __webpack_require__(/*! ../type/map */ "./node_modules/js-yaml/lib/js-yaml/type/map.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js?`)},"./node_modules/js-yaml/lib/js-yaml/schema/json.js":function(module,exports,__webpack_require__){eval(`// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use \`Null\` and \`NULL\` as \`null\`, etc.





var Schema = __webpack_require__(/*! ../schema */ "./node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./failsafe */ "./node_modules/js-yaml/lib/js-yaml/schema/failsafe.js")
  ],
  implicit: [
    __webpack_require__(/*! ../type/null */ "./node_modules/js-yaml/lib/js-yaml/type/null.js"),
    __webpack_require__(/*! ../type/bool */ "./node_modules/js-yaml/lib/js-yaml/type/bool.js"),
    __webpack_require__(/*! ../type/int */ "./node_modules/js-yaml/lib/js-yaml/type/int.js"),
    __webpack_require__(/*! ../type/float */ "./node_modules/js-yaml/lib/js-yaml/type/float.js")
  ]
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/schema/json.js?`)},"./node_modules/js-yaml/lib/js-yaml/type.js":function(module,exports,__webpack_require__){eval(`

var YAMLException = __webpack_require__(/*! ./exception */ "./node_modules/js-yaml/lib/js-yaml/exception.js");

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/binary.js":function(module,exports,__webpack_require__){eval(`var require;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include \`Buffer\` shim
  var _require = require;
  NodeBuffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
} catch (__) {}

var Type       = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/binary.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/bool.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/bool.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/float.js":function(module,exports,__webpack_require__){eval(`

var common = __webpack_require__(/*! ../common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var Type   = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +
  // .inf
  '|[-+]?\\\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with \`_\`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/float.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/int.js":function(module,exports,__webpack_require__){eval(`

var common = __webpack_require__(/*! ../common */ "./node_modules/js-yaml/lib/js-yaml/common.js");
var Type   = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with \`_\`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with \`_\`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/int.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/js/function.js":function(module,exports,__webpack_require__){eval(`var require;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = __webpack_require__(/*! esprima */ "./node_modules/esprima/dist/esprima.js");
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(/*! ../../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/js/function.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/js/regexp.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // \`/foo/gim\` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\\/([gim]*)$/.exec(data),
      modifiers = '';

  // \`/foo/gim\` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/js/regexp.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/js/undefined.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/js/undefined.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/map.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/map.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/merge.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/merge.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/null.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/null.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/omap.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/omap.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/pairs.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/pairs.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/seq.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/seq.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/set.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/set.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/str.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/str.js?`)},"./node_modules/js-yaml/lib/js-yaml/type/timestamp.js":function(module,exports,__webpack_require__){eval(`

var Type = __webpack_require__(/*! ../type */ "./node_modules/js-yaml/lib/js-yaml/type.js");

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\\\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


//# sourceURL=webpack://%5Bname%5D/./node_modules/js-yaml/lib/js-yaml/type/timestamp.js?`)},"./node_modules/json-schema-traverse/index.js":function(module,exports,__webpack_require__){eval(`

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\\//g, '~1');
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/json-schema-traverse/index.js?`)},"./node_modules/lodash/_Symbol.js":function(module,exports,__webpack_require__){eval(`var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_Symbol.js?`)},"./node_modules/lodash/_apply.js":function(module,exports){eval(`/**
 * A faster alternative to \`Function#apply\`, this function invokes \`func\`
 * with the \`this\` binding of \`thisArg\` and the arguments of \`args\`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The \`this\` binding of \`func\`.
 * @param {Array} args The arguments to invoke \`func\` with.
 * @returns {*} Returns the result of \`func\`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_apply.js?`)},"./node_modules/lodash/_arrayLikeKeys.js":function(module,exports,__webpack_require__){eval(`var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like \`value\`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable \`arguments.length\` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_arrayLikeKeys.js?`)},"./node_modules/lodash/_arrayMap.js":function(module,exports){eval(`/**
 * A specialized version of \`_.map\` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_arrayMap.js?`)},"./node_modules/lodash/_asciiToArray.js":function(module,exports){eval(`/**
 * Converts an ASCII \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_asciiToArray.js?`)},"./node_modules/lodash/_assignValue.js":function(module,exports,__webpack_require__){eval(`var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns \`value\` to \`key\` of \`object\` if the existing value is not equivalent
 * using [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_assignValue.js?`)},"./node_modules/lodash/_baseAssignValue.js":function(module,exports,__webpack_require__){eval(`var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of \`assignValue\` and \`assignMergeValue\` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseAssignValue.js?`)},"./node_modules/lodash/_baseFindIndex.js":function(module,exports){eval(`/**
 * The base implementation of \`_.findIndex\` and \`_.findLastIndex\` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseFindIndex.js?`)},"./node_modules/lodash/_baseGetTag.js":function(module,exports,__webpack_require__){eval(`var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** \`Object#toString\` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of \`getTag\` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the \`toStringTag\`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseGetTag.js?`)},"./node_modules/lodash/_baseIndexOf.js":function(module,exports,__webpack_require__){eval(`var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of \`_.indexOf\` without \`fromIndex\` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIndexOf.js?`)},"./node_modules/lodash/_baseIsArguments.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** \`Object#toString\` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of \`_.isArguments\`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an \`arguments\` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsArguments.js?`)},"./node_modules/lodash/_baseIsNaN.js":function(module,exports){eval(`/**
 * The base implementation of \`_.isNaN\` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is \`NaN\`, else \`false\`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsNaN.js?`)},"./node_modules/lodash/_baseIsNative.js":function(module,exports,__webpack_require__){eval(`var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match \`RegExp\`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\\[object .+?Constructor\\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of \`_.isNative\` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a native function,
 *  else \`false\`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsNative.js?`)},"./node_modules/lodash/_baseIsTypedArray.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** \`Object#toString\` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify \`toStringTag\` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of \`_.isTypedArray\` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a typed array, else \`false\`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseIsTypedArray.js?`)},"./node_modules/lodash/_baseKeys.js":function(module,exports,__webpack_require__){eval(`var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of \`_.keys\` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseKeys.js?`)},"./node_modules/lodash/_baseRest.js":function(module,exports,__webpack_require__){eval(`var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of \`_.rest\` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseRest.js?`)},"./node_modules/lodash/_baseSetToString.js":function(module,exports,__webpack_require__){eval(`var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of \`setToString\` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The \`toString\` result.
 * @returns {Function} Returns \`func\`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseSetToString.js?`)},"./node_modules/lodash/_baseSlice.js":function(module,exports){eval(`/**
 * The base implementation of \`_.slice\` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of \`array\`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseSlice.js?`)},"./node_modules/lodash/_baseTimes.js":function(module,exports){eval(`/**
 * The base implementation of \`_.times\` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke \`iteratee\`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseTimes.js?`)},"./node_modules/lodash/_baseToString.js":function(module,exports,__webpack_require__){eval(`var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various \`Number\` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of \`_.toString\` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseToString.js?`)},"./node_modules/lodash/_baseTrim.js":function(module,exports,__webpack_require__){eval(`var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\\s+/;

/**
 * The base implementation of \`_.trim\`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseTrim.js?`)},"./node_modules/lodash/_baseUnary.js":function(module,exports){eval(`/**
 * The base implementation of \`_.unary\` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_baseUnary.js?`)},"./node_modules/lodash/_castSlice.js":function(module,exports,__webpack_require__){eval(`var baseSlice = __webpack_require__(/*! ./_baseSlice */ "./node_modules/lodash/_baseSlice.js");

/**
 * Casts \`array\` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_castSlice.js?`)},"./node_modules/lodash/_charsEndIndex.js":function(module,exports,__webpack_require__){eval(`var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * Used by \`_.trim\` and \`_.trimEnd\` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsEndIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_charsEndIndex.js?`)},"./node_modules/lodash/_charsStartIndex.js":function(module,exports,__webpack_require__){eval(`var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * Used by \`_.trim\` and \`_.trimStart\` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsStartIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_charsStartIndex.js?`)},"./node_modules/lodash/_copyObject.js":function(module,exports,__webpack_require__){eval(`var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of \`source\` to \`object\`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns \`object\`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_copyObject.js?`)},"./node_modules/lodash/_coreJsData.js":function(module,exports,__webpack_require__){eval(`var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_coreJsData.js?`)},"./node_modules/lodash/_createAssigner.js":function(module,exports,__webpack_require__){eval(`var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like \`_.assign\`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_createAssigner.js?`)},"./node_modules/lodash/_defineProperty.js":function(module,exports,__webpack_require__){eval(`var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_defineProperty.js?`)},"./node_modules/lodash/_freeGlobal.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable \`global\` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_freeGlobal.js?`)},"./node_modules/lodash/_getNative.js":function(module,exports,__webpack_require__){eval(`var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at \`key\` of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else \`undefined\`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_getNative.js?`)},"./node_modules/lodash/_getRawTag.js":function(module,exports,__webpack_require__){eval(`var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [\`toStringTag\`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of \`baseGetTag\` which ignores \`Symbol.toStringTag\` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw \`toStringTag\`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_getRawTag.js?`)},"./node_modules/lodash/_getValue.js":function(module,exports){eval(`/**
 * Gets the value at \`key\` of \`object\`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_getValue.js?`)},"./node_modules/lodash/_hasUnicode.js":function(module,exports){eval(`/** Used to compose unicode character classes. */
var rsAstralRange = '\\\\ud800-\\\\udfff',
    rsComboMarksRange = '\\\\u0300-\\\\u036f',
    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',
    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\\\ufe0e\\\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if \`string\` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns \`true\` if a symbol is found, else \`false\`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_hasUnicode.js?`)},"./node_modules/lodash/_isIndex.js":function(module,exports){eval(`/** Used as references for various \`Number\` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\\d*)$/;

/**
 * Checks if \`value\` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid index, else \`false\`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isIndex.js?`)},"./node_modules/lodash/_isIterateeCall.js":function(module,exports,__webpack_require__){eval(`var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns \`true\` if the arguments are from an iteratee call,
 *  else \`false\`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isIterateeCall.js?`)},"./node_modules/lodash/_isMasked.js":function(module,exports,__webpack_require__){eval(`var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if \`func\` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns \`true\` if \`func\` is masked, else \`false\`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isMasked.js?`)},"./node_modules/lodash/_isPrototype.js":function(module,exports){eval(`/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if \`value\` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a prototype, else \`false\`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_isPrototype.js?`)},"./node_modules/lodash/_nativeKeys.js":function(module,exports,__webpack_require__){eval(`var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_nativeKeys.js?`)},"./node_modules/lodash/_nodeUtil.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable \`exports\`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable \`module\`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension \`module.exports\`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable \`process\` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use \`util.types\` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy \`process.binding('util')\` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_nodeUtil.js?`)},"./node_modules/lodash/_objectToString.js":function(module,exports){eval(`/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [\`toStringTag\`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts \`value\` to a string using \`Object.prototype.toString\`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_objectToString.js?`)},"./node_modules/lodash/_overArg.js":function(module,exports){eval(`/**
 * Creates a unary function that invokes \`func\` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_overArg.js?`)},"./node_modules/lodash/_overRest.js":function(module,exports,__webpack_require__){eval(`var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of \`baseRest\` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_overRest.js?`)},"./node_modules/lodash/_root.js":function(module,exports,__webpack_require__){eval(`var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable \`self\`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_root.js?`)},"./node_modules/lodash/_setToString.js":function(module,exports,__webpack_require__){eval(`var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the \`toString\` method of \`func\` to return \`string\`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The \`toString\` result.
 * @returns {Function} Returns \`func\`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_setToString.js?`)},"./node_modules/lodash/_shortOut.js":function(module,exports){eval(`/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke \`identity\` instead
 * of \`func\` when it's called \`HOT_COUNT\` or more times in \`HOT_SPAN\`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_shortOut.js?`)},"./node_modules/lodash/_strictIndexOf.js":function(module,exports){eval(`/**
 * A specialized version of \`_.indexOf\` which performs strict equality
 * comparisons of values, i.e. \`===\`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else \`-1\`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_strictIndexOf.js?`)},"./node_modules/lodash/_stringToArray.js":function(module,exports,__webpack_require__){eval(`var asciiToArray = __webpack_require__(/*! ./_asciiToArray */ "./node_modules/lodash/_asciiToArray.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeToArray = __webpack_require__(/*! ./_unicodeToArray */ "./node_modules/lodash/_unicodeToArray.js");

/**
 * Converts \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_stringToArray.js?`)},"./node_modules/lodash/_toSource.js":function(module,exports){eval(`/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts \`func\` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_toSource.js?`)},"./node_modules/lodash/_trimmedEndIndex.js":function(module,exports){eval(`/** Used to match a single whitespace character. */
var reWhitespace = /\\s/;

/**
 * Used by \`_.trim\` and \`_.trimEnd\` to get the index of the last non-whitespace
 * character of \`string\`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_trimmedEndIndex.js?`)},"./node_modules/lodash/_unicodeToArray.js":function(module,exports){eval(`/** Used to compose unicode character classes. */
var rsAstralRange = '\\\\ud800-\\\\udfff',
    rsComboMarksRange = '\\\\u0300-\\\\u036f',
    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',
    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\\\ufe0e\\\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',
    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',
    rsZWJ = '\\\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/_unicodeToArray.js?`)},"./node_modules/lodash/assign.js":function(module,exports,__webpack_require__){eval(`var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates \`object\` and is loosely based on
 * [\`Object.assign\`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns \`object\`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/assign.js?`)},"./node_modules/lodash/constant.js":function(module,exports){eval(`/**
 * Creates a function that returns \`value\`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/constant.js?`)},"./node_modules/lodash/eq.js":function(module,exports){eval(`/**
 * Performs a
 * [\`SameValueZero\`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns \`true\` if the values are equivalent, else \`false\`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/eq.js?`)},"./node_modules/lodash/identity.js":function(module,exports){eval(`/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns \`value\`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/identity.js?`)},"./node_modules/lodash/isArguments.js":function(module,exports,__webpack_require__){eval(`var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if \`value\` is likely an \`arguments\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an \`arguments\` object,
 *  else \`false\`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isArguments.js?`)},"./node_modules/lodash/isArray.js":function(module,exports){eval(`/**
 * Checks if \`value\` is classified as an \`Array\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an array, else \`false\`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isArray.js?`)},"./node_modules/lodash/isArrayLike.js":function(module,exports,__webpack_require__){eval(`var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if \`value\` is array-like. A value is considered array-like if it's
 * not a function and has a \`value.length\` that's an integer greater than or
 * equal to \`0\` and less than or equal to \`Number.MAX_SAFE_INTEGER\`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is array-like, else \`false\`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isArrayLike.js?`)},"./node_modules/lodash/isBuffer.js":function(module,exports,__webpack_require__){eval(`/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable \`exports\`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable \`module\`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension \`module.exports\`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other \`lodash\` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if \`value\` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a buffer, else \`false\`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isBuffer.js?`)},"./node_modules/lodash/isFunction.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** \`Object#toString\` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if \`value\` is classified as a \`Function\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a function, else \`false\`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of \`Object#toString\` avoids issues with the \`typeof\` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isFunction.js?`)},"./node_modules/lodash/isLength.js":function(module,exports){eval(`/** Used as references for various \`Number\` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if \`value\` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [\`ToLength\`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid length, else \`false\`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isLength.js?`)},"./node_modules/lodash/isObject.js":function(module,exports){eval(`/**
 * Checks if \`value\` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of \`Object\`. (e.g. arrays, functions, objects, regexes, \`new Number(0)\`, and \`new String('')\`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an object, else \`false\`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isObject.js?`)},"./node_modules/lodash/isObjectLike.js":function(module,exports){eval(`/**
 * Checks if \`value\` is object-like. A value is object-like if it's not \`null\`
 * and has a \`typeof\` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is object-like, else \`false\`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isObjectLike.js?`)},"./node_modules/lodash/isSymbol.js":function(module,exports,__webpack_require__){eval(`var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** \`Object#toString\` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if \`value\` is classified as a \`Symbol\` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a symbol, else \`false\`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isSymbol.js?`)},"./node_modules/lodash/isTypedArray.js":function(module,exports,__webpack_require__){eval(`var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if \`value\` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a typed array, else \`false\`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/isTypedArray.js?`)},"./node_modules/lodash/keys.js":function(module,exports,__webpack_require__){eval(`var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of \`object\`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/keys.js?`)},"./node_modules/lodash/stubFalse.js":function(module,exports){eval(`/**
 * This method returns \`false\`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns \`false\`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/stubFalse.js?`)},"./node_modules/lodash/toString.js":function(module,exports,__webpack_require__){eval(`var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts \`value\` to a string. An empty string is returned for \`null\`
 * and \`undefined\` values. The sign of \`-0\` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/toString.js?`)},"./node_modules/lodash/trim.js":function(module,exports,__webpack_require__){eval(`var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js"),
    baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    castSlice = __webpack_require__(/*! ./_castSlice */ "./node_modules/lodash/_castSlice.js"),
    charsEndIndex = __webpack_require__(/*! ./_charsEndIndex */ "./node_modules/lodash/_charsEndIndex.js"),
    charsStartIndex = __webpack_require__(/*! ./_charsStartIndex */ "./node_modules/lodash/_charsStartIndex.js"),
    stringToArray = __webpack_require__(/*! ./_stringToArray */ "./node_modules/lodash/_stringToArray.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Removes leading and trailing whitespace or specified characters from \`string\`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like \`_.map\`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return baseTrim(string);
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

module.exports = trim;


//# sourceURL=webpack://%5Bname%5D/./node_modules/lodash/trim.js?`)},"./node_modules/lz-string/libs/lz-string.js":function(module,exports,__webpack_require__){eval(`var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


//# sourceURL=webpack://%5Bname%5D/./node_modules/lz-string/libs/lz-string.js?`)},"./node_modules/minibus/minibus.js":function(module,exports,__webpack_require__){eval(`var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! minibus - v3.1.0 - 2014-11-22
 * https://github.com/axelpale/minibus
 *
 * Copyright (c) 2014 Akseli Palen <akseli.palen@gmail.com>;
 * Licensed under the MIT license */

(function (root, factory) {
  'use strict';
  // UMD pattern commonjsStrict.js
  // https://github.com/umdjs/umd
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function (exports) {
  'use strict';

// Minibus

//**************
// Constructor *
//**************

var Bus = function () {
  // event string -> sub route map
  this.eventMap = {};

  // route string -> route object
  this.routeMap = {};

  // free namespace shared between the event handlers on the bus.
  this.busContext = {};
};

exports.create = function () {
  return new Bus();
};

// For extendability.
// Usage: Minibus.extension.myFunction = function (...) {...};
exports.extension = Bus.prototype;



//*******************
// Helper functions *
//*******************

var isArray = function (v) {
  return Object.prototype.toString.call(v) === '[object Array]';
};

var isEmpty = function (obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};



//*************
// Exceptions *
//*************

var InvalidEventStringError = function (eventString) {
  // Usage
  //   throw new InvalidEventStringError(eventString)
  this.name = 'InvalidEventStringError';
  this.message = 'Invalid event string given: ' + eventString;
};

var InvalidRouteStringError = function (routeString) {
  // Usage
  //   throw new InvalidRouteStringError(routeString)
  this.name = 'InvalidRouteStringError';
  this.message = 'Invalid route string given: ' + routeString;
};

var InvalidEventHandlerError = function (eventHandler) {
  // Usage
  //   throw new InvalidEventHandlerError(eventHandler)
  this.name = 'InvalidEventHandlerError';
  this.message = 'Invalid event handler function given: ' + eventHandler;
};



//*******************************************
// Member functions. They all are mutators. *
//*******************************************

var _emit = function (eventString) {
  // Emit an event to execute the bound event handler functions.
  // The event handlers are executed immediately.
  //
  // Parameter
  //   eventString
  //     Event string or array of event strings.
  //   arg1 (optional)
  //     Argument to be passed to the handler functions.
  //   arg2 (optional)
  //   ...
  //
  // Return
  //   nothing
  //
  // Throw
  //   InvalidEventStringError
  //     if given event string is not a string or array of strings.
  //
  var emitArgs, i, subRouteMap, routeString, eventHandlers, busContext;

  // Turn to array for more general code.
  if (!isArray(eventString)) {
    eventString = [eventString];
  }

  // Validate all eventStrings before mutating anything.
  // This makes the on call more atomic.
  for (i = 0; i < eventString.length; i += 1) {
    if (typeof eventString[i] !== 'string') {
      throw new InvalidEventStringError(eventString[i]);
    }
  }

  // Collect passed arguments after the eventString argument.
  emitArgs = [];
  for (i = 1; i < arguments.length; i += 1) {
    emitArgs.push(arguments[i]);
  }

  // Collect all the event handlers bound to the given eventString
  eventHandlers = [];
  for (i = 0; i < eventString.length; i += 1) {
    if (this.eventMap.hasOwnProperty(eventString[i])) {
      subRouteMap = this.eventMap[eventString[i]];
      for (routeString in subRouteMap) {
        if (subRouteMap.hasOwnProperty(routeString)) {
          eventHandlers.push(subRouteMap[routeString].eventHandler);
        }
      }
    }
  }

  // Apply the event handlers.
  // All event handlers on the bus share a same bus context.
  busContext = this.busContext;
  for (i = 0; i < eventHandlers.length; i += 1) {
    eventHandlers[i].apply(busContext, emitArgs);
  }
};

// See Node.js events.EventEmitter.emit
Bus.prototype.emit = _emit;

// See Backbone.js Events.trigger
Bus.prototype.trigger = _emit;

// See Mozilla Web API EventTarget.dispatchEvent
// See http://stackoverflow.com/a/10085161/638546
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.dispatchEvent = _emit;

// See http://stackoverflow.com/a/9672223/638546
// Uncomment to enable. Too rare to be included by default.
//Bus.prototype.fireEvent = _emit;



var _on = function (eventString, eventHandler) {
  // Bind an event string(s) to an event handler function.
  //
  // Parameter
  //   eventString
  //     Event string or array of event strings.
  //     Empty array is ok but does nothing.
  //   eventHandler
  //     Event handler function to be executed when the event is emitted.
  //
  // Throw
  //   InvalidEventStringError
  //   InvalidEventHandlerError
  //
  // Return
  //   a route string or an array of route strings
  //
  var wasArray, i, routeObject, routeString, routeStringArray;

  // Turn to array for more general code.
  // Store whether parameter was array to return right type of value.
  wasArray = isArray(eventString);
  if (!wasArray) {
    eventString = [eventString];
  }

  // Validate all eventStrings before mutating anything.
  // This makes the on call more atomic.
  for (i = 0; i < eventString.length; i += 1) {
    if (typeof eventString[i] !== 'string') {
      throw new InvalidEventStringError(eventString[i]);
    }
  }

  // Validate the eventHandler
  if (typeof eventHandler !== 'function') {
    throw new InvalidEventHandlerError(eventHandler);
  }

  routeStringArray = [];
  for (i = 0; i < eventString.length; i += 1) {
    routeObject = {
      eventString: eventString[i],
      eventHandler: eventHandler
    };

    routeString = Identity.create();
    routeStringArray.push(routeString);

    if (!this.eventMap.hasOwnProperty(eventString[i])) {
      this.eventMap[eventString[i]] = {};
    }
    this.eventMap[eventString[i]][routeString] = routeObject;
    this.routeMap[routeString] = routeObject;
  }

  if (wasArray) {
    return routeStringArray;
  } // else
  return routeStringArray[0];
};

// See Backbone.js Events.on
// See Node.js events.EventEmitter.on
Bus.prototype.on = _on;

// See http://stackoverflow.com/a/9672223/638546
Bus.prototype.listen = _on;

// See Node.js events.EventEmitter.addListener
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.addListener = _on;

// See Mozilla Web API EventTarget.addEventListener
// See http://stackoverflow.com/a/11237657/638546
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.addEventListener = _on;



var _once = function (eventString, eventHandler) {
  // Like _on but reacts to emit only once.
  //
  // Parameter
  //   See _on
  //
  // Return
  //   See _on
  //
  // Throw
  //   InvalidEventStringError
  //   InvalidEventHandlerError
  //
  var that, routeString, called;

  // Validate the eventHandler. On does the validation also.
  // Duplicate validation is required because a wrapper function
  // is feed into on instead the given eventHandler.
  if (typeof eventHandler !== 'function') {
    throw new InvalidEventHandlerError(eventHandler);
  }

  that = this;
  called = false;
  routeString = this.on(eventString, function () {
    if (!called) {
      called = true; // Required to prevent duplicate sync calls
      that.off(routeString);
      // Apply. Use the context given by emit to embrace code dryness.
      eventHandler.apply(this, arguments);
    }
  });
  return routeString;
};

// See Node.js events.EventEmitter.once
// See Backbone.js Events.once
Bus.prototype.once = _once;



var _off = function (routeString) {
  // Unbind one or many event handlers.
  //
  // Parameter
  //   routeString
  //     A route string or an array of route strings or
  //     an array of arrays of route strings.
  //     The route to be shut down.
  //
  // Parameter (Alternative)
  //   eventString
  //     An event string or an array of event strings or
  //     an array of arrays of event strings.
  //     Shut down all the routes with this event string.
  //
  // Parameter (Alternative)
  //   (nothing)
  //     Shut down all the routes i.e. unbind all the event handlers.
  //
  // Throws
  //   InvalidRouteStringError
  //
  // Return
  //   nothing
  //
  var noArgs, i, routeObject, eventString, subRouteMap, rs;

  noArgs = (typeof routeString === 'undefined');
  if (noArgs) {
    this.routeMap = {};
    this.eventMap = {};
    return;
  }

  // Turn to array for more general code.
  if (!isArray(routeString)) {
    routeString = [routeString];
  }

  // Flatten arrays to allow arrays of arrays of route strings.
  // This is needed if user wants to off an array of routes. Some routes
  // might be arrays or route strings because 'on' interface.
  // http://stackoverflow.com/a/10865042/638546
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/
  //   Reference/Global_Objects/Array/concat
  var flat = [];
  flat = flat.concat.apply(flat, routeString);
  routeString = flat;

  // Validate all routeStrings before mutating anything.
  // This makes the off call more atomic.
  for (i = 0; i < routeString.length; i += 1) {
    if (typeof routeString[i] !== 'string') {
      throw new InvalidRouteStringError(routeString[i]);
    }
  }

  for (i = 0; i < routeString.length; i += 1) {
    if (this.routeMap.hasOwnProperty(routeString[i])) {
      routeObject = this.routeMap[routeString[i]];
      delete this.routeMap[routeString[i]];
      delete this.eventMap[routeObject.eventString][routeString[i]];
      // Remove sub route map from the event map if it is empty.
      // This prevents outdated eventStrings piling up on the eventMap.
      if (isEmpty(this.eventMap[routeObject.eventString])) {
        delete this.eventMap[routeObject.eventString];
      }
    } else {
      // As eventString
      eventString = routeString[i];
      if (this.eventMap.hasOwnProperty(eventString)) {
        subRouteMap = this.eventMap[eventString];
        for (rs in subRouteMap) {
          if (subRouteMap.hasOwnProperty(rs)) {
            delete this.routeMap[rs];
          }
        }
        delete this.eventMap[eventString];
      }
    }
  }
  // Assert: event handlers and their routes removed.
};

// Backbone.js Events.off
Bus.prototype.off = _off;

// Node.js events.EventEmitter.removeListener
Bus.prototype.removeListener = _off;

// See Mozilla Web API EventTarget.removeEventListener
// Uncomment to enable. Too lengthy to be included by default.
//Bus.prototype.removeEventListener = _off;


var Identity = (function () {
  // A utility for creating unique strings for identification.
  // Abstracts how uniqueness is archieved.
  //
  // Usages
  //   >>> Identity.create();
  //   '532402059994638'
  //   >>> Identity.create();
  //   '544258285779506'
  //
  var exports = {};
  /////////////////

  exports.create = function () {
    return Math.random().toString().substring(2);
  };

  ///////////////
  return exports;
}());


  // Version
  exports.version = '3.1.0';


// End of intro
}));


//# sourceURL=webpack://%5Bname%5D/./node_modules/minibus/minibus.js?`)},"./node_modules/pouchdb-browser/lib/index.es.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var immediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immediate */ "./node_modules/immediate/lib/index.js");
/* harmony import */ var immediate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(immediate__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/index.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! spark-md5 */ "./node_modules/pouchdb-browser/node_modules/spark-md5/spark-md5.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(spark_md5__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vuvuzela__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vuvuzela */ "./node_modules/vuvuzela/index.js");
/* harmony import */ var vuvuzela__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vuvuzela__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var argsarray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! argsarray */ "./node_modules/argsarray/index.js");
/* harmony import */ var argsarray__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(argsarray__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! inherits */ "./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_6__);








function mangle(key) {
  return '$' + key;
}
function unmangle(key) {
  return key.substring(1);
}
function Map$1() {
  this._store = {};
}
Map$1.prototype.get = function (key) {
  var mangled = mangle(key);
  return this._store[mangled];
};
Map$1.prototype.set = function (key, value) {
  var mangled = mangle(key);
  this._store[mangled] = value;
  return true;
};
Map$1.prototype.has = function (key) {
  var mangled = mangle(key);
  return mangled in this._store;
};
Map$1.prototype.delete = function (key) {
  var mangled = mangle(key);
  var res = mangled in this._store;
  delete this._store[mangled];
  return res;
};
Map$1.prototype.forEach = function (cb) {
  var keys = Object.keys(this._store);
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    var value = this._store[key];
    key = unmangle(key);
    cb(value, key);
  }
};
Object.defineProperty(Map$1.prototype, 'size', {
  get: function () {
    return Object.keys(this._store).length;
  }
});

function Set$1(array) {
  this._store = new Map$1();

  // init with an array
  if (array && Array.isArray(array)) {
    for (var i = 0, len = array.length; i < len; i++) {
      this.add(array[i]);
    }
  }
}
Set$1.prototype.add = function (key) {
  return this._store.set(key, true);
};
Set$1.prototype.has = function (key) {
  return this._store.has(key);
};
Set$1.prototype.forEach = function (cb) {
  this._store.forEach(function (value, key) {
    cb(key);
  });
};
Object.defineProperty(Set$1.prototype, 'size', {
  get: function () {
    return this._store.size;
  }
});

/* global Map,Set,Symbol */
// Based on https://kangax.github.io/compat-table/es6/ we can sniff out
// incomplete Map/Set implementations which would otherwise cause our tests to fail.
// Notably they fail in IE11 and iOS 8.4, which this prevents.
function supportsMapAndSet() {
  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {
    return false;
  }
  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);
  return prop && 'get' in prop && Map[Symbol.species] === Map;
}

// based on https://github.com/montagejs/collections

var ExportedSet;
var ExportedMap;

{
  if (supportsMapAndSet()) { // prefer built-in Map/Set
    ExportedSet = Set;
    ExportedMap = Map;
  } else { // fall back to our polyfill
    ExportedSet = Set$1;
    ExportedMap = Map$1;
  }
}

function isBinaryObject(object) {
  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||
    (typeof Blob !== 'undefined' && object instanceof Blob);
}

function cloneArrayBuffer(buff) {
  if (typeof buff.slice === 'function') {
    return buff.slice(0);
  }
  // IE10-11 slice() polyfill
  var target = new ArrayBuffer(buff.byteLength);
  var targetArray = new Uint8Array(target);
  var sourceArray = new Uint8Array(buff);
  targetArray.set(sourceArray);
  return target;
}

function cloneBinaryObject(object) {
  if (object instanceof ArrayBuffer) {
    return cloneArrayBuffer(object);
  }
  var size = object.size;
  var type = object.type;
  // Blob
  if (typeof object.slice === 'function') {
    return object.slice(0, size, type);
  }
  // PhantomJS slice() replacement
  return object.webkitSlice(0, size, type);
}

// most of this is borrowed from lodash.isPlainObject:
// https://github.com/fis-components/lodash.isplainobject/
// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js

var funcToString = Function.prototype.toString;
var objectCtorString = funcToString.call(Object);

function isPlainObject(value) {
  var proto = Object.getPrototypeOf(value);
  /* istanbul ignore if */
  if (proto === null) { // not sure when this happens, but I guess it can
    return true;
  }
  var Ctor = proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

function clone(object) {
  var newObject;
  var i;
  var len;

  if (!object || typeof object !== 'object') {
    return object;
  }

  if (Array.isArray(object)) {
    newObject = [];
    for (i = 0, len = object.length; i < len; i++) {
      newObject[i] = clone(object[i]);
    }
    return newObject;
  }

  // special case: to avoid inconsistencies between IndexedDB
  // and other backends, we automatically stringify Dates
  if (object instanceof Date) {
    return object.toISOString();
  }

  if (isBinaryObject(object)) {
    return cloneBinaryObject(object);
  }

  if (!isPlainObject(object)) {
    return object; // don't clone objects like Workers
  }

  newObject = {};
  for (i in object) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(object, i)) {
      var value = clone(object[i]);
      if (typeof value !== 'undefined') {
        newObject[i] = value;
      }
    }
  }
  return newObject;
}

function once(fun) {
  var called = false;
  return argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    /* istanbul ignore if */
    if (called) {
      // this is a smoke test and should never actually happen
      throw new Error('once called more than once');
    } else {
      called = true;
      fun.apply(this, args);
    }
  });
}

function toPromise(func) {
  //create the function we will be returning
  return argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    // Clone arguments
    args = clone(args);
    var self = this;
    // if the last argument is a function, assume its a callback
    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
    var promise = new Promise(function (fulfill, reject) {
      var resp;
      try {
        var callback = once(function (err, mesg) {
          if (err) {
            reject(err);
          } else {
            fulfill(mesg);
          }
        });
        // create a callback for this invocation
        // apply the function in the orig context
        args.push(callback);
        resp = func.apply(self, args);
        if (resp && typeof resp.then === 'function') {
          fulfill(resp);
        }
      } catch (e) {
        reject(e);
      }
    });
    // if there is a callback, call it back
    if (usedCB) {
      promise.then(function (result) {
        usedCB(null, result);
      }, usedCB);
    }
    return promise;
  });
}

function logApiCall(self, name, args) {
  /* istanbul ignore if */
  if (self.constructor.listeners('debug').length) {
    var logArgs = ['api', self.name, name];
    for (var i = 0; i < args.length - 1; i++) {
      logArgs.push(args[i]);
    }
    self.constructor.emit('debug', logArgs);

    // override the callback itself to log the response
    var origCallback = args[args.length - 1];
    args[args.length - 1] = function (err, res) {
      var responseArgs = ['api', self.name, name];
      responseArgs = responseArgs.concat(
        err ? ['error', err] : ['success', res]
      );
      self.constructor.emit('debug', responseArgs);
      origCallback(err, res);
    };
  }
}

function adapterFun(name, callback) {
  return toPromise(argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    if (this._closed) {
      return Promise.reject(new Error('database is closed'));
    }
    if (this._destroyed) {
      return Promise.reject(new Error('database is destroyed'));
    }
    var self = this;
    logApiCall(self, name, args);
    if (!this.taskqueue.isReady) {
      return new Promise(function (fulfill, reject) {
        self.taskqueue.addTask(function (failed) {
          if (failed) {
            reject(failed);
          } else {
            fulfill(self[name].apply(self, args));
          }
        });
      });
    }
    return callback.apply(this, args);
  }));
}

// like underscore/lodash _.pick()
function pick(obj, arr) {
  var res = {};
  for (var i = 0, len = arr.length; i < len; i++) {
    var prop = arr[i];
    if (prop in obj) {
      res[prop] = obj[prop];
    }
  }
  return res;
}

// Most browsers throttle concurrent requests at 6, so it's silly
// to shim _bulk_get by trying to launch potentially hundreds of requests
// and then letting the majority time out. We can handle this ourselves.
var MAX_NUM_CONCURRENT_REQUESTS = 6;

function identityFunction(x) {
  return x;
}

function formatResultForOpenRevsGet(result) {
  return [{
    ok: result
  }];
}

// shim for P/CouchDB adapters that don't directly implement _bulk_get
function bulkGet(db, opts, callback) {
  var requests = opts.docs;

  // consolidate into one request per doc if possible
  var requestsById = new ExportedMap();
  requests.forEach(function (request) {
    if (requestsById.has(request.id)) {
      requestsById.get(request.id).push(request);
    } else {
      requestsById.set(request.id, [request]);
    }
  });

  var numDocs = requestsById.size;
  var numDone = 0;
  var perDocResults = new Array(numDocs);

  function collapseResultsAndFinish() {
    var results = [];
    perDocResults.forEach(function (res) {
      res.docs.forEach(function (info) {
        results.push({
          id: res.id,
          docs: [info]
        });
      });
    });
    callback(null, {results: results});
  }

  function checkDone() {
    if (++numDone === numDocs) {
      collapseResultsAndFinish();
    }
  }

  function gotResult(docIndex, id, docs) {
    perDocResults[docIndex] = {id: id, docs: docs};
    checkDone();
  }

  var allRequests = [];
  requestsById.forEach(function (value, key) {
    allRequests.push(key);
  });

  var i = 0;

  function nextBatch() {

    if (i >= allRequests.length) {
      return;
    }

    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);
    var batch = allRequests.slice(i, upTo);
    processBatch(batch, i);
    i += batch.length;
  }

  function processBatch(batch, offset) {
    batch.forEach(function (docId, j) {
      var docIdx = offset + j;
      var docRequests = requestsById.get(docId);

      // just use the first request as the "template"
      // TODO: The _bulk_get API allows for more subtle use cases than this,
      // but for now it is unlikely that there will be a mix of different
      // "atts_since" or "attachments" in the same request, since it's just
      // replicate.js that is using this for the moment.
      // Also, atts_since is aspirational, since we don't support it yet.
      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
      docOpts.open_revs = docRequests.map(function (request) {
        // rev is optional, open_revs disallowed
        return request.rev;
      });

      // remove falsey / undefined revisions
      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);

      var formatResult = identityFunction;

      if (docOpts.open_revs.length === 0) {
        delete docOpts.open_revs;

        // when fetching only the "winning" leaf,
        // transform the result so it looks like an open_revs
        // request
        formatResult = formatResultForOpenRevsGet;
      }

      // globally-supplied options
      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {
        if (param in opts) {
          docOpts[param] = opts[param];
        }
      });
      db.get(docId, docOpts, function (err, res) {
        var result;
        /* istanbul ignore if */
        if (err) {
          result = [{error: err}];
        } else {
          result = formatResult(res);
        }
        gotResult(docIdx, docId, result);
        nextBatch();
      });
    });
  }

  nextBatch();

}

var hasLocal;

try {
  localStorage.setItem('_pouch_check_localstorage', 1);
  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
} catch (e) {
  hasLocal = false;
}

function hasLocalStorage() {
  return hasLocal;
}

// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We

inherits__WEBPACK_IMPORTED_MODULE_5___default()(Changes, events__WEBPACK_IMPORTED_MODULE_6___default.a);

/* istanbul ignore next */
function attachBrowserEvents(self) {
  if (hasLocalStorage()) {
    addEventListener("storage", function (e) {
      self.emit(e.key);
    });
  }
}

function Changes() {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);
  this._listeners = {};

  attachBrowserEvents(this);
}
Changes.prototype.addListener = function (dbName, id, db, opts) {
  /* istanbul ignore if */
  if (this._listeners[id]) {
    return;
  }
  var self = this;
  var inprogress = false;
  function eventFunction() {
    /* istanbul ignore if */
    if (!self._listeners[id]) {
      return;
    }
    if (inprogress) {
      inprogress = 'waiting';
      return;
    }
    inprogress = true;
    var changesOpts = pick(opts, [
      'style', 'include_docs', 'attachments', 'conflicts', 'filter',
      'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'
    ]);

    /* istanbul ignore next */
    function onError() {
      inprogress = false;
    }

    db.changes(changesOpts).on('change', function (c) {
      if (c.seq > opts.since && !opts.cancelled) {
        opts.since = c.seq;
        opts.onChange(c);
      }
    }).on('complete', function () {
      if (inprogress === 'waiting') {
        immediate__WEBPACK_IMPORTED_MODULE_0___default()(eventFunction);
      }
      inprogress = false;
    }).on('error', onError);
  }
  this._listeners[id] = eventFunction;
  this.on(dbName, eventFunction);
};

Changes.prototype.removeListener = function (dbName, id) {
  /* istanbul ignore if */
  if (!(id in this._listeners)) {
    return;
  }
  events__WEBPACK_IMPORTED_MODULE_6___default.a.prototype.removeListener.call(this, dbName,
    this._listeners[id]);
  delete this._listeners[id];
};


/* istanbul ignore next */
Changes.prototype.notifyLocalWindows = function (dbName) {
  //do a useless change on a storage thing
  //in order to get other windows's listeners to activate
  if (hasLocalStorage()) {
    localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
  }
};

Changes.prototype.notify = function (dbName) {
  this.emit(dbName);
  this.notifyLocalWindows(dbName);
};

function guardedConsole(method) {
  /* istanbul ignore else */
  if (typeof console !== 'undefined' && typeof console[method] === 'function') {
    var args = Array.prototype.slice.call(arguments, 1);
    console[method].apply(console, args);
  }
}

function randomNumber(min, max) {
  var maxTimeout = 600000; // Hard-coded default of 10 minutes
  min = parseInt(min, 10) || 0;
  max = parseInt(max, 10);
  if (max !== max || max <= min) {
    max = (min || 1) << 1; //doubling
  } else {
    max = max + 1;
  }
  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout
  if (max > maxTimeout) {
    min = maxTimeout >> 1; // divide by two
    max = maxTimeout;
  }
  var ratio = Math.random();
  var range = max - min;

  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
}

function defaultBackOff(min) {
  var max = 0;
  if (!min) {
    max = 2000;
  }
  return randomNumber(min, max);
}

// designed to give info to browser users, who are disturbed
// when they see http errors in the console
function explainError(status, str) {
  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);
}

var assign;
{
  if (typeof Object.assign === 'function') {
    assign = Object.assign;
  } else {
    // lite Object.assign polyfill based on
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    assign = function (target) {
      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    };
  }
}

var $inject_Object_assign = assign;

inherits__WEBPACK_IMPORTED_MODULE_5___default()(PouchError, Error);

function PouchError(status, error, reason) {
  Error.call(this, reason);
  this.status = status;
  this.name = error;
  this.message = reason;
  this.error = true;
}

PouchError.prototype.toString = function () {
  return JSON.stringify({
    status: this.status,
    name: this.name,
    message: this.message,
    reason: this.reason
  });
};

var UNAUTHORIZED = new PouchError(401, 'unauthorized', "Name or password is incorrect.");
var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
var NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');
var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
var INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');
var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
var DB_MISSING = new PouchError(404, 'not_found', 'Database not found');
var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
var WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');
var LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');
var FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
var FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');
var INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');

function createError(error, reason) {
  function CustomPouchError(reason) {
    // inherit error properties from our parent error manually
    // so as to allow proper JSON parsing.
    /* jshint ignore:start */
    var names = Object.getOwnPropertyNames(error);
    for (var i = 0, len = names.length; i < len; i++) {
      if (typeof error[names[i]] !== 'function') {
        this[names[i]] = error[names[i]];
      }
    }
    /* jshint ignore:end */
    if (reason !== undefined) {
      this.reason = reason;
    }
  }
  CustomPouchError.prototype = PouchError.prototype;
  return new CustomPouchError(reason);
}

function generateErrorFromResponse(err) {

  if (typeof err !== 'object') {
    var data = err;
    err = UNKNOWN_ERROR;
    err.data = data;
  }

  if ('error' in err && err.error === 'conflict') {
    err.name = 'conflict';
    err.status = 409;
  }

  if (!('name' in err)) {
    err.name = err.error || 'unknown';
  }

  if (!('status' in err)) {
    err.status = 500;
  }

  if (!('message' in err)) {
    err.message = err.message || err.reason;
  }

  return err;
}

function tryFilter(filter, doc, req) {
  try {
    return !filter(doc, req);
  } catch (err) {
    var msg = 'Filter function threw: ' + err.toString();
    return createError(BAD_REQUEST, msg);
  }
}

function filterChange(opts) {
  var req = {};
  var hasFilter = opts.filter && typeof opts.filter === 'function';
  req.query = opts.query_params;

  return function filter(change) {
    if (!change.doc) {
      // CSG sends events on the changes feed that don't have documents,
      // this hack makes a whole lot of existing code robust.
      change.doc = {};
    }

    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);

    if (typeof filterReturn === 'object') {
      return filterReturn;
    }

    if (filterReturn) {
      return false;
    }

    if (!opts.include_docs) {
      delete change.doc;
    } else if (!opts.attachments) {
      for (var att in change.doc._attachments) {
        /* istanbul ignore else */
        if (change.doc._attachments.hasOwnProperty(att)) {
          change.doc._attachments[att].stub = true;
        }
      }
    }
    return true;
  };
}

function flatten(arrs) {
  var res = [];
  for (var i = 0, len = arrs.length; i < len; i++) {
    res = res.concat(arrs[i]);
  }
  return res;
}

// shim for Function.prototype.name,

// Determine id an ID is valid
//   - invalid IDs begin with an underescore that does not begin '_design' or
//     '_local'
//   - any other string value is a valid id
// Returns the specific error object for each case
function invalidIdError(id) {
  var err;
  if (!id) {
    err = createError(MISSING_ID);
  } else if (typeof id !== 'string') {
    err = createError(INVALID_ID);
  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
    err = createError(RESERVED_ID);
  }
  if (err) {
    throw err;
  }
}

// Checks if a PouchDB object is "remote" or not. This is

function isRemote(db) {
  if (typeof db._remote === 'boolean') {
    return db._remote;
  }
  /* istanbul ignore next */
  if (typeof db.type === 'function') {
    guardedConsole('warn',
      'db.type() is deprecated and will be removed in ' +
      'a future version of PouchDB');
    return db.type() === 'http';
  }
  /* istanbul ignore next */
  return false;
}

function listenerCount(ee, type) {
  return 'listenerCount' in ee ? ee.listenerCount(type) :
                                 events__WEBPACK_IMPORTED_MODULE_6___default.a.listenerCount(ee, type);
}

function parseDesignDocFunctionName(s) {
  if (!s) {
    return null;
  }
  var parts = s.split('/');
  if (parts.length === 2) {
    return parts;
  }
  if (parts.length === 1) {
    return [s, s];
  }
  return null;
}

function normalizeDesignDocFunctionName(s) {
  var normalized = parseDesignDocFunctionName(s);
  return normalized ? normalized.join('/') : null;
}

// originally parseUri 1.2.2, now patched by us
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
var keys = ["source", "protocol", "authority", "userInfo", "user", "password",
    "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
var qName ="queryKey";
var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;

// use the "loose" parser
/* eslint maxlen: 0, no-useless-escape: 0 */
var parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;

function parseUri(str) {
  var m = parser.exec(str);
  var uri = {};
  var i = 14;

  while (i--) {
    var key = keys[i];
    var value = m[i] || "";
    var encoded = ['user', 'password'].indexOf(key) !== -1;
    uri[key] = encoded ? decodeURIComponent(value) : value;
  }

  uri[qName] = {};
  uri[keys[12]].replace(qParser, function ($0, $1, $2) {
    if ($1) {
      uri[qName][$1] = $2;
    }
  });

  return uri;
}

// Based on https://github.com/alexdavid/scope-eval v0.0.3
// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)
// This is basically just a wrapper around new Function()

function scopeEval(source, scope) {
  var keys = [];
  var values = [];
  for (var key in scope) {
    if (scope.hasOwnProperty(key)) {
      keys.push(key);
      values.push(scope[key]);
    }
  }
  keys.push(source);
  return Function.apply(null, keys).apply(null, values);
}

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
function upsert(db, docId, diffFun) {
  return new Promise(function (fulfill, reject) {
    db.get(docId, function (err, doc) {
      if (err) {
        /* istanbul ignore next */
        if (err.status !== 404) {
          return reject(err);
        }
        doc = {};
      }

      // the user might change the _rev, so save it for posterity
      var docRev = doc._rev;
      var newDoc = diffFun(doc);

      if (!newDoc) {
        // if the diffFun returns falsy, we short-circuit as
        // an optimization
        return fulfill({updated: false, rev: docRev});
      }

      // users aren't allowed to modify these values,
      // so reset them here
      newDoc._id = docId;
      newDoc._rev = docRev;
      fulfill(tryAndPut(db, newDoc, diffFun));
    });
  });
}

function tryAndPut(db, doc, diffFun) {
  return db.put(doc).then(function (res) {
    return {
      updated: true,
      rev: res.rev
    };
  }, function (err) {
    /* istanbul ignore next */
    if (err.status !== 409) {
      throw err;
    }
    return upsert(db, doc._id, diffFun);
  });
}

var thisAtob = function (str) {
  return atob(str);
};

var thisBtoa = function (str) {
  return btoa(str);
};

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor (e.g.
// old QtWebKit versions, Android < 4.4).
function createBlob(parts, properties) {
  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
  parts = parts || [];
  properties = properties || {};
  try {
    return new Blob(parts, properties);
  } catch (e) {
    if (e.name !== "TypeError") {
      throw e;
    }
    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :
                  WebKitBlobBuilder;
    var builder = new Builder();
    for (var i = 0; i < parts.length; i += 1) {
      builder.append(parts[i]);
    }
    return builder.getBlob(properties.type);
  }
}

// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function binaryStringToArrayBuffer(bin) {
  var length = bin.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  for (var i = 0; i < length; i++) {
    arr[i] = bin.charCodeAt(i);
  }
  return buf;
}

function binStringToBluffer(binString, type) {
  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});
}

function b64ToBluffer(b64, type) {
  return binStringToBluffer(thisAtob(b64), type);
}

//Can't find original post, but this is close
//http://stackoverflow.com/questions/6965107/ (continues on next line)
//converting-between-strings-and-arraybuffers
function arrayBufferToBinaryString(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);
  var length = bytes.byteLength;
  for (var i = 0; i < length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return binary;
}

// shim for browsers that don't support it
function readAsBinaryString(blob, callback) {
  var reader = new FileReader();
  var hasBinaryString = typeof reader.readAsBinaryString === 'function';
  reader.onloadend = function (e) {
    var result = e.target.result || '';
    if (hasBinaryString) {
      return callback(result);
    }
    callback(arrayBufferToBinaryString(result));
  };
  if (hasBinaryString) {
    reader.readAsBinaryString(blob);
  } else {
    reader.readAsArrayBuffer(blob);
  }
}

function blobToBinaryString(blobOrBuffer, callback) {
  readAsBinaryString(blobOrBuffer, function (bin) {
    callback(bin);
  });
}

function blobToBase64(blobOrBuffer, callback) {
  blobToBinaryString(blobOrBuffer, function (base64) {
    callback(thisBtoa(base64));
  });
}

// simplified API. universal browser support is assumed
function readAsArrayBuffer(blob, callback) {
  var reader = new FileReader();
  reader.onloadend = function (e) {
    var result = e.target.result || new ArrayBuffer(0);
    callback(result);
  };
  reader.readAsArrayBuffer(blob);
}

// this is not used in the browser

var setImmediateShim = self.setImmediate || self.setTimeout;
var MD5_CHUNK_SIZE = 32768;

function rawToBase64(raw) {
  return thisBtoa(raw);
}

function sliceBlob(blob, start, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start, end);
  }
  return blob.slice(start, end);
}

function appendBlob(buffer, blob, start, end, callback) {
  if (start > 0 || end < blob.size) {
    // only slice blob if we really need to
    blob = sliceBlob(blob, start, end);
  }
  readAsArrayBuffer(blob, function (arrayBuffer) {
    buffer.append(arrayBuffer);
    callback();
  });
}

function appendString(buffer, string, start, end, callback) {
  if (start > 0 || end < string.length) {
    // only create a substring if we really need to
    string = string.substring(start, end);
  }
  buffer.appendBinary(string);
  callback();
}

function binaryMd5(data, callback) {
  var inputIsString = typeof data === 'string';
  var len = inputIsString ? data.length : data.size;
  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
  var chunks = Math.ceil(len / chunkSize);
  var currentChunk = 0;
  var buffer = inputIsString ? new spark_md5__WEBPACK_IMPORTED_MODULE_2___default.a() : new spark_md5__WEBPACK_IMPORTED_MODULE_2___default.a.ArrayBuffer();

  var append = inputIsString ? appendString : appendBlob;

  function next() {
    setImmediateShim(loadNextChunk);
  }

  function done() {
    var raw = buffer.end(true);
    var base64 = rawToBase64(raw);
    callback(base64);
    buffer.destroy();
  }

  function loadNextChunk() {
    var start = currentChunk * chunkSize;
    var end = start + chunkSize;
    currentChunk++;
    if (currentChunk < chunks) {
      append(buffer, data, start, end, next);
    } else {
      append(buffer, data, start, end, done);
    }
  }
  loadNextChunk();
}

function stringMd5(string) {
  return spark_md5__WEBPACK_IMPORTED_MODULE_2___default.a.hash(string);
}

function rev(doc, deterministic_revs) {
  var clonedDoc = clone(doc);
  if (!deterministic_revs) {
    return Object(uuid__WEBPACK_IMPORTED_MODULE_1__["v4"])().replace(/-/g, '').toLowerCase();
  }

  delete clonedDoc._rev_tree;
  return stringMd5(JSON.stringify(clonedDoc));
}

var uuid = uuid__WEBPACK_IMPORTED_MODULE_1__["v4"]; // mimic old import, only v4 is ever used elsewhere

// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// http://guide.couchdb.org/draft/conflicts.html
function winningRev(metadata) {
  var winningId;
  var winningPos;
  var winningDeleted;
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var tree = node.ids;
    var branches = tree[2];
    var pos = node.pos;
    if (branches.length) { // non-leaf
      for (var i = 0, len = branches.length; i < len; i++) {
        toVisit.push({pos: pos + 1, ids: branches[i]});
      }
      continue;
    }
    var deleted = !!tree[1].deleted;
    var id = tree[0];
    // sort by deleted, then pos, then id
    if (!winningId || (winningDeleted !== deleted ? winningDeleted :
        winningPos !== pos ? winningPos < pos : winningId < id)) {
      winningId = id;
      winningPos = pos;
      winningDeleted = deleted;
    }
  }

  return winningPos + '-' + winningId;
}

// Pretty much all below can be combined into a higher order function to
// traverse revisions
// The return value from the callback will be passed as context to all
// children of that node
function traverseRevTree(revs, callback) {
  var toVisit = revs.slice();

  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var branches = tree[2];
    var newCtx =
      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});
    }
  }
}

function sortByPos(a, b) {
  return a.pos - b.pos;
}

function collectLeaves(revs) {
  var leaves = [];
  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
    if (isLeaf) {
      leaves.push({rev: pos + "-" + id, pos: pos, opts: opts});
    }
  });
  leaves.sort(sortByPos).reverse();
  for (var i = 0, len = leaves.length; i < len; i++) {
    delete leaves[i].pos;
  }
  return leaves;
}

// returns revs of all conflicts that is leaves such that
// 1. are not deleted and
// 2. are different than winning revision
function collectConflicts(metadata) {
  var win = winningRev(metadata);
  var leaves = collectLeaves(metadata.rev_tree);
  var conflicts = [];
  for (var i = 0, len = leaves.length; i < len; i++) {
    var leaf = leaves[i];
    if (leaf.rev !== win && !leaf.opts.deleted) {
      conflicts.push(leaf.rev);
    }
  }
  return conflicts;
}

// compact a tree by marking its non-leafs as missing,
// and return a list of revs to delete
function compactTree(metadata) {
  var revs = [];
  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                               revHash, ctx, opts) {
    if (opts.status === 'available' && !isLeaf) {
      revs.push(pos + '-' + revHash);
      opts.status = 'missing';
    }
  });
  return revs;
}

// build up a list of all the paths to the leafs in this revision tree
function rootToLeaf(revs) {
  var paths = [];
  var toVisit = revs.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, opts: opts});
    if (isLeaf) {
      paths.push({pos: (pos + 1 - history.length), ids: history});
    }
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: pos + 1, ids: branches[i], history: history});
    }
  }
  return paths.reverse();
}

// for a better overview of what this is doing, read:

function sortByPos$1(a, b) {
  return a.pos - b.pos;
}

// classic binary search
function binarySearch(arr, item, comparator) {
  var low = 0;
  var high = arr.length;
  var mid;
  while (low < high) {
    mid = (low + high) >>> 1;
    if (comparator(arr[mid], item) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}

// assuming the arr is sorted, insert the item in the proper place
function insertSorted(arr, item, comparator) {
  var idx = binarySearch(arr, item, comparator);
  arr.splice(idx, 0, item);
}

// Turn a path as a flat array into a tree with a single branch.
// If any should be stemmed from the beginning of the array, that's passed
// in as the second argument
function pathToTree(path, numStemmed) {
  var root;
  var leaf;
  for (var i = numStemmed, len = path.length; i < len; i++) {
    var node = path[i];
    var currentLeaf = [node.id, node.opts, []];
    if (leaf) {
      leaf[2].push(currentLeaf);
      leaf = currentLeaf;
    } else {
      root = leaf = currentLeaf;
    }
  }
  return root;
}

// compare the IDs of two trees
function compareTree(a, b) {
  return a[0] < b[0] ? -1 : 1;
}

// Merge two trees together
// The roots of tree1 and tree2 must be the same revision
function mergeTree(in_tree1, in_tree2) {
  var queue = [{tree1: in_tree1, tree2: in_tree2}];
  var conflicts = false;
  while (queue.length > 0) {
    var item = queue.pop();
    var tree1 = item.tree1;
    var tree2 = item.tree2;

    if (tree1[1].status || tree2[1].status) {
      tree1[1].status =
        (tree1[1].status ===  'available' ||
        tree2[1].status === 'available') ? 'available' : 'missing';
    }

    for (var i = 0; i < tree2[2].length; i++) {
      if (!tree1[2][0]) {
        conflicts = 'new_leaf';
        tree1[2][0] = tree2[2][i];
        continue;
      }

      var merged = false;
      for (var j = 0; j < tree1[2].length; j++) {
        if (tree1[2][j][0] === tree2[2][i][0]) {
          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});
          merged = true;
        }
      }
      if (!merged) {
        conflicts = 'new_branch';
        insertSorted(tree1[2], tree2[2][i], compareTree);
      }
    }
  }
  return {conflicts: conflicts, tree: in_tree1};
}

function doMerge(tree, path, dontExpand) {
  var restree = [];
  var conflicts = false;
  var merged = false;
  var res;

  if (!tree.length) {
    return {tree: [path], conflicts: 'new_leaf'};
  }

  for (var i = 0, len = tree.length; i < len; i++) {
    var branch = tree[i];
    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
      // Paths start at the same position and have the same root, so they need
      // merged
      res = mergeTree(branch.ids, path.ids);
      restree.push({pos: branch.pos, ids: res.tree});
      conflicts = conflicts || res.conflicts;
      merged = true;
    } else if (dontExpand !== true) {
      // The paths start at a different position, take the earliest path and
      // traverse up until it as at the same point from root as the path we
      // want to merge.  If the keys match we return the longer path with the
      // other merged After stemming we dont want to expand the trees

      var t1 = branch.pos < path.pos ? branch : path;
      var t2 = branch.pos < path.pos ? path : branch;
      var diff = t2.pos - t1.pos;

      var candidateParents = [];

      var trees = [];
      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});
      while (trees.length > 0) {
        var item = trees.pop();
        if (item.diff === 0) {
          if (item.ids[0] === t2.ids[0]) {
            candidateParents.push(item);
          }
          continue;
        }
        var elements = item.ids[2];
        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
          trees.push({
            ids: elements[j],
            diff: item.diff - 1,
            parent: item.ids,
            parentIdx: j
          });
        }
      }

      var el = candidateParents[0];

      if (!el) {
        restree.push(branch);
      } else {
        res = mergeTree(el.ids, t2.ids);
        el.parent[2][el.parentIdx] = res.tree;
        restree.push({pos: t1.pos, ids: t1.ids});
        conflicts = conflicts || res.conflicts;
        merged = true;
      }
    } else {
      restree.push(branch);
    }
  }

  // We didnt find
  if (!merged) {
    restree.push(path);
  }

  restree.sort(sortByPos$1);

  return {
    tree: restree,
    conflicts: conflicts || 'internal_node'
  };
}

// To ensure we dont grow the revision tree infinitely, we stem old revisions
function stem(tree, depth) {
  // First we break out the tree into a complete list of root to leaf paths
  var paths = rootToLeaf(tree);
  var stemmedRevs;

  var result;
  for (var i = 0, len = paths.length; i < len; i++) {
    // Then for each path, we cut off the start of the path based on the
    // \`depth\` to stem to, and generate a new set of flat trees
    var path = paths[i];
    var stemmed = path.ids;
    var node;
    if (stemmed.length > depth) {
      // only do the stemming work if we actually need to stem
      if (!stemmedRevs) {
        stemmedRevs = {}; // avoid allocating this object unnecessarily
      }
      var numStemmed = stemmed.length - depth;
      node = {
        pos: path.pos + numStemmed,
        ids: pathToTree(stemmed, numStemmed)
      };

      for (var s = 0; s < numStemmed; s++) {
        var rev = (path.pos + s) + '-' + stemmed[s].id;
        stemmedRevs[rev] = true;
      }
    } else { // no need to actually stem
      node = {
        pos: path.pos,
        ids: pathToTree(stemmed, 0)
      };
    }

    // Then we remerge all those flat trees together, ensuring that we dont
    // connect trees that would go beyond the depth limit
    if (result) {
      result = doMerge(result, node, true).tree;
    } else {
      result = [node];
    }
  }

  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed
  if (stemmedRevs) {
    traverseRevTree(result, function (isLeaf, pos, revHash) {
      // some revisions may have been removed in a branch but not in another
      delete stemmedRevs[pos + '-' + revHash];
    });
  }

  return {
    tree: result,
    revs: stemmedRevs ? Object.keys(stemmedRevs) : []
  };
}

function merge(tree, path, depth) {
  var newTree = doMerge(tree, path);
  var stemmed = stem(newTree.tree, depth);
  return {
    tree: stemmed.tree,
    stemmedRevs: stemmed.revs,
    conflicts: newTree.conflicts
  };
}

// return true if a rev exists in the rev tree, false otherwise
function revExists(revs, rev) {
  var toVisit = revs.slice();
  var splitRev = rev.split('-');
  var targetPos = parseInt(splitRev[0], 10);
  var targetId = splitRev[1];

  var node;
  while ((node = toVisit.pop())) {
    if (node.pos === targetPos && node.ids[0] === targetId) {
      return true;
    }
    var branches = node.ids[2];
    for (var i = 0, len = branches.length; i < len; i++) {
      toVisit.push({pos: node.pos + 1, ids: branches[i]});
    }
  }
  return false;
}

function getTrees(node) {
  return node.ids;
}

// check if a specific revision of a doc has been deleted
//  - metadata: the metadata object from the doc store
//  - rev: (optional) the revision to check. defaults to winning revision
function isDeleted(metadata, rev) {
  if (!rev) {
    rev = winningRev(metadata);
  }
  var id = rev.substring(rev.indexOf('-') + 1);
  var toVisit = metadata.rev_tree.map(getTrees);

  var tree;
  while ((tree = toVisit.pop())) {
    if (tree[0] === id) {
      return !!tree[1].deleted;
    }
    toVisit = toVisit.concat(tree[2]);
  }
}

function isLocalId(id) {
  return (/^_local/).test(id);
}

// returns the current leaf node for a given revision
function latest(rev, metadata) {
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var pos = node.pos;
    var tree = node.ids;
    var id = tree[0];
    var opts = tree[1];
    var branches = tree[2];
    var isLeaf = branches.length === 0;

    var history = node.history ? node.history.slice() : [];
    history.push({id: id, pos: pos, opts: opts});

    if (isLeaf) {
      for (var i = 0, len = history.length; i < len; i++) {
        var historyNode = history[i];
        var historyRev = historyNode.pos + '-' + historyNode.id;

        if (historyRev === rev) {
          // return the rev of this leaf
          return pos + '-' + id;
        }
      }
    }

    for (var j = 0, l = branches.length; j < l; j++) {
      toVisit.push({pos: pos + 1, ids: branches[j], history: history});
    }
  }

  /* istanbul ignore next */
  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(Changes$1, events__WEBPACK_IMPORTED_MODULE_6___default.a);

function tryCatchInChangeListener(self, change, pending, lastSeq) {
  // isolate try/catches to avoid V8 deoptimizations
  try {
    self.emit('change', change, pending, lastSeq);
  } catch (e) {
    guardedConsole('error', 'Error in .on("change", function):', e);
  }
}

function Changes$1(db, opts, callback) {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);
  var self = this;
  this.db = db;
  opts = opts ? clone(opts) : {};
  var complete = opts.complete = once(function (err, resp) {
    if (err) {
      if (listenerCount(self, 'error') > 0) {
        self.emit('error', err);
      }
    } else {
      self.emit('complete', resp);
    }
    self.removeAllListeners();
    db.removeListener('destroyed', onDestroy);
  });
  if (callback) {
    self.on('complete', function (resp) {
      callback(null, resp);
    });
    self.on('error', callback);
  }
  function onDestroy() {
    self.cancel();
  }
  db.once('destroyed', onDestroy);

  opts.onChange = function (change, pending, lastSeq) {
    /* istanbul ignore if */
    if (self.isCancelled) {
      return;
    }
    tryCatchInChangeListener(self, change, pending, lastSeq);
  };

  var promise = new Promise(function (fulfill, reject) {
    opts.complete = function (err, res) {
      if (err) {
        reject(err);
      } else {
        fulfill(res);
      }
    };
  });
  self.once('cancel', function () {
    db.removeListener('destroyed', onDestroy);
    opts.complete(null, {status: 'cancelled'});
  });
  this.then = promise.then.bind(promise);
  this['catch'] = promise['catch'].bind(promise);
  this.then(function (result) {
    complete(null, result);
  }, complete);



  if (!db.taskqueue.isReady) {
    db.taskqueue.addTask(function (failed) {
      if (failed) {
        opts.complete(failed);
      } else if (self.isCancelled) {
        self.emit('cancel');
      } else {
        self.validateChanges(opts);
      }
    });
  } else {
    self.validateChanges(opts);
  }
}
Changes$1.prototype.cancel = function () {
  this.isCancelled = true;
  if (this.db.taskqueue.isReady) {
    this.emit('cancel');
  }
};
function processChange(doc, metadata, opts) {
  var changeList = [{rev: doc._rev}];
  if (opts.style === 'all_docs') {
    changeList = collectLeaves(metadata.rev_tree)
    .map(function (x) { return {rev: x.rev}; });
  }
  var change = {
    id: metadata.id,
    changes: changeList,
    doc: doc
  };

  if (isDeleted(metadata, doc._rev)) {
    change.deleted = true;
  }
  if (opts.conflicts) {
    change.doc._conflicts = collectConflicts(metadata);
    if (!change.doc._conflicts.length) {
      delete change.doc._conflicts;
    }
  }
  return change;
}

Changes$1.prototype.validateChanges = function (opts) {
  var callback = opts.complete;
  var self = this;

  /* istanbul ignore else */
  if (PouchDB._changesFilterPlugin) {
    PouchDB._changesFilterPlugin.validate(opts, function (err) {
      if (err) {
        return callback(err);
      }
      self.doChanges(opts);
    });
  } else {
    self.doChanges(opts);
  }
};

Changes$1.prototype.doChanges = function (opts) {
  var self = this;
  var callback = opts.complete;

  opts = clone(opts);
  if ('live' in opts && !('continuous' in opts)) {
    opts.continuous = opts.live;
  }
  opts.processChange = processChange;

  if (opts.since === 'latest') {
    opts.since = 'now';
  }
  if (!opts.since) {
    opts.since = 0;
  }
  if (opts.since === 'now') {
    this.db.info().then(function (info) {
      /* istanbul ignore if */
      if (self.isCancelled) {
        callback(null, {status: 'cancelled'});
        return;
      }
      opts.since = info.update_seq;
      self.doChanges(opts);
    }, callback);
    return;
  }

  /* istanbul ignore else */
  if (PouchDB._changesFilterPlugin) {
    PouchDB._changesFilterPlugin.normalize(opts);
    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {
      return PouchDB._changesFilterPlugin.filter(this, opts);
    }
  } else {
    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {
      if (key in opts) {
        guardedConsole('warn',
          'The "' + key + '" option was passed in to changes/replicate, ' +
          'but pouchdb-changes-filter plugin is not installed, so it ' +
          'was ignored. Please install the plugin to enable filtering.'
        );
      }
    });
  }

  if (!('descending' in opts)) {
    opts.descending = false;
  }

  // 0 and 1 should return 1 document
  opts.limit = opts.limit === 0 ? 1 : opts.limit;
  opts.complete = callback;
  var newPromise = this.db._changes(opts);
  /* istanbul ignore else */
  if (newPromise && typeof newPromise.cancel === 'function') {
    var cancel = self.cancel;
    self.cancel = argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
      newPromise.cancel();
      cancel.apply(this, args);
    });
  }
};

/*
 * A generic pouch adapter
 */

function compare(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Wrapper for functions that call the bulkdocs api with a single doc,
// if the first result is an error, return an error
function yankError(callback, docId) {
  return function (err, results) {
    if (err || (results[0] && results[0].error)) {
      err = err || results[0];
      err.docId = docId;
      callback(err);
    } else {
      callback(null, results.length ? results[0]  : results);
    }
  };
}

// clean docs given to us by the user
function cleanDocs(docs) {
  for (var i = 0; i < docs.length; i++) {
    var doc = docs[i];
    if (doc._deleted) {
      delete doc._attachments; // ignore atts for deleted docs
    } else if (doc._attachments) {
      // filter out extraneous keys from _attachments
      var atts = Object.keys(doc._attachments);
      for (var j = 0; j < atts.length; j++) {
        var att = atts[j];
        doc._attachments[att] = pick(doc._attachments[att],
          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);
      }
    }
  }
}

// compare two docs, first by _id then by _rev
function compareByIdThenRev(a, b) {
  var idCompare = compare(a._id, b._id);
  if (idCompare !== 0) {
    return idCompare;
  }
  var aStart = a._revisions ? a._revisions.start : 0;
  var bStart = b._revisions ? b._revisions.start : 0;
  return compare(aStart, bStart);
}

// for every node in a revision tree computes its distance from the closest
// leaf
function computeHeight(revs) {
  var height = {};
  var edges = [];
  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
    var rev$$1 = pos + "-" + id;
    if (isLeaf) {
      height[rev$$1] = 0;
    }
    if (prnt !== undefined) {
      edges.push({from: prnt, to: rev$$1});
    }
    return rev$$1;
  });

  edges.reverse();
  edges.forEach(function (edge) {
    if (height[edge.from] === undefined) {
      height[edge.from] = 1 + height[edge.to];
    } else {
      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
    }
  });
  return height;
}

function allDocsKeysParse(opts) {
  var keys =  ('limit' in opts) ?
    opts.keys.slice(opts.skip, opts.limit + opts.skip) :
    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;
  opts.keys = keys;
  opts.skip = 0;
  delete opts.limit;
  if (opts.descending) {
    keys.reverse();
    opts.descending = false;
  }
}

// all compaction is done in a queue, to avoid attaching
// too many listeners at once
function doNextCompaction(self) {
  var task = self._compactionQueue[0];
  var opts = task.opts;
  var callback = task.callback;
  self.get('_local/compaction').catch(function () {
    return false;
  }).then(function (doc) {
    if (doc && doc.last_seq) {
      opts.last_seq = doc.last_seq;
    }
    self._compact(opts, function (err, res) {
      /* istanbul ignore if */
      if (err) {
        callback(err);
      } else {
        callback(null, res);
      }
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
        self._compactionQueue.shift();
        if (self._compactionQueue.length) {
          doNextCompaction(self);
        }
      });
    });
  });
}

function attachmentNameError(name) {
  if (name.charAt(0) === '_') {
    return name + ' is not a valid attachment name, attachment ' +
      'names cannot start with \\'_\\'';
  }
  return false;
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(AbstractPouchDB, events__WEBPACK_IMPORTED_MODULE_6___default.a);

function AbstractPouchDB() {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);

  // re-bind prototyped methods
  for (var p in AbstractPouchDB.prototype) {
    if (typeof this[p] === 'function') {
      this[p] = this[p].bind(this);
    }
  }
}

AbstractPouchDB.prototype.post =
  adapterFun('post', function (doc, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return callback(createError(NOT_AN_OBJECT));
  }
  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));
});

AbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof doc !== 'object' || Array.isArray(doc)) {
    return cb(createError(NOT_AN_OBJECT));
  }
  invalidIdError(doc._id);
  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {
    if (doc._deleted) {
      return this._removeLocal(doc, cb);
    } else {
      return this._putLocal(doc, cb);
    }
  }
  var self = this;
  if (opts.force && doc._rev) {
    transformForceOptionToNewEditsOption();
    putDoc(function (err) {
      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};
      cb(err, result);
    });
  } else {
    putDoc(cb);
  }

  function transformForceOptionToNewEditsOption() {
    var parts = doc._rev.split('-');
    var oldRevId = parts[1];
    var oldRevNum = parseInt(parts[0], 10);

    var newRevNum = oldRevNum + 1;
    var newRevId = rev();

    doc._revisions = {
      start: newRevNum,
      ids: [newRevId, oldRevId]
    };
    doc._rev = newRevNum + '-' + newRevId;
    opts.new_edits = false;
  }
  function putDoc(next) {
    if (typeof self._put === 'function' && opts.new_edits !== false) {
      self._put(doc, opts, next);
    } else {
      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));
    }
  }
});

AbstractPouchDB.prototype.putAttachment =
  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,
                                              blob, type) {
  var api = this;
  if (typeof type === 'function') {
    type = blob;
    blob = rev$$1;
    rev$$1 = null;
  }
  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267
  /* istanbul ignore if */
  if (typeof type === 'undefined') {
    type = blob;
    blob = rev$$1;
    rev$$1 = null;
  }
  if (!type) {
    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');
  }

  function createAttachment(doc) {
    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;
    doc._attachments = doc._attachments || {};
    doc._attachments[attachmentId] = {
      content_type: type,
      data: blob,
      revpos: ++prevrevpos
    };
    return api.put(doc);
  }

  return api.get(docId).then(function (doc) {
    if (doc._rev !== rev$$1) {
      throw createError(REV_CONFLICT);
    }

    return createAttachment(doc);
  }, function (err) {
     // create new doc
    /* istanbul ignore else */
    if (err.reason === MISSING_DOC.message) {
      return createAttachment({_id: docId});
    } else {
      throw err;
    }
  });
});

AbstractPouchDB.prototype.removeAttachment =
  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,
                                                 callback) {
  var self = this;
  self.get(docId, function (err, obj) {
    /* istanbul ignore if */
    if (err) {
      callback(err);
      return;
    }
    if (obj._rev !== rev$$1) {
      callback(createError(REV_CONFLICT));
      return;
    }
    /* istanbul ignore if */
    if (!obj._attachments) {
      return callback();
    }
    delete obj._attachments[attachmentId];
    if (Object.keys(obj._attachments).length === 0) {
      delete obj._attachments;
    }
    self.put(obj, callback);
  });
});

AbstractPouchDB.prototype.remove =
  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
  var doc;
  if (typeof optsOrRev === 'string') {
    // id, rev, opts, callback style
    doc = {
      _id: docOrId,
      _rev: optsOrRev
    };
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
  } else {
    // doc, opts, callback style
    doc = docOrId;
    if (typeof optsOrRev === 'function') {
      callback = optsOrRev;
      opts = {};
    } else {
      callback = opts;
      opts = optsOrRev;
    }
  }
  opts = opts || {};
  opts.was_delete = true;
  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};
  newDoc._deleted = true;
  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
    return this._removeLocal(doc, callback);
  }
  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));
});

AbstractPouchDB.prototype.revsDiff =
  adapterFun('revsDiff', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  var ids = Object.keys(req);

  if (!ids.length) {
    return callback(null, {});
  }

  var count = 0;
  var missing = new ExportedMap();

  function addToMissing(id, revId) {
    if (!missing.has(id)) {
      missing.set(id, {missing: []});
    }
    missing.get(id).missing.push(revId);
  }

  function processDoc(id, rev_tree) {
    // Is this fast enough? Maybe we should switch to a set simulated by a map
    var missingForId = req[id].slice(0);
    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,
      opts) {
        var rev$$1 = pos + '-' + revHash;
        var idx = missingForId.indexOf(rev$$1);
        if (idx === -1) {
          return;
        }

        missingForId.splice(idx, 1);
        /* istanbul ignore if */
        if (opts.status !== 'available') {
          addToMissing(id, rev$$1);
        }
      });

    // Traversing the tree is synchronous, so now \`missingForId\` contains
    // revisions that were not found in the tree
    missingForId.forEach(function (rev$$1) {
      addToMissing(id, rev$$1);
    });
  }

  ids.map(function (id) {
    this._getRevisionTree(id, function (err, rev_tree) {
      if (err && err.status === 404 && err.message === 'missing') {
        missing.set(id, {missing: req[id]});
      } else if (err) {
        /* istanbul ignore next */
        return callback(err);
      } else {
        processDoc(id, rev_tree);
      }

      if (++count === ids.length) {
        // convert LazyMap to object
        var missingObj = {};
        missing.forEach(function (value, key) {
          missingObj[key] = value;
        });
        return callback(null, missingObj);
      }
    });
  }, this);
});

// _bulk_get API for faster replication, as described in
// https://github.com/apache/couchdb-chttpd/pull/33
// At the "abstract" level, it will just run multiple get()s in
// parallel, because this isn't much of a performance cost
// for local databases (except the cost of multiple transactions, which is
// small). The http adapter overrides this in order
// to do a more efficient single HTTP request.
AbstractPouchDB.prototype.bulkGet =
  adapterFun('bulkGet', function (opts, callback) {
  bulkGet(this, opts, callback);
});

// compact one document and fire callback
// by compacting we mean removing all revisions which
// are further from the leaf in revision tree than max_height
AbstractPouchDB.prototype.compactDocument =
  adapterFun('compactDocument', function (docId, maxHeight, callback) {
  var self = this;
  this._getRevisionTree(docId, function (err, revTree) {
    /* istanbul ignore if */
    if (err) {
      return callback(err);
    }
    var height = computeHeight(revTree);
    var candidates = [];
    var revs = [];
    Object.keys(height).forEach(function (rev$$1) {
      if (height[rev$$1] > maxHeight) {
        candidates.push(rev$$1);
      }
    });

    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
      var rev$$1 = pos + '-' + revHash;
      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {
        revs.push(rev$$1);
      }
    });
    self._doCompaction(docId, revs, callback);
  });
});

// compact the whole database using single document
// compaction
AbstractPouchDB.prototype.compact =
  adapterFun('compact', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  opts = opts || {};

  self._compactionQueue = self._compactionQueue || [];
  self._compactionQueue.push({opts: opts, callback: callback});
  if (self._compactionQueue.length === 1) {
    doNextCompaction(self);
  }
});
AbstractPouchDB.prototype._compact = function (opts, callback) {
  var self = this;
  var changesOpts = {
    return_docs: false,
    last_seq: opts.last_seq || 0
  };
  var promises = [];

  function onChange(row) {
    promises.push(self.compactDocument(row.id, 0));
  }
  function onComplete(resp) {
    var lastSeq = resp.last_seq;
    Promise.all(promises).then(function () {
      return upsert(self, '_local/compaction', function deltaFunc(doc) {
        if (!doc.last_seq || doc.last_seq < lastSeq) {
          doc.last_seq = lastSeq;
          return doc;
        }
        return false; // somebody else got here first, don't update
      });
    }).then(function () {
      callback(null, {ok: true});
    }).catch(callback);
  }
  self.changes(changesOpts)
    .on('change', onChange)
    .on('complete', onComplete)
    .on('error', callback);
};

/* Begin api wrappers. Specific functionality to storage belongs in the
   _[method] */
AbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }
  if (typeof id !== 'string') {
    return cb(createError(INVALID_ID));
  }
  if (isLocalId(id) && typeof this._getLocal === 'function') {
    return this._getLocal(id, cb);
  }
  var leaves = [], self = this;

  function finishOpenRevs() {
    var result = [];
    var count = leaves.length;
    /* istanbul ignore if */
    if (!count) {
      return cb(null, result);
    }

    // order with open_revs is unspecified
    leaves.forEach(function (leaf) {
      self.get(id, {
        rev: leaf,
        revs: opts.revs,
        latest: opts.latest,
        attachments: opts.attachments,
        binary: opts.binary
      }, function (err, doc) {
        if (!err) {
          // using latest=true can produce duplicates
          var existing;
          for (var i = 0, l = result.length; i < l; i++) {
            if (result[i].ok && result[i].ok._rev === doc._rev) {
              existing = true;
              break;
            }
          }
          if (!existing) {
            result.push({ok: doc});
          }
        } else {
          result.push({missing: leaf});
        }
        count--;
        if (!count) {
          cb(null, result);
        }
      });
    });
  }

  if (opts.open_revs) {
    if (opts.open_revs === "all") {
      this._getRevisionTree(id, function (err, rev_tree) {
        /* istanbul ignore if */
        if (err) {
          return cb(err);
        }
        leaves = collectLeaves(rev_tree).map(function (leaf) {
          return leaf.rev;
        });
        finishOpenRevs();
      });
    } else {
      if (Array.isArray(opts.open_revs)) {
        leaves = opts.open_revs;
        for (var i = 0; i < leaves.length; i++) {
          var l = leaves[i];
          // looks like it's the only thing couchdb checks
          if (!(typeof (l) === "string" && /^\\d+-/.test(l))) {
            return cb(createError(INVALID_REV));
          }
        }
        finishOpenRevs();
      } else {
        return cb(createError(UNKNOWN_ERROR, 'function_clause'));
      }
    }
    return; // open_revs does not like other options
  }

  return this._get(id, opts, function (err, result) {
    if (err) {
      err.docId = id;
      return cb(err);
    }

    var doc = result.doc;
    var metadata = result.metadata;
    var ctx = result.ctx;

    if (opts.conflicts) {
      var conflicts = collectConflicts(metadata);
      if (conflicts.length) {
        doc._conflicts = conflicts;
      }
    }

    if (isDeleted(metadata, doc._rev)) {
      doc._deleted = true;
    }

    if (opts.revs || opts.revs_info) {
      var splittedRev = doc._rev.split('-');
      var revNo       = parseInt(splittedRev[0], 10);
      var revHash     = splittedRev[1];

      var paths = rootToLeaf(metadata.rev_tree);
      var path = null;

      for (var i = 0; i < paths.length; i++) {
        var currentPath = paths[i];
        var hashIndex = currentPath.ids.map(function (x) { return x.id; })
          .indexOf(revHash);
        var hashFoundAtRevPos = hashIndex === (revNo - 1);

        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {
          path = currentPath;
        }
      }

      /* istanbul ignore if */
      if (!path) {
        err = new Error('invalid rev tree');
        err.docId = id;
        return cb(err);
      }

      var indexOfRev = path.ids.map(function (x) { return x.id; })
        .indexOf(doc._rev.split('-')[1]) + 1;
      var howMany = path.ids.length - indexOfRev;
      path.ids.splice(indexOfRev, howMany);
      path.ids.reverse();

      if (opts.revs) {
        doc._revisions = {
          start: (path.pos + path.ids.length) - 1,
          ids: path.ids.map(function (rev$$1) {
            return rev$$1.id;
          })
        };
      }
      if (opts.revs_info) {
        var pos =  path.pos + path.ids.length;
        doc._revs_info = path.ids.map(function (rev$$1) {
          pos--;
          return {
            rev: pos + '-' + rev$$1.id,
            status: rev$$1.opts.status
          };
        });
      }
    }

    if (opts.attachments && doc._attachments) {
      var attachments = doc._attachments;
      var count = Object.keys(attachments).length;
      if (count === 0) {
        return cb(null, doc);
      }
      Object.keys(attachments).forEach(function (key) {
        this._getAttachment(doc._id, key, attachments[key], {
          // Previously the revision handling was done in adapter.js
          // getAttachment, however since idb-next doesnt we need to
          // pass the rev through
          rev: doc._rev,
          binary: opts.binary,
          ctx: ctx
        }, function (err, data) {
          var att = doc._attachments[key];
          att.data = data;
          delete att.stub;
          delete att.length;
          if (!--count) {
            cb(null, doc);
          }
        });
      }, self);
    } else {
      if (doc._attachments) {
        for (var key in doc._attachments) {
          /* istanbul ignore else */
          if (doc._attachments.hasOwnProperty(key)) {
            doc._attachments[key].stub = true;
          }
        }
      }
      cb(null, doc);
    }
  });
});

// TODO: I dont like this, it forces an extra read for every
// attachment read and enforces a confusing api between
// adapter.js and the adapter implementation
AbstractPouchDB.prototype.getAttachment =
  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {
  var self = this;
  if (opts instanceof Function) {
    callback = opts;
    opts = {};
  }
  this._get(docId, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (res.doc._attachments && res.doc._attachments[attachmentId]) {
      opts.ctx = res.ctx;
      opts.binary = true;
      self._getAttachment(docId, attachmentId,
                          res.doc._attachments[attachmentId], opts, callback);
    } else {
      return callback(createError(MISSING_DOC));
    }
  });
});

AbstractPouchDB.prototype.allDocs =
  adapterFun('allDocs', function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
  if (opts.start_key) {
    opts.startkey = opts.start_key;
  }
  if (opts.end_key) {
    opts.endkey = opts.end_key;
  }
  if ('keys' in opts) {
    if (!Array.isArray(opts.keys)) {
      return callback(new TypeError('options.keys must be an array'));
    }
    var incompatibleOpt =
      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
      return incompatibleOpt in opts;
    })[0];
    if (incompatibleOpt) {
      callback(createError(QUERY_PARSE_ERROR,
        'Query parameter \`' + incompatibleOpt +
        '\` is not compatible with multi-get'
      ));
      return;
    }
    if (!isRemote(this)) {
      allDocsKeysParse(opts);
      if (opts.keys.length === 0) {
        return this._allDocs({limit: 0}, callback);
      }
    }
  }

  return this._allDocs(opts, callback);
});

AbstractPouchDB.prototype.changes = function (opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = opts || {};

  // By default set return_docs to false if the caller has opts.live = true,
  // this will prevent us from collecting the set of changes indefinitely
  // resulting in growing memory
  opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;

  return new Changes$1(this, opts, callback);
};

AbstractPouchDB.prototype.close = adapterFun('close', function (callback) {
  this._closed = true;
  this.emit('closed');
  return this._close(callback);
});

AbstractPouchDB.prototype.info = adapterFun('info', function (callback) {
  var self = this;
  this._info(function (err, info) {
    if (err) {
      return callback(err);
    }
    // assume we know better than the adapter, unless it informs us
    info.db_name = info.db_name || self.name;
    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));
    info.adapter = self.adapter;
    callback(null, info);
  });
});

AbstractPouchDB.prototype.id = adapterFun('id', function (callback) {
  return this._id(callback);
});

/* istanbul ignore next */
AbstractPouchDB.prototype.type = function () {
  return (typeof this._type === 'function') ? this._type() : this.adapter;
};

AbstractPouchDB.prototype.bulkDocs =
  adapterFun('bulkDocs', function (req, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  opts = opts || {};

  if (Array.isArray(req)) {
    req = {
      docs: req
    };
  }

  if (!req || !req.docs || !Array.isArray(req.docs)) {
    return callback(createError(MISSING_BULK_DOCS));
  }

  for (var i = 0; i < req.docs.length; ++i) {
    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
      return callback(createError(NOT_AN_OBJECT));
    }
  }

  var attachmentError;
  req.docs.forEach(function (doc) {
    if (doc._attachments) {
      Object.keys(doc._attachments).forEach(function (name) {
        attachmentError = attachmentError || attachmentNameError(name);
        if (!doc._attachments[name].content_type) {
          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');
        }
      });
    }
  });

  if (attachmentError) {
    return callback(createError(BAD_REQUEST, attachmentError));
  }

  if (!('new_edits' in opts)) {
    if ('new_edits' in req) {
      opts.new_edits = req.new_edits;
    } else {
      opts.new_edits = true;
    }
  }

  var adapter = this;
  if (!opts.new_edits && !isRemote(adapter)) {
    // ensure revisions of the same doc are sorted, so that
    // the local adapter processes them correctly (#2935)
    req.docs.sort(compareByIdThenRev);
  }

  cleanDocs(req.docs);

  // in the case of conflicts, we want to return the _ids to the user
  // however, the underlying adapter may destroy the docs array, so
  // create a copy here
  var ids = req.docs.map(function (doc) {
    return doc._id;
  });

  return this._bulkDocs(req, opts, function (err, res) {
    if (err) {
      return callback(err);
    }
    if (!opts.new_edits) {
      // this is what couch does when new_edits is false
      res = res.filter(function (x) {
        return x.error;
      });
    }
    // add ids for error/conflict responses (not required for CouchDB)
    if (!isRemote(adapter)) {
      for (var i = 0, l = res.length; i < l; i++) {
        res[i].id = res[i].id || ids[i];
      }
    }

    callback(null, res);
  });
});

AbstractPouchDB.prototype.registerDependentDatabase =
  adapterFun('registerDependentDatabase', function (dependentDb,
                                                          callback) {
  var depDB = new this.constructor(dependentDb, this.__opts);

  function diffFun(doc) {
    doc.dependentDbs = doc.dependentDbs || {};
    if (doc.dependentDbs[dependentDb]) {
      return false; // no update required
    }
    doc.dependentDbs[dependentDb] = true;
    return doc;
  }
  upsert(this, '_local/_pouch_dependentDbs', diffFun)
    .then(function () {
      callback(null, {db: depDB});
    }).catch(callback);
});

AbstractPouchDB.prototype.destroy =
  adapterFun('destroy', function (opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  var self = this;
  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;

  function destroyDb() {
    // call destroy method of the particular adaptor
    self._destroy(opts, function (err, resp) {
      if (err) {
        return callback(err);
      }
      self._destroyed = true;
      self.emit('destroyed');
      callback(null, resp || { 'ok': true });
    });
  }

  if (isRemote(self)) {
    // no need to check for dependent DBs if it's a remote DB
    return destroyDb();
  }

  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {
    if (err) {
      /* istanbul ignore if */
      if (err.status !== 404) {
        return callback(err);
      } else { // no dependencies
        return destroyDb();
      }
    }
    var dependentDbs = localDoc.dependentDbs;
    var PouchDB = self.constructor;
    var deletedMap = Object.keys(dependentDbs).map(function (name) {
      // use_prefix is only false in the browser
      /* istanbul ignore next */
      var trueName = usePrefix ?
        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
      return new PouchDB(trueName, self.__opts).destroy();
    });
    Promise.all(deletedMap).then(destroyDb, callback);
  });
});

function TaskQueue() {
  this.isReady = false;
  this.failed = false;
  this.queue = [];
}

TaskQueue.prototype.execute = function () {
  var fun;
  if (this.failed) {
    while ((fun = this.queue.shift())) {
      fun(this.failed);
    }
  } else {
    while ((fun = this.queue.shift())) {
      fun();
    }
  }
};

TaskQueue.prototype.fail = function (err) {
  this.failed = err;
  this.execute();
};

TaskQueue.prototype.ready = function (db) {
  this.isReady = true;
  this.db = db;
  this.execute();
};

TaskQueue.prototype.addTask = function (fun) {
  this.queue.push(fun);
  if (this.failed) {
    this.execute();
  }
};

function parseAdapter(name, opts) {
  var match = name.match(/([a-z-]*):\\/\\/(.*)/);
  if (match) {
    // the http adapter expects the fully qualified name
    return {
      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],
      adapter: match[1]
    };
  }

  var adapters = PouchDB.adapters;
  var preferredAdapters = PouchDB.preferredAdapters;
  var prefix = PouchDB.prefix;
  var adapterName = opts.adapter;

  if (!adapterName) { // automatically determine adapter
    for (var i = 0; i < preferredAdapters.length; ++i) {
      adapterName = preferredAdapters[i];
      // check for browsers that have been upgraded from websql-only to websql+idb
      /* istanbul ignore if */
      if (adapterName === 'idb' && 'websql' in adapters &&
          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {
        // log it, because this can be confusing during development
        guardedConsole('log', 'PouchDB is downgrading "' + name + '" to WebSQL to' +
          ' avoid data loss, because it was already opened with WebSQL.');
        continue; // keep using websql to avoid user data loss
      }
      break;
    }
  }

  var adapter = adapters[adapterName];

  // if adapter is invalid, then an error will be thrown later
  var usePrefix = (adapter && 'use_prefix' in adapter) ?
    adapter.use_prefix : true;

  return {
    name: usePrefix ? (prefix + name) : name,
    adapter: adapterName
  };
}

// OK, so here's the deal. Consider this code:
//     var db1 = new PouchDB('foo');
//     var db2 = new PouchDB('foo');
//     db1.destroy();
// ^ these two both need to emit 'destroyed' events,
// as well as the PouchDB constructor itself.
// So we have one db object (whichever one got destroy() called on it)
// responsible for emitting the initial event, which then gets emitted
// by the constructor, which then broadcasts it to any other dbs
// that may have been created with the same name.
function prepareForDestruction(self) {

  function onDestroyed(from_constructor) {
    self.removeListener('closed', onClosed);
    if (!from_constructor) {
      self.constructor.emit('destroyed', self.name);
    }
  }

  function onClosed() {
    self.removeListener('destroyed', onDestroyed);
    self.constructor.emit('unref', self);
  }

  self.once('destroyed', onDestroyed);
  self.once('closed', onClosed);
  self.constructor.emit('ref', self);
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(PouchDB, AbstractPouchDB);
function PouchDB(name, opts) {
  // In Node our test suite only tests this for PouchAlt unfortunately
  /* istanbul ignore if */
  if (!(this instanceof PouchDB)) {
    return new PouchDB(name, opts);
  }

  var self = this;
  opts = opts || {};

  if (name && typeof name === 'object') {
    opts = name;
    name = opts.name;
    delete opts.name;
  }

  if (opts.deterministic_revs === undefined) {
    opts.deterministic_revs = true;
  }

  this.__opts = opts = clone(opts);

  self.auto_compaction = opts.auto_compaction;
  self.prefix = PouchDB.prefix;

  if (typeof name !== 'string') {
    throw new Error('Missing/invalid DB name');
  }

  var prefixedName = (opts.prefix || '') + name;
  var backend = parseAdapter(prefixedName, opts);

  opts.name = backend.name;
  opts.adapter = opts.adapter || backend.adapter;

  self.name = name;
  self._adapter = opts.adapter;
  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);

  if (!PouchDB.adapters[opts.adapter] ||
      !PouchDB.adapters[opts.adapter].valid()) {
    throw new Error('Invalid Adapter: ' + opts.adapter);
  }

  AbstractPouchDB.call(self);
  self.taskqueue = new TaskQueue();

  self.adapter = opts.adapter;

  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {
    if (err) {
      return self.taskqueue.fail(err);
    }
    prepareForDestruction(self);

    self.emit('created', self);
    PouchDB.emit('created', self.name);
    self.taskqueue.ready(self);
  });

}

// AbortController was introduced quite a while after fetch and
// isnt required for PouchDB to function so polyfill if needed
var a = (typeof AbortController !== 'undefined')
    ? AbortController
    : function () { return {abort: function () {}}; };

var f$1 = fetch;
var h = Headers;

PouchDB.adapters = {};
PouchDB.preferredAdapters = [];

PouchDB.prefix = '_pouch_';

var eventEmitter = new events__WEBPACK_IMPORTED_MODULE_6___default.a();

function setUpEventEmitter(Pouch) {
  Object.keys(events__WEBPACK_IMPORTED_MODULE_6___default.a.prototype).forEach(function (key) {
    if (typeof events__WEBPACK_IMPORTED_MODULE_6___default.a.prototype[key] === 'function') {
      Pouch[key] = eventEmitter[key].bind(eventEmitter);
    }
  });

  // these are created in constructor.js, and allow us to notify each DB with
  // the same name that it was destroyed, via the constructor object
  var destructListeners = Pouch._destructionListeners = new ExportedMap();

  Pouch.on('ref', function onConstructorRef(db) {
    if (!destructListeners.has(db.name)) {
      destructListeners.set(db.name, []);
    }
    destructListeners.get(db.name).push(db);
  });

  Pouch.on('unref', function onConstructorUnref(db) {
    if (!destructListeners.has(db.name)) {
      return;
    }
    var dbList = destructListeners.get(db.name);
    var pos = dbList.indexOf(db);
    if (pos < 0) {
      /* istanbul ignore next */
      return;
    }
    dbList.splice(pos, 1);
    if (dbList.length > 1) {
      /* istanbul ignore next */
      destructListeners.set(db.name, dbList);
    } else {
      destructListeners.delete(db.name);
    }
  });

  Pouch.on('destroyed', function onConstructorDestroyed(name) {
    if (!destructListeners.has(name)) {
      return;
    }
    var dbList = destructListeners.get(name);
    destructListeners.delete(name);
    dbList.forEach(function (db) {
      db.emit('destroyed',true);
    });
  });
}

setUpEventEmitter(PouchDB);

PouchDB.adapter = function (id, obj, addToPreferredAdapters) {
  /* istanbul ignore else */
  if (obj.valid()) {
    PouchDB.adapters[id] = obj;
    if (addToPreferredAdapters) {
      PouchDB.preferredAdapters.push(id);
    }
  }
};

PouchDB.plugin = function (obj) {
  if (typeof obj === 'function') { // function style for plugins
    obj(PouchDB);
  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {
    throw new Error('Invalid plugin: got "' + obj + '", expected an object or a function');
  } else {
    Object.keys(obj).forEach(function (id) { // object style for plugins
      PouchDB.prototype[id] = obj[id];
    });
  }
  if (this.__defaults) {
    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);
  }
  return PouchDB;
};

PouchDB.defaults = function (defaultOpts) {
  function PouchAlt(name, opts) {
    if (!(this instanceof PouchAlt)) {
      return new PouchAlt(name, opts);
    }

    opts = opts || {};

    if (name && typeof name === 'object') {
      opts = name;
      name = opts.name;
      delete opts.name;
    }

    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);
    PouchDB.call(this, name, opts);
  }

  inherits__WEBPACK_IMPORTED_MODULE_5___default()(PouchAlt, PouchDB);

  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();
  Object.keys(PouchDB).forEach(function (key) {
    if (!(key in PouchAlt)) {
      PouchAlt[key] = PouchDB[key];
    }
  });

  // make default options transitive
  // https://github.com/pouchdb/pouchdb/issues/5922
  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);

  return PouchAlt;
};

PouchDB.fetch = function (url, opts) {
  return f$1(url, opts);
};

// managed automatically by set-version.js
var version = "7.2.2";

// this would just be "return doc[field]", but fields
// can be "deep" due to dot notation
function getFieldFromDoc(doc, parsedField) {
  var value = doc;
  for (var i = 0, len = parsedField.length; i < len; i++) {
    var key = parsedField[i];
    value = value[key];
    if (!value) {
      break;
    }
  }
  return value;
}

function compare$1(left, right) {
  return left < right ? -1 : left > right ? 1 : 0;
}

// Converts a string in dot notation to an array of its components, with backslash escaping
function parseField(fieldName) {
  // fields may be deep (e.g. "foo.bar.baz"), so parse
  var fields = [];
  var current = '';
  for (var i = 0, len = fieldName.length; i < len; i++) {
    var ch = fieldName[i];
    if (ch === '.') {
      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter
        current = current.substring(0, current.length - 1) + '.';
      } else { // not escaped, so delimiter
        fields.push(current);
        current = '';
      }
    } else { // normal character
      current += ch;
    }
  }
  fields.push(current);
  return fields;
}

var combinationFields = ['$or', '$nor', '$not'];
function isCombinationalField(field) {
  return combinationFields.indexOf(field) > -1;
}

function getKey(obj) {
  return Object.keys(obj)[0];
}

function getValue(obj) {
  return obj[getKey(obj)];
}


// flatten an array of selectors joined by an $and operator
function mergeAndedSelectors(selectors) {

  // sort to ensure that e.g. if the user specified
  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into
  // just {$gt: 'b'}
  var res = {};

  selectors.forEach(function (selector) {
    Object.keys(selector).forEach(function (field) {
      var matcher = selector[field];
      if (typeof matcher !== 'object') {
        matcher = {$eq: matcher};
      }

      if (isCombinationalField(field)) {
        if (matcher instanceof Array) {
          res[field] = matcher.map(function (m) {
            return mergeAndedSelectors([m]);
          });
        } else {
          res[field] = mergeAndedSelectors([matcher]);
        }
      } else {
        var fieldMatchers = res[field] = res[field] || {};
        Object.keys(matcher).forEach(function (operator) {
          var value = matcher[operator];

          if (operator === '$gt' || operator === '$gte') {
            return mergeGtGte(operator, value, fieldMatchers);
          } else if (operator === '$lt' || operator === '$lte') {
            return mergeLtLte(operator, value, fieldMatchers);
          } else if (operator === '$ne') {
            return mergeNe(value, fieldMatchers);
          } else if (operator === '$eq') {
            return mergeEq(value, fieldMatchers);
          }
          fieldMatchers[operator] = value;
        });
      }
    });
  });

  return res;
}



// collapse logically equivalent gt/gte values
function mergeGtGte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$gte !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gte) { // more specificity
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value >= fieldMatchers.$gte) { // more specificity
        delete fieldMatchers.$gte;
        fieldMatchers.$gt = value;
      }
    }
  } else if (typeof fieldMatchers.$gt !== 'undefined') {
    if (operator === '$gte') {
      if (value > fieldMatchers.$gt) { // more specificity
        delete fieldMatchers.$gt;
        fieldMatchers.$gte = value;
      }
    } else { // operator === '$gt'
      if (value > fieldMatchers.$gt) { // more specificity
        fieldMatchers.$gt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// collapse logically equivalent lt/lte values
function mergeLtLte(operator, value, fieldMatchers) {
  if (typeof fieldMatchers.$eq !== 'undefined') {
    return; // do nothing
  }
  if (typeof fieldMatchers.$lte !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lte) { // more specificity
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value <= fieldMatchers.$lte) { // more specificity
        delete fieldMatchers.$lte;
        fieldMatchers.$lt = value;
      }
    }
  } else if (typeof fieldMatchers.$lt !== 'undefined') {
    if (operator === '$lte') {
      if (value < fieldMatchers.$lt) { // more specificity
        delete fieldMatchers.$lt;
        fieldMatchers.$lte = value;
      }
    } else { // operator === '$gt'
      if (value < fieldMatchers.$lt) { // more specificity
        fieldMatchers.$lt = value;
      }
    }
  } else {
    fieldMatchers[operator] = value;
  }
}

// combine $ne values into one array
function mergeNe(value, fieldMatchers) {
  if ('$ne' in fieldMatchers) {
    // there are many things this could "not" be
    fieldMatchers.$ne.push(value);
  } else { // doesn't exist yet
    fieldMatchers.$ne = [value];
  }
}

// add $eq into the mix
function mergeEq(value, fieldMatchers) {
  // these all have less specificity than the $eq
  // TODO: check for user errors here
  delete fieldMatchers.$gt;
  delete fieldMatchers.$gte;
  delete fieldMatchers.$lt;
  delete fieldMatchers.$lte;
  delete fieldMatchers.$ne;
  fieldMatchers.$eq = value;
}

//#7458: execute function mergeAndedSelectors on nested $and
function mergeAndedSelectorsNested(obj) {
    for (var prop in obj) {
        if (Array.isArray(obj)) {
            for (var i in obj) {
                if (obj[i]['$and']) {
                    obj[i] = mergeAndedSelectors(obj[i]['$and']);
                }
            }
        }
        var value = obj[prop];
        if (typeof value === 'object') {
            mergeAndedSelectorsNested(value); // <- recursive call
        }
    }
    return obj;
}

//#7458: determine id $and is present in selector (at any level)
function isAndInSelector(obj, isAnd) {
    for (var prop in obj) {
        if (prop === '$and') {
            isAnd = true;
        }
        var value = obj[prop];
        if (typeof value === 'object') {
            isAnd = isAndInSelector(value, isAnd); // <- recursive call
        }
    }
    return isAnd;
}

//
// normalize the selector
//
function massageSelector(input) {
  var result = clone(input);
  var wasAnded = false;
    //#7458: if $and is present in selector (at any level) merge nested $and
    if (isAndInSelector(result, false)) {
        result = mergeAndedSelectorsNested(result);
        if ('$and' in result) {
            result = mergeAndedSelectors(result['$and']);
        }
        wasAnded = true;
    }

  ['$or', '$nor'].forEach(function (orOrNor) {
    if (orOrNor in result) {
      // message each individual selector
      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}
      result[orOrNor].forEach(function (subSelector) {
        var fields = Object.keys(subSelector);
        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];
          var matcher = subSelector[field];
          if (typeof matcher !== 'object' || matcher === null) {
            subSelector[field] = {$eq: matcher};
          }
        }
      });
    }
  });

  if ('$not' in result) {
    //This feels a little like forcing, but it will work for now,
    //I would like to come back to this and make the merging of selectors a little more generic
    result['$not'] = mergeAndedSelectors([result['$not']]);
  }

  var fields = Object.keys(result);

  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    var matcher = result[field];

    if (typeof matcher !== 'object' || matcher === null) {
      matcher = {$eq: matcher};
    } else if ('$ne' in matcher && !wasAnded) {
      // I put these in an array, since there may be more than one
      // but in the "mergeAnded" operation, I already take care of that
      matcher.$ne = [matcher.$ne];
    }
    result[field] = matcher;
  }

  return result;
}

function pad(str, padWith, upToLength) {
  var padding = '';
  var targetLength = upToLength - str.length;
  /* istanbul ignore next */
  while (padding.length < targetLength) {
    padding += padWith;
  }
  return padding;
}

function padLeft(str, padWith, upToLength) {
  var padding = pad(str, padWith, upToLength);
  return padding + str;
}

var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
var MAGNITUDE_DIGITS = 3; // ditto
var SEP = ''; // set to '_' for easier debugging 

function collate(a, b) {

  if (a === b) {
    return 0;
  }

  a = normalizeKey(a);
  b = normalizeKey(b);

  var ai = collationIndex(a);
  var bi = collationIndex(b);
  if ((ai - bi) !== 0) {
    return ai - bi;
  }
  switch (typeof a) {
    case 'number':
      return a - b;
    case 'boolean':
      return a < b ? -1 : 1;
    case 'string':
      return stringCollate(a, b);
  }
  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
}

// couch considers null/NaN/Infinity/-Infinity === undefined,
// for the purposes of mapreduce indexes. also, dates get stringified.
function normalizeKey(key) {
  switch (typeof key) {
    case 'undefined':
      return null;
    case 'number':
      if (key === Infinity || key === -Infinity || isNaN(key)) {
        return null;
      }
      return key;
    case 'object':
      var origKey = key;
      if (Array.isArray(key)) {
        var len = key.length;
        key = new Array(len);
        for (var i = 0; i < len; i++) {
          key[i] = normalizeKey(origKey[i]);
        }
      /* istanbul ignore next */
      } else if (key instanceof Date) {
        return key.toJSON();
      } else if (key !== null) { // generic object
        key = {};
        for (var k in origKey) {
          if (origKey.hasOwnProperty(k)) {
            var val = origKey[k];
            if (typeof val !== 'undefined') {
              key[k] = normalizeKey(val);
            }
          }
        }
      }
  }
  return key;
}

function indexify(key) {
  if (key !== null) {
    switch (typeof key) {
      case 'boolean':
        return key ? 1 : 0;
      case 'number':
        return numToIndexableString(key);
      case 'string':
        // We've to be sure that key does not contain \\u0000
        // Do order-preserving replacements:
        // 0 -> 1, 1
        // 1 -> 1, 2
        // 2 -> 2, 2
        /* eslint-disable no-control-regex */
        return key
          .replace(/\\u0002/g, '\\u0002\\u0002')
          .replace(/\\u0001/g, '\\u0001\\u0002')
          .replace(/\\u0000/g, '\\u0001\\u0001');
        /* eslint-enable no-control-regex */
      case 'object':
        var isArray = Array.isArray(key);
        var arr = isArray ? key : Object.keys(key);
        var i = -1;
        var len = arr.length;
        var result = '';
        if (isArray) {
          while (++i < len) {
            result += toIndexableString(arr[i]);
          }
        } else {
          while (++i < len) {
            var objKey = arr[i];
            result += toIndexableString(objKey) +
                toIndexableString(key[objKey]);
          }
        }
        return result;
    }
  }
  return '';
}

// convert the given key to a string that would be appropriate
// for lexical sorting, e.g. within a database, where the
// sorting is the same given by the collate() function.
function toIndexableString(key) {
  var zero = '\\u0000';
  key = normalizeKey(key);
  return collationIndex(key) + SEP + indexify(key) + zero;
}

function parseNumber(str, i) {
  var originalIdx = i;
  var num;
  var zero = str[i] === '1';
  if (zero) {
    num = 0;
    i++;
  } else {
    var neg = str[i] === '0';
    i++;
    var numAsString = '';
    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
    /* istanbul ignore next */
    if (neg) {
      magnitude = -magnitude;
    }
    i += MAGNITUDE_DIGITS;
    while (true) {
      var ch = str[i];
      if (ch === '\\u0000') {
        break;
      } else {
        numAsString += ch;
      }
      i++;
    }
    numAsString = numAsString.split('.');
    if (numAsString.length === 1) {
      num = parseInt(numAsString, 10);
    } else {
      /* istanbul ignore next */
      num = parseFloat(numAsString[0] + '.' + numAsString[1]);
    }
    /* istanbul ignore next */
    if (neg) {
      num = num - 10;
    }
    /* istanbul ignore next */
    if (magnitude !== 0) {
      // parseFloat is more reliable than pow due to rounding errors
      // e.g. Number.MAX_VALUE would return Infinity if we did
      // num * Math.pow(10, magnitude);
      num = parseFloat(num + 'e' + magnitude);
    }
  }
  return {num: num, length : i - originalIdx};
}

// move up the stack while parsing
// this function moved outside of parseIndexableString for performance
function pop(stack, metaStack) {
  var obj = stack.pop();

  if (metaStack.length) {
    var lastMetaElement = metaStack[metaStack.length - 1];
    if (obj === lastMetaElement.element) {
      // popping a meta-element, e.g. an object whose value is another object
      metaStack.pop();
      lastMetaElement = metaStack[metaStack.length - 1];
    }
    var element = lastMetaElement.element;
    var lastElementIndex = lastMetaElement.index;
    if (Array.isArray(element)) {
      element.push(obj);
    } else if (lastElementIndex === stack.length - 2) { // obj with key+value
      var key = stack.pop();
      element[key] = obj;
    } else {
      stack.push(obj); // obj with key only
    }
  }
}

function parseIndexableString(str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;

  /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
  while (true) {
    var collationIndex = str[i++];
    if (collationIndex === '\\u0000') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case '1':
        stack.push(null);
        break;
      case '2':
        stack.push(str[i] === '1');
        i++;
        break;
      case '3':
        var parsedNum = parseNumber(str, i);
        stack.push(parsedNum.num);
        i += parsedNum.length;
        break;
      case '4':
        var parsedStr = '';
        /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
        while (true) {
          var ch = str[i];
          if (ch === '\\u0000') {
            break;
          }
          parsedStr += ch;
          i++;
        }
        // perform the reverse of the order-preserving replacement
        // algorithm (see above)
        /* eslint-disable no-control-regex */
        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')
          .replace(/\\u0001\\u0002/g, '\\u0001')
          .replace(/\\u0002\\u0002/g, '\\u0002');
        /* eslint-enable no-control-regex */
        stack.push(parsedStr);
        break;
      case '5':
        var arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '6':
        var objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      /* istanbul ignore next */
      default:
        throw new Error(
          'bad collationIndex or unexpectedly reached end of input: ' +
            collationIndex);
    }
  }
}

function arrayCollate(a, b) {
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; i++) {
    var sort = collate(a[i], b[i]);
    if (sort !== 0) {
      return sort;
    }
  }
  return (a.length === b.length) ? 0 :
    (a.length > b.length) ? 1 : -1;
}
function stringCollate(a, b) {
  // See: https://github.com/daleharvey/pouchdb/issues/40
  // This is incompatible with the CouchDB implementation, but its the
  // best we can do for now
  return (a === b) ? 0 : ((a > b) ? 1 : -1);
}
function objectCollate(a, b) {
  var ak = Object.keys(a), bk = Object.keys(b);
  var len = Math.min(ak.length, bk.length);
  for (var i = 0; i < len; i++) {
    // First sort the keys
    var sort = collate(ak[i], bk[i]);
    if (sort !== 0) {
      return sort;
    }
    // if the keys are equal sort the values
    sort = collate(a[ak[i]], b[bk[i]]);
    if (sort !== 0) {
      return sort;
    }

  }
  return (ak.length === bk.length) ? 0 :
    (ak.length > bk.length) ? 1 : -1;
}
// The collation is defined by erlangs ordered terms
// the atoms null, true, false come first, then numbers, strings,
// arrays, then objects
// null/undefined/NaN/Infinity/-Infinity are all considered null
function collationIndex(x) {
  var id = ['boolean', 'number', 'string', 'object'];
  var idx = id.indexOf(typeof x);
  //false if -1 otherwise true, but fast!!!!1
  if (~idx) {
    if (x === null) {
      return 1;
    }
    if (Array.isArray(x)) {
      return 5;
    }
    return idx < 3 ? (idx + 2) : (idx + 3);
  }
  /* istanbul ignore next */
  if (Array.isArray(x)) {
    return 5;
  }
}

// conversion:
// x yyy zz...zz
// x = 0 for negative, 1 for 0, 2 for positive
// y = exponent (for negative numbers negated) moved so that it's >= 0
// z = mantisse
function numToIndexableString(num) {

  if (num === 0) {
    return '1';
  }

  // convert number to exponential format for easier and
  // more succinct string sorting
  var expFormat = num.toExponential().split(/e\\+?/);
  var magnitude = parseInt(expFormat[1], 10);

  var neg = num < 0;

  var result = neg ? '0' : '2';

  // first sort by magnitude
  // it's easier if all magnitudes are positive
  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

  result += SEP + magString;

  // then sort by the factor
  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
  /* istanbul ignore next */
  if (neg) { // for negative reverse ordering
    factor = 10 - factor;
  }

  var factorStr = factor.toFixed(20);

  // strip zeros from the end
  factorStr = factorStr.replace(/\\.?0+$/, '');

  result += SEP + factorStr;

  return result;
}

// create a comparator based on the sort object
function createFieldSorter(sort) {

  function getFieldValuesAsArray(doc) {
    return sort.map(function (sorting) {
      var fieldName = getKey(sorting);
      var parsedField = parseField(fieldName);
      var docFieldValue = getFieldFromDoc(doc, parsedField);
      return docFieldValue;
    });
  }

  return function (aRow, bRow) {
    var aFieldValues = getFieldValuesAsArray(aRow.doc);
    var bFieldValues = getFieldValuesAsArray(bRow.doc);
    var collation = collate(aFieldValues, bFieldValues);
    if (collation !== 0) {
      return collation;
    }
    // this is what mango seems to do
    return compare$1(aRow.doc._id, bRow.doc._id);
  };
}

function filterInMemoryFields(rows, requestDef, inMemoryFields) {
  rows = rows.filter(function (row) {
    return rowFilter(row.doc, requestDef.selector, inMemoryFields);
  });

  if (requestDef.sort) {
    // in-memory sort
    var fieldSorter = createFieldSorter(requestDef.sort);
    rows = rows.sort(fieldSorter);
    if (typeof requestDef.sort[0] !== 'string' &&
        getValue(requestDef.sort[0]) === 'desc') {
      rows = rows.reverse();
    }
  }

  if ('limit' in requestDef || 'skip' in requestDef) {
    // have to do the limit in-memory
    var skip = requestDef.skip || 0;
    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;
    rows = rows.slice(skip, limit);
  }
  return rows;
}

function rowFilter(doc, selector, inMemoryFields) {
  return inMemoryFields.every(function (field) {
    var matcher = selector[field];
    var parsedField = parseField(field);
    var docFieldValue = getFieldFromDoc(doc, parsedField);
    if (isCombinationalField(field)) {
      return matchCominationalSelector(field, matcher, doc);
    }

    return matchSelector(matcher, doc, parsedField, docFieldValue);
  });
}

function matchSelector(matcher, doc, parsedField, docFieldValue) {
  if (!matcher) {
    // no filtering necessary; this field is just needed for sorting
    return true;
  }

  // is matcher an object, if so continue recursion
  if (typeof matcher === 'object') {
    return Object.keys(matcher).every(function (userOperator) {
      var userValue = matcher[userOperator];
      return match(userOperator, doc, userValue, parsedField, docFieldValue);
    });
  }

  // no more depth, No need to recurse further
  return matcher === docFieldValue;
}

function matchCominationalSelector(field, matcher, doc) {

  if (field === '$or') {
    return matcher.some(function (orMatchers) {
      return rowFilter(doc, orMatchers, Object.keys(orMatchers));
    });
  }

  if (field === '$not') {
    return !rowFilter(doc, matcher, Object.keys(matcher));
  }

  //\`$nor\`
  return !matcher.find(function (orMatchers) {
    return rowFilter(doc, orMatchers, Object.keys(orMatchers));
  });

}

function match(userOperator, doc, userValue, parsedField, docFieldValue) {
  if (!matchers[userOperator]) {
    throw new Error('unknown operator "' + userOperator +
      '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +
      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
  }
  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);
}

function fieldExists(docFieldValue) {
  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;
}

function fieldIsNotUndefined(docFieldValue) {
  return typeof docFieldValue !== 'undefined';
}

function modField(docFieldValue, userValue) {
  var divisor = userValue[0];
  var mod = userValue[1];
  if (divisor === 0) {
    throw new Error('Bad divisor, cannot divide by zero');
  }

  if (parseInt(divisor, 10) !== divisor ) {
    throw new Error('Divisor is not an integer');
  }

  if (parseInt(mod, 10) !== mod ) {
    throw new Error('Modulus is not an integer');
  }

  if (parseInt(docFieldValue, 10) !== docFieldValue) {
    return false;
  }

  return docFieldValue % divisor === mod;
}

function arrayContainsValue(docFieldValue, userValue) {
  return userValue.some(function (val) {
    if (docFieldValue instanceof Array) {
      return docFieldValue.indexOf(val) > -1;
    }

    return docFieldValue === val;
  });
}

function arrayContainsAllValues(docFieldValue, userValue) {
  return userValue.every(function (val) {
    return docFieldValue.indexOf(val) > -1;
  });
}

function arraySize(docFieldValue, userValue) {
  return docFieldValue.length === userValue;
}

function regexMatch(docFieldValue, userValue) {
  var re = new RegExp(userValue);

  return re.test(docFieldValue);
}

function typeMatch(docFieldValue, userValue) {

  switch (userValue) {
    case 'null':
      return docFieldValue === null;
    case 'boolean':
      return typeof (docFieldValue) === 'boolean';
    case 'number':
      return typeof (docFieldValue) === 'number';
    case 'string':
      return typeof (docFieldValue) === 'string';
    case 'array':
      return docFieldValue instanceof Array;
    case 'object':
      return ({}).toString.call(docFieldValue) === '[object Object]';
  }

  throw new Error(userValue + ' not supported as a type.' +
                  'Please use one of object, string, array, number, boolean or null.');

}

var matchers = {

  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.some(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.some(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {
    if (!Array.isArray(docFieldValue)) {
      return false;
    }

    /* istanbul ignore next */
    if (docFieldValue.length === 0) {
      return false;
    }

    if (typeof docFieldValue[0] === 'object') {
      return docFieldValue.every(function (val) {
        return rowFilter(val, userValue, Object.keys(userValue));
      });
    }

    return docFieldValue.every(function (val) {
      return matchSelector(userValue, doc, parsedField, val);
    });
  },

  '$eq': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;
  },

  '$gte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;
  },

  '$gt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;
  },

  '$lte': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;
  },

  '$lt': function (doc, userValue, parsedField, docFieldValue) {
    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;
  },

  '$exists': function (doc, userValue, parsedField, docFieldValue) {
    //a field that is null is still considered to exist
    if (userValue) {
      return fieldIsNotUndefined(docFieldValue);
    }

    return !fieldIsNotUndefined(docFieldValue);
  },

  '$mod': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);
  },

  '$ne': function (doc, userValue, parsedField, docFieldValue) {
    return userValue.every(function (neValue) {
      return collate(docFieldValue, neValue) !== 0;
    });
  },
  '$in': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);
  },

  '$nin': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);
  },

  '$size': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);
  },

  '$all': function (doc, userValue, parsedField, docFieldValue) {
    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);
  },

  '$regex': function (doc, userValue, parsedField, docFieldValue) {
    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);
  },

  '$type': function (doc, userValue, parsedField, docFieldValue) {
    return typeMatch(docFieldValue, userValue);
  }
};

// return true if the given doc matches the supplied selector
function matchesSelector(doc, selector) {
  /* istanbul ignore if */
  if (typeof selector !== 'object') {
    // match the CouchDB error message
    throw new Error('Selector error: expected a JSON object');
  }

  selector = massageSelector(selector);
  var row = {
    'doc': doc
  };

  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));
  return rowsMatched && rowsMatched.length === 1;
}

function evalFilter(input) {
  return scopeEval('"use strict";\\nreturn ' + input + ';', {});
}

function evalView(input) {
  var code = [
    'return function(doc) {',
    '  "use strict";',
    '  var emitted = false;',
    '  var emit = function (a, b) {',
    '    emitted = true;',
    '  };',
    '  var view = ' + input + ';',
    '  view(doc);',
    '  if (emitted) {',
    '    return true;',
    '  }',
    '};'
  ].join('\\n');

  return scopeEval(code, {});
}

function validate(opts, callback) {
  if (opts.selector) {
    if (opts.filter && opts.filter !== '_selector') {
      var filterName = typeof opts.filter === 'string' ?
        opts.filter : 'function';
      return callback(new Error('selector invalid for filter "' + filterName + '"'));
    }
  }
  callback();
}

function normalize(opts) {
  if (opts.view && !opts.filter) {
    opts.filter = '_view';
  }

  if (opts.selector && !opts.filter) {
    opts.filter = '_selector';
  }

  if (opts.filter && typeof opts.filter === 'string') {
    if (opts.filter === '_view') {
      opts.view = normalizeDesignDocFunctionName(opts.view);
    } else {
      opts.filter = normalizeDesignDocFunctionName(opts.filter);
    }
  }
}

function shouldFilter(changesHandler, opts) {
  return opts.filter && typeof opts.filter === 'string' &&
    !opts.doc_ids && !isRemote(changesHandler.db);
}

function filter(changesHandler, opts) {
  var callback = opts.complete;
  if (opts.filter === '_view') {
    if (!opts.view || typeof opts.view !== 'string') {
      var err = createError(BAD_REQUEST,
        '\`view\` filter parameter not found or invalid.');
      return callback(err);
    }
    // fetch a view from a design doc, make it behave like a filter
    var viewName = parseDesignDocFunctionName(opts.view);
    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&
        ddoc.views[viewName[1]].map;
      if (!mapFun) {
        return callback(createError(MISSING_DOC,
          (ddoc.views ? 'missing json key: ' + viewName[1] :
            'missing json key: views')));
      }
      opts.filter = evalView(mapFun);
      changesHandler.doChanges(opts);
    });
  } else if (opts.selector) {
    opts.filter = function (doc) {
      return matchesSelector(doc, opts.selector);
    };
    changesHandler.doChanges(opts);
  } else {
    // fetch a filter from a design doc
    var filterName = parseDesignDocFunctionName(opts.filter);
    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {
      /* istanbul ignore if */
      if (changesHandler.isCancelled) {
        return callback(null, {status: 'cancelled'});
      }
      /* istanbul ignore next */
      if (err) {
        return callback(generateErrorFromResponse(err));
      }
      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];
      if (!filterFun) {
        return callback(createError(MISSING_DOC,
          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]
            : 'missing json key: filters')));
      }
      opts.filter = evalFilter(filterFun);
      changesHandler.doChanges(opts);
    });
  }
}

function applyChangesFilterPlugin(PouchDB) {
  PouchDB._changesFilterPlugin = {
    validate: validate,
    normalize: normalize,
    shouldFilter: shouldFilter,
    filter: filter
  };
}

// TODO: remove from pouchdb-core (breaking)
PouchDB.plugin(applyChangesFilterPlugin);

PouchDB.version = version;

function toObject(array) {
  return array.reduce(function (obj, item) {
    obj[item] = true;
    return obj;
  }, {});
}
// List of top level reserved words for doc
var reservedWords = toObject([
  '_id',
  '_rev',
  '_attachments',
  '_deleted',
  '_revisions',
  '_revs_info',
  '_conflicts',
  '_deleted_conflicts',
  '_local_seq',
  '_rev_tree',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats',
  // Specific to Couchbase Sync Gateway
  '_removed'
]);

// List of reserved words that should end up the document
var dataWords = toObject([
  '_attachments',
  //replication documents
  '_replication_id',
  '_replication_state',
  '_replication_state_time',
  '_replication_state_reason',
  '_replication_stats'
]);

function parseRevisionInfo(rev$$1) {
  if (!/^\\d+-/.test(rev$$1)) {
    return createError(INVALID_REV);
  }
  var idx = rev$$1.indexOf('-');
  var left = rev$$1.substring(0, idx);
  var right = rev$$1.substring(idx + 1);
  return {
    prefix: parseInt(left, 10),
    id: right
  };
}

function makeRevTreeFromRevisions(revisions, opts) {
  var pos = revisions.start - revisions.ids.length + 1;

  var revisionIds = revisions.ids;
  var ids = [revisionIds[0], opts, []];

  for (var i = 1, len = revisionIds.length; i < len; i++) {
    ids = [revisionIds[i], {status: 'missing'}, [ids]];
  }

  return [{
    pos: pos,
    ids: ids
  }];
}

// Preprocess documents, parse their revisions, assign an id and a
// revision for new writes that are missing them, etc
function parseDoc(doc, newEdits, dbOpts) {
  if (!dbOpts) {
    dbOpts = {
      deterministic_revs: true
    };
  }

  var nRevNum;
  var newRevId;
  var revInfo;
  var opts = {status: 'available'};
  if (doc._deleted) {
    opts.deleted = true;
  }

  if (newEdits) {
    if (!doc._id) {
      doc._id = uuid();
    }
    newRevId = rev(doc, dbOpts.deterministic_revs);
    if (doc._rev) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      doc._rev_tree = [{
        pos: revInfo.prefix,
        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]
      }];
      nRevNum = revInfo.prefix + 1;
    } else {
      doc._rev_tree = [{
        pos: 1,
        ids : [newRevId, opts, []]
      }];
      nRevNum = 1;
    }
  } else {
    if (doc._revisions) {
      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
      nRevNum = doc._revisions.start;
      newRevId = doc._revisions.ids[0];
    }
    if (!doc._rev_tree) {
      revInfo = parseRevisionInfo(doc._rev);
      if (revInfo.error) {
        return revInfo;
      }
      nRevNum = revInfo.prefix;
      newRevId = revInfo.id;
      doc._rev_tree = [{
        pos: nRevNum,
        ids: [newRevId, opts, []]
      }];
    }
  }

  invalidIdError(doc._id);

  doc._rev = nRevNum + '-' + newRevId;

  var result = {metadata : {}, data : {}};
  for (var key in doc) {
    /* istanbul ignore else */
    if (Object.prototype.hasOwnProperty.call(doc, key)) {
      var specialKey = key[0] === '_';
      if (specialKey && !reservedWords[key]) {
        var error = createError(DOC_VALIDATION, key);
        error.message = DOC_VALIDATION.message + ': ' + key;
        throw error;
      } else if (specialKey && !dataWords[key]) {
        result.metadata[key.slice(1)] = doc[key];
      } else {
        result.data[key] = doc[key];
      }
    }
  }
  return result;
}

function parseBase64(data) {
  try {
    return thisAtob(data);
  } catch (e) {
    var err = createError(BAD_ARG,
      'Attachment is not a valid base64 string');
    return {error: err};
  }
}

function preprocessString(att, blobType, callback) {
  var asBinary = parseBase64(att.data);
  if (asBinary.error) {
    return callback(asBinary.error);
  }

  att.length = asBinary.length;
  if (blobType === 'blob') {
    att.data = binStringToBluffer(asBinary, att.content_type);
  } else if (blobType === 'base64') {
    att.data = thisBtoa(asBinary);
  } else { // binary
    att.data = asBinary;
  }
  binaryMd5(asBinary, function (result) {
    att.digest = 'md5-' + result;
    callback();
  });
}

function preprocessBlob(att, blobType, callback) {
  binaryMd5(att.data, function (md5) {
    att.digest = 'md5-' + md5;
    // size is for blobs (browser), length is for buffers (node)
    att.length = att.data.size || att.data.length || 0;
    if (blobType === 'binary') {
      blobToBinaryString(att.data, function (binString) {
        att.data = binString;
        callback();
      });
    } else if (blobType === 'base64') {
      blobToBase64(att.data, function (b64) {
        att.data = b64;
        callback();
      });
    } else {
      callback();
    }
  });
}

function preprocessAttachment(att, blobType, callback) {
  if (att.stub) {
    return callback();
  }
  if (typeof att.data === 'string') { // input is a base64 string
    preprocessString(att, blobType, callback);
  } else { // input is a blob
    preprocessBlob(att, blobType, callback);
  }
}

function preprocessAttachments(docInfos, blobType, callback) {

  if (!docInfos.length) {
    return callback();
  }

  var docv = 0;
  var overallErr;

  docInfos.forEach(function (docInfo) {
    var attachments = docInfo.data && docInfo.data._attachments ?
      Object.keys(docInfo.data._attachments) : [];
    var recv = 0;

    if (!attachments.length) {
      return done();
    }

    function processedAttachment(err) {
      overallErr = err;
      recv++;
      if (recv === attachments.length) {
        done();
      }
    }

    for (var key in docInfo.data._attachments) {
      if (docInfo.data._attachments.hasOwnProperty(key)) {
        preprocessAttachment(docInfo.data._attachments[key],
          blobType, processedAttachment);
      }
    }
  });

  function done() {
    docv++;
    if (docInfos.length === docv) {
      if (overallErr) {
        callback(overallErr);
      } else {
        callback();
      }
    }
  }
}

function updateDoc(revLimit, prev, docInfo, results,
                   i, cb, writeDoc, newEdits) {

  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {
    results[i] = docInfo;
    return cb();
  }

  // sometimes this is pre-calculated. historically not always
  var previousWinningRev = prev.winningRev || winningRev(prev);
  var previouslyDeleted = 'deleted' in prev ? prev.deleted :
    isDeleted(prev, previousWinningRev);
  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :
    isDeleted(docInfo.metadata);
  var isRoot = /^1-/.test(docInfo.metadata.rev);

  if (previouslyDeleted && !deleted && newEdits && isRoot) {
    var newDoc = docInfo.data;
    newDoc._rev = previousWinningRev;
    newDoc._id = docInfo.metadata.id;
    docInfo = parseDoc(newDoc, newEdits);
  }

  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);

  var inConflict = newEdits && ((
    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||
    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||
    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));

  if (inConflict) {
    var err = createError(REV_CONFLICT);
    results[i] = err;
    return cb();
  }

  var newRev = docInfo.metadata.rev;
  docInfo.metadata.rev_tree = merged.tree;
  docInfo.stemmedRevs = merged.stemmedRevs || [];
  /* istanbul ignore else */
  if (prev.rev_map) {
    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
  }

  // recalculate
  var winningRev$$1 = winningRev(docInfo.metadata);
  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);

  // calculate the total number of documents that were added/removed,
  // from the perspective of total_rows/doc_count
  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :
    previouslyDeleted < winningRevIsDeleted ? -1 : 1;

  var newRevIsDeleted;
  if (newRev === winningRev$$1) {
    // if the new rev is the same as the winning rev, we can reuse that value
    newRevIsDeleted = winningRevIsDeleted;
  } else {
    // if they're not the same, then we need to recalculate
    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);
  }

  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
    true, delta, i, cb);
}

function rootIsMissing(docInfo) {
  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
}

function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,
                     writeDoc, opts, overallCallback) {

  // Default to 1000 locally
  revLimit = revLimit || 1000;

  function insertDoc(docInfo, resultsIdx, callback) {
    // Cant insert new deleted documents
    var winningRev$$1 = winningRev(docInfo.metadata);
    var deleted = isDeleted(docInfo.metadata, winningRev$$1);
    if ('was_delete' in opts && deleted) {
      results[resultsIdx] = createError(MISSING_DOC, 'deleted');
      return callback();
    }

    // 4712 - detect whether a new document was inserted with a _rev
    var inConflict = newEdits && rootIsMissing(docInfo);

    if (inConflict) {
      var err = createError(REV_CONFLICT);
      results[resultsIdx] = err;
      return callback();
    }

    var delta = deleted ? 0 : 1;

    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,
      delta, resultsIdx, callback);
  }

  var newEdits = opts.new_edits;
  var idsToDocs = new ExportedMap();

  var docsDone = 0;
  var docsToDo = docInfos.length;

  function checkAllDocsDone() {
    if (++docsDone === docsToDo && overallCallback) {
      overallCallback();
    }
  }

  docInfos.forEach(function (currentDoc, resultsIdx) {

    if (currentDoc._id && isLocalId(currentDoc._id)) {
      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
      api[fun](currentDoc, {ctx: tx}, function (err, res) {
        results[resultsIdx] = err || res;
        checkAllDocsDone();
      });
      return;
    }

    var id = currentDoc.metadata.id;
    if (idsToDocs.has(id)) {
      docsToDo--; // duplicate
      idsToDocs.get(id).push([currentDoc, resultsIdx]);
    } else {
      idsToDocs.set(id, [[currentDoc, resultsIdx]]);
    }
  });

  // in the case of new_edits, the user can provide multiple docs
  // with the same id. these need to be processed sequentially
  idsToDocs.forEach(function (docs, id) {
    var numDone = 0;

    function docWritten() {
      if (++numDone < docs.length) {
        nextDoc();
      } else {
        checkAllDocsDone();
      }
    }
    function nextDoc() {
      var value = docs[numDone];
      var currentDoc = value[0];
      var resultsIdx = value[1];

      if (fetchedDocs.has(id)) {
        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,
          resultsIdx, docWritten, writeDoc, newEdits);
      } else {
        // Ensure stemming applies to new writes as well
        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);
        currentDoc.metadata.rev_tree = merged.tree;
        currentDoc.stemmedRevs = merged.stemmedRevs || [];
        insertDoc(currentDoc, resultsIdx, docWritten);
      }
    }
    nextDoc();
  });
}

// IndexedDB requires a versioned database structure, so we use the
// version here to manage migrations.
var ADAPTER_VERSION = 5;

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
// Keyed by document id
var DOC_STORE = 'document-store';
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
var BY_SEQ_STORE = 'by-sequence';
// Where we store attachments
var ATTACH_STORE = 'attach-store';
// Where we store many-to-many relations
// between attachment digests and seqs
var ATTACH_AND_SEQ_STORE = 'attach-seq-store';

// Where we store database-wide meta data in a single record
// keyed by id: META_STORE
var META_STORE = 'meta-store';
// Where we store local documents
var LOCAL_STORE = 'local-store';
// Where we detect blob support
var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

function safeJsonParse(str) {
  // This try/catch guards against stack overflow errors.
  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela
  // cannot overflow.
  try {
    return JSON.parse(str);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela__WEBPACK_IMPORTED_MODULE_3___default.a.parse(str);
  }
}

function safeJsonStringify(json) {
  try {
    return JSON.stringify(json);
  } catch (e) {
    /* istanbul ignore next */
    return vuvuzela__WEBPACK_IMPORTED_MODULE_3___default.a.stringify(json);
  }
}

function idbError(callback) {
  return function (evt) {
    var message = 'unknown_error';
    if (evt.target && evt.target.error) {
      message = evt.target.error.name || evt.target.error.message;
    }
    callback(createError(IDB_ERROR, message, evt.type));
  };
}

// Unfortunately, the metadata has to be stringified
// when it is put into the database, because otherwise
// IndexedDB can throw errors for deeply-nested objects.
// Originally we just used JSON.parse/JSON.stringify; now
// we use this custom vuvuzela library that avoids recursion.
// If we could do it all over again, we'd probably use a
// format for the revision trees other than JSON.
function encodeMetadata(metadata, winningRev, deleted) {
  return {
    data: safeJsonStringify(metadata),
    winningRev: winningRev,
    deletedOrLocal: deleted ? '1' : '0',
    seq: metadata.seq, // highest seq for this doc
    id: metadata.id
  };
}

function decodeMetadata(storedObject) {
  if (!storedObject) {
    return null;
  }
  var metadata = safeJsonParse(storedObject.data);
  metadata.winningRev = storedObject.winningRev;
  metadata.deleted = storedObject.deletedOrLocal === '1';
  metadata.seq = storedObject.seq;
  return metadata;
}

// read the doc back out from the database. we don't store the
// _id or _rev because we already have _doc_id_rev.
function decodeDoc(doc) {
  if (!doc) {
    return doc;
  }
  var idx = doc._doc_id_rev.lastIndexOf(':');
  doc._id = doc._doc_id_rev.substring(0, idx - 1);
  doc._rev = doc._doc_id_rev.substring(idx + 1);
  delete doc._doc_id_rev;
  return doc;
}

// Read a blob from the database, encoding as necessary
// and translating from base64 if the IDB doesn't support
// native Blobs
function readBlobData(body, type, asBlob, callback) {
  if (asBlob) {
    if (!body) {
      callback(createBlob([''], {type: type}));
    } else if (typeof body !== 'string') { // we have blob support
      callback(body);
    } else { // no blob support
      callback(b64ToBluffer(body, type));
    }
  } else { // as base64 string
    if (!body) {
      callback('');
    } else if (typeof body !== 'string') { // we have blob support
      readAsBinaryString(body, function (binary) {
        callback(thisBtoa(binary));
      });
    } else { // no blob support
      callback(body);
    }
  }
}

function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
  var attachments = Object.keys(doc._attachments || {});
  if (!attachments.length) {
    return cb && cb();
  }
  var numDone = 0;

  function checkDone() {
    if (++numDone === attachments.length && cb) {
      cb();
    }
  }

  function fetchAttachment(doc, att) {
    var attObj = doc._attachments[att];
    var digest = attObj.digest;
    var req = txn.objectStore(ATTACH_STORE).get(digest);
    req.onsuccess = function (e) {
      attObj.body = e.target.result.body;
      checkDone();
    };
  }

  attachments.forEach(function (att) {
    if (opts.attachments && opts.include_docs) {
      fetchAttachment(doc, att);
    } else {
      doc._attachments[att].stub = true;
      checkDone();
    }
  });
}

// IDB-specific postprocessing necessary because
// we don't know whether we stored a true Blob or
// a base64-encoded string, and if it's a Blob it
// needs to be read outside of the transaction context
function postProcessAttachments(results, asBlob) {
  return Promise.all(results.map(function (row) {
    if (row.doc && row.doc._attachments) {
      var attNames = Object.keys(row.doc._attachments);
      return Promise.all(attNames.map(function (att) {
        var attObj = row.doc._attachments[att];
        if (!('body' in attObj)) { // already processed
          return;
        }
        var body = attObj.body;
        var type = attObj.content_type;
        return new Promise(function (resolve) {
          readBlobData(body, type, asBlob, function (data) {
            row.doc._attachments[att] = $inject_Object_assign(
              pick(attObj, ['digest', 'content_type']),
              {data: data}
            );
            resolve();
          });
        });
      }));
    }
  }));
}

function compactRevs(revs, docId, txn) {

  var possiblyOrphanedDigests = [];
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var attStore = txn.objectStore(ATTACH_STORE);
  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
  var count = revs.length;

  function checkDone() {
    count--;
    if (!count) { // done processing all revs
      deleteOrphanedAttachments();
    }
  }

  function deleteOrphanedAttachments() {
    if (!possiblyOrphanedDigests.length) {
      return;
    }
    possiblyOrphanedDigests.forEach(function (digest) {
      var countReq = attAndSeqStore.index('digestSeq').count(
        IDBKeyRange.bound(
          digest + '::', digest + '::\\uffff', false, false));
      countReq.onsuccess = function (e) {
        var count = e.target.result;
        if (!count) {
          // orphaned
          attStore.delete(digest);
        }
      };
    });
  }

  revs.forEach(function (rev$$1) {
    var index = seqStore.index('_doc_id_rev');
    var key = docId + "::" + rev$$1;
    index.getKey(key).onsuccess = function (e) {
      var seq = e.target.result;
      if (typeof seq !== 'number') {
        return checkDone();
      }
      seqStore.delete(seq);

      var cursor = attAndSeqStore.index('seq')
        .openCursor(IDBKeyRange.only(seq));

      cursor.onsuccess = function (event) {
        var cursor = event.target.result;
        if (cursor) {
          var digest = cursor.value.digestSeq.split('::')[0];
          possiblyOrphanedDigests.push(digest);
          attAndSeqStore.delete(cursor.primaryKey);
          cursor.continue();
        } else { // done
          checkDone();
        }
      };
    };
  });
}

function openTransactionSafely(idb, stores, mode) {
  try {
    return {
      txn: idb.transaction(stores, mode)
    };
  } catch (err) {
    return {
      error: err
    };
  }
}

var changesHandler = new Changes();

function idbBulkDocs(dbOpts, req, opts, api, idb, callback) {
  var docInfos = req.docs;
  var txn;
  var docStore;
  var bySeqStore;
  var attachStore;
  var attachAndSeqStore;
  var metaStore;
  var docInfoError;
  var metaDoc;

  for (var i = 0, len = docInfos.length; i < len; i++) {
    var doc = docInfos[i];
    if (doc._id && isLocalId(doc._id)) {
      continue;
    }
    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);
    if (doc.error && !docInfoError) {
      docInfoError = doc;
    }
  }

  if (docInfoError) {
    return callback(docInfoError);
  }

  var allDocsProcessed = false;
  var docCountDelta = 0;
  var results = new Array(docInfos.length);
  var fetchedDocs = new ExportedMap();
  var preconditionErrored = false;
  var blobType = api._meta.blobSupport ? 'blob' : 'base64';

  preprocessAttachments(docInfos, blobType, function (err) {
    if (err) {
      return callback(err);
    }
    startTransaction();
  });

  function startTransaction() {

    var stores = [
      DOC_STORE, BY_SEQ_STORE,
      ATTACH_STORE,
      LOCAL_STORE, ATTACH_AND_SEQ_STORE,
      META_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    txn = txnResult.txn;
    txn.onabort = idbError(callback);
    txn.ontimeout = idbError(callback);
    txn.oncomplete = complete;
    docStore = txn.objectStore(DOC_STORE);
    bySeqStore = txn.objectStore(BY_SEQ_STORE);
    attachStore = txn.objectStore(ATTACH_STORE);
    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
    metaStore = txn.objectStore(META_STORE);

    metaStore.get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result;
      updateDocCountIfReady();
    };

    verifyAttachments(function (err) {
      if (err) {
        preconditionErrored = true;
        return callback(err);
      }
      fetchExistingDocs();
    });
  }

  function onAllDocsProcessed() {
    allDocsProcessed = true;
    updateDocCountIfReady();
  }

  function idbProcessDocs() {
    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,
                txn, results, writeDoc, opts, onAllDocsProcessed);
  }

  function updateDocCountIfReady() {
    if (!metaDoc || !allDocsProcessed) {
      return;
    }
    // caching the docCount saves a lot of time in allDocs() and
    // info(), which is why we go to all the trouble of doing this
    metaDoc.docCount += docCountDelta;
    metaStore.put(metaDoc);
  }

  function fetchExistingDocs() {

    if (!docInfos.length) {
      return;
    }

    var numFetched = 0;

    function checkDone() {
      if (++numFetched === docInfos.length) {
        idbProcessDocs();
      }
    }

    function readMetadata(event) {
      var metadata = decodeMetadata(event.target.result);

      if (metadata) {
        fetchedDocs.set(metadata.id, metadata);
      }
      checkDone();
    }

    for (var i = 0, len = docInfos.length; i < len; i++) {
      var docInfo = docInfos[i];
      if (docInfo._id && isLocalId(docInfo._id)) {
        checkDone(); // skip local docs
        continue;
      }
      var req = docStore.get(docInfo.metadata.id);
      req.onsuccess = readMetadata;
    }
  }

  function complete() {
    if (preconditionErrored) {
      return;
    }

    changesHandler.notify(api._meta.name);
    callback(null, results);
  }

  function verifyAttachment(digest, callback) {

    var req = attachStore.get(digest);
    req.onsuccess = function (e) {
      if (!e.target.result) {
        var err = createError(MISSING_STUB,
          'unknown stub attachment with digest ' +
          digest);
        err.status = 412;
        callback(err);
      } else {
        callback();
      }
    };
  }

  function verifyAttachments(finish) {


    var digests = [];
    docInfos.forEach(function (docInfo) {
      if (docInfo.data && docInfo.data._attachments) {
        Object.keys(docInfo.data._attachments).forEach(function (filename) {
          var att = docInfo.data._attachments[filename];
          if (att.stub) {
            digests.push(att.digest);
          }
        });
      }
    });
    if (!digests.length) {
      return finish();
    }
    var numDone = 0;
    var err;

    function checkDone() {
      if (++numDone === digests.length) {
        finish(err);
      }
    }
    digests.forEach(function (digest) {
      verifyAttachment(digest, function (attErr) {
        if (attErr && !err) {
          err = attErr;
        }
        checkDone();
      });
    });
  }

  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,
                    isUpdate, delta, resultsIdx, callback) {

    docInfo.metadata.winningRev = winningRev$$1;
    docInfo.metadata.deleted = winningRevIsDeleted;

    var doc = docInfo.data;
    doc._id = docInfo.metadata.id;
    doc._rev = docInfo.metadata.rev;

    if (newRevIsDeleted) {
      doc._deleted = true;
    }

    var hasAttachments = doc._attachments &&
      Object.keys(doc._attachments).length;
    if (hasAttachments) {
      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
        isUpdate, resultsIdx, callback);
    }

    docCountDelta += delta;
    updateDocCountIfReady();

    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
      isUpdate, resultsIdx, callback);
  }

  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
                     isUpdate, resultsIdx, callback) {

    var doc = docInfo.data;
    var metadata = docInfo.metadata;

    doc._doc_id_rev = metadata.id + '::' + metadata.rev;
    delete doc._id;
    delete doc._rev;

    function afterPutDoc(e) {
      var revsToDelete = docInfo.stemmedRevs || [];

      if (isUpdate && api.auto_compaction) {
        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));
      }

      if (revsToDelete && revsToDelete.length) {
        compactRevs(revsToDelete, docInfo.metadata.id, txn);
      }

      metadata.seq = e.target.result;
      // Current _rev is calculated from _rev_tree on read
      // delete metadata.rev;
      var metadataToStore = encodeMetadata(metadata, winningRev$$1,
        winningRevIsDeleted);
      var metaDataReq = docStore.put(metadataToStore);
      metaDataReq.onsuccess = afterPutMetadata;
    }

    function afterPutDocError(e) {
      // ConstraintError, need to update, not put (see #1638 for details)
      e.preventDefault(); // avoid transaction abort
      e.stopPropagation(); // avoid transaction onerror
      var index = bySeqStore.index('_doc_id_rev');
      var getKeyReq = index.getKey(doc._doc_id_rev);
      getKeyReq.onsuccess = function (e) {
        var putReq = bySeqStore.put(doc, e.target.result);
        putReq.onsuccess = afterPutDoc;
      };
    }

    function afterPutMetadata() {
      results[resultsIdx] = {
        ok: true,
        id: metadata.id,
        rev: metadata.rev
      };
      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
      insertAttachmentMappings(docInfo, metadata.seq, callback);
    }

    var putReq = bySeqStore.put(doc);

    putReq.onsuccess = afterPutDoc;
    putReq.onerror = afterPutDocError;
  }

  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,
                            isUpdate, resultsIdx, callback) {


    var doc = docInfo.data;

    var numDone = 0;
    var attachments = Object.keys(doc._attachments);

    function collectResults() {
      if (numDone === attachments.length) {
        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,
          isUpdate, resultsIdx, callback);
      }
    }

    function attachmentSaved() {
      numDone++;
      collectResults();
    }

    attachments.forEach(function (key) {
      var att = docInfo.data._attachments[key];
      if (!att.stub) {
        var data = att.data;
        delete att.data;
        att.revpos = parseInt(winningRev$$1, 10);
        var digest = att.digest;
        saveAttachment(digest, data, attachmentSaved);
      } else {
        numDone++;
        collectResults();
      }
    });
  }

  // map seqs to attachment digests, which
  // we will need later during compaction
  function insertAttachmentMappings(docInfo, seq, callback) {

    var attsAdded = 0;
    var attsToAdd = Object.keys(docInfo.data._attachments || {});

    if (!attsToAdd.length) {
      return callback();
    }

    function checkDone() {
      if (++attsAdded === attsToAdd.length) {
        callback();
      }
    }

    function add(att) {
      var digest = docInfo.data._attachments[att].digest;
      var req = attachAndSeqStore.put({
        seq: seq,
        digestSeq: digest + '::' + seq
      });

      req.onsuccess = checkDone;
      req.onerror = function (e) {
        // this callback is for a constaint error, which we ignore
        // because this docid/rev has already been associated with
        // the digest (e.g. when new_edits == false)
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
        checkDone();
      };
    }
    for (var i = 0; i < attsToAdd.length; i++) {
      add(attsToAdd[i]); // do in parallel
    }
  }

  function saveAttachment(digest, data, callback) {


    var getKeyReq = attachStore.count(digest);
    getKeyReq.onsuccess = function (e) {
      var count = e.target.result;
      if (count) {
        return callback(); // already exists
      }
      var newAtt = {
        digest: digest,
        body: data
      };
      var putReq = attachStore.put(newAtt);
      putReq.onsuccess = callback;
    };
  }
}

// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations
// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or
// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because
// we're not processing each document one-at-a-time.
function runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {

  if (batchSize === -1) {
    batchSize = 1000;
  }

  // Bail out of getAll()/getAllKeys() in the following cases:
  // 1) either method is unsupported - we need both
  // 2) batchSize is 1 (might as well use IDBCursor)
  // 3) descending  no real way to do this via getAll()/getAllKeys()

  var useGetAll = typeof objectStore.getAll === 'function' &&
    typeof objectStore.getAllKeys === 'function' &&
    batchSize > 1 && !descending;

  var keysBatch;
  var valuesBatch;
  var pseudoCursor;

  function onGetAll(e) {
    valuesBatch = e.target.result;
    if (keysBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function onGetAllKeys(e) {
    keysBatch = e.target.result;
    if (valuesBatch) {
      onBatch(keysBatch, valuesBatch, pseudoCursor);
    }
  }

  function continuePseudoCursor() {
    if (!keysBatch.length) { // no more results
      return onBatch();
    }
    // fetch next batch, exclusive start
    var lastKey = keysBatch[keysBatch.length - 1];
    var newKeyRange;
    if (keyRange && keyRange.upper) {
      try {
        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,
          true, keyRange.upperOpen);
      } catch (e) {
        if (e.name === "DataError" && e.code === 0) {
          return onBatch(); // we're done, startkey and endkey are equal
        }
      }
    } else {
      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
    }
    keyRange = newKeyRange;
    keysBatch = null;
    valuesBatch = null;
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  }

  function onCursor(e) {
    var cursor = e.target.result;
    if (!cursor) { // done
      return onBatch();
    }
    // regular IDBCursor acts like a batch where batch size is always 1
    onBatch([cursor.key], [cursor.value], cursor);
  }

  if (useGetAll) {
    pseudoCursor = {"continue": continuePseudoCursor};
    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
  } else if (descending) {
    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
  } else {
    objectStore.openCursor(keyRange).onsuccess = onCursor;
  }
}

// simple shim for objectStore.getAll(), falling back to IDBCursor
function getAll(objectStore, keyRange, onSuccess) {
  if (typeof objectStore.getAll === 'function') {
    // use native getAll
    objectStore.getAll(keyRange).onsuccess = onSuccess;
    return;
  }
  // fall back to cursors
  var values = [];

  function onCursor(e) {
    var cursor = e.target.result;
    if (cursor) {
      values.push(cursor.value);
      cursor.continue();
    } else {
      onSuccess({
        target: {
          result: values
        }
      });
    }
  }

  objectStore.openCursor(keyRange).onsuccess = onCursor;
}

function allDocsKeys(keys, docStore, onBatch) {
  // It's not guaranted to be returned in right order  
  var valuesBatch = new Array(keys.length);
  var count = 0;
  keys.forEach(function (key, index) {
    docStore.get(key).onsuccess = function (event) {
      if (event.target.result) {
        valuesBatch[index] = event.target.result;
      } else {
        valuesBatch[index] = {key: key, error: 'not_found'};
      }
      count++;
      if (count === keys.length) {
        onBatch(keys, valuesBatch, {});
      }
    };
  });
}

function createKeyRange(start, end, inclusiveEnd, key, descending) {
  try {
    if (start && end) {
      if (descending) {
        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
      } else {
        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
      }
    } else if (start) {
      if (descending) {
        return IDBKeyRange.upperBound(start);
      } else {
        return IDBKeyRange.lowerBound(start);
      }
    } else if (end) {
      if (descending) {
        return IDBKeyRange.lowerBound(end, !inclusiveEnd);
      } else {
        return IDBKeyRange.upperBound(end, !inclusiveEnd);
      }
    } else if (key) {
      return IDBKeyRange.only(key);
    }
  } catch (e) {
    return {error: e};
  }
  return null;
}

function idbAllDocs(opts, idb, callback) {
  var start = 'startkey' in opts ? opts.startkey : false;
  var end = 'endkey' in opts ? opts.endkey : false;
  var key = 'key' in opts ? opts.key : false;
  var keys = 'keys' in opts ? opts.keys : false; 
  var skip = opts.skip || 0;
  var limit = typeof opts.limit === 'number' ? opts.limit : -1;
  var inclusiveEnd = opts.inclusive_end !== false;

  var keyRange ; 
  var keyRangeError;
  if (!keys) {
    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);
    keyRangeError = keyRange && keyRange.error;
    if (keyRangeError && 
      !(keyRangeError.name === "DataError" && keyRangeError.code === 0)) {
      // DataError with error code 0 indicates start is less than end, so
      // can just do an empty query. Else need to throw
      return callback(createError(IDB_ERROR,
        keyRangeError.name, keyRangeError.message));
    }
  }

  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];

  if (opts.attachments) {
    stores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, stores, 'readonly');
  if (txnResult.error) {
    return callback(txnResult.error);
  }
  var txn = txnResult.txn;
  txn.oncomplete = onTxnComplete;
  txn.onabort = idbError(callback);
  var docStore = txn.objectStore(DOC_STORE);
  var seqStore = txn.objectStore(BY_SEQ_STORE);
  var metaStore = txn.objectStore(META_STORE);
  var docIdRevIndex = seqStore.index('_doc_id_rev');
  var results = [];
  var docCount;
  var updateSeq;

  metaStore.get(META_STORE).onsuccess = function (e) {
    docCount = e.target.result.docCount;
  };

  /* istanbul ignore if */
  if (opts.update_seq) {
    getMaxUpdateSeq(seqStore, function (e) { 
      if (e.target.result && e.target.result.length > 0) {
        updateSeq = e.target.result[0];
      }
    });
  }

  function getMaxUpdateSeq(objectStore, onSuccess) {
    function onCursor(e) {
      var cursor = e.target.result;
      var maxKey = undefined;
      if (cursor && cursor.key) {
        maxKey = cursor.key;
      } 
      return onSuccess({
        target: {
          result: [maxKey]
        }
      });
    }
    objectStore.openCursor(null, 'prev').onsuccess = onCursor;
  }

  // if the user specifies include_docs=true, then we don't
  // want to block the main cursor while we're fetching the doc
  function fetchDocAsynchronously(metadata, row, winningRev$$1) {
    var key = metadata.id + "::" + winningRev$$1;
    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {
      row.doc = decodeDoc(e.target.result) || {};
      if (opts.conflicts) {
        var conflicts = collectConflicts(metadata);
        if (conflicts.length) {
          row.doc._conflicts = conflicts;
        }
      }
      fetchAttachmentsIfNecessary(row.doc, opts, txn);
    };
  }

  function allDocsInner(winningRev$$1, metadata) {
    var row = {
      id: metadata.id,
      key: metadata.id,
      value: {
        rev: winningRev$$1
      }
    };
    var deleted = metadata.deleted;
    if (deleted) {
      if (keys) {
        results.push(row);
        // deleted docs are okay with "keys" requests
        row.value.deleted = true;
        row.doc = null;
      }
    } else if (skip-- <= 0) {
      results.push(row);
      if (opts.include_docs) {
        fetchDocAsynchronously(metadata, row, winningRev$$1);
      }
    }
  }

  function processBatch(batchValues) {
    for (var i = 0, len = batchValues.length; i < len; i++) {
      if (results.length === limit) {
        break;
      }
      var batchValue = batchValues[i];
      if (batchValue.error && keys) {
        // key was not found with "keys" requests
        results.push(batchValue);
        continue;
      }
      var metadata = decodeMetadata(batchValue);
      var winningRev$$1 = metadata.winningRev;
      allDocsInner(winningRev$$1, metadata);
    }
  }

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor) {
      return;
    }
    processBatch(batchValues);
    if (results.length < limit) {
      cursor.continue();
    }
  }

  function onGetAll(e) {
    var values = e.target.result;
    if (opts.descending) {
      values = values.reverse();
    }
    processBatch(values);
  }

  function onResultsReady() {
    var returnVal = {
      total_rows: docCount,
      offset: opts.skip,
      rows: results
    };
    
    /* istanbul ignore if */
    if (opts.update_seq && updateSeq !== undefined) {
      returnVal.update_seq = updateSeq;
    }
    callback(null, returnVal);
  }

  function onTxnComplete() {
    if (opts.attachments) {
      postProcessAttachments(results, opts.binary).then(onResultsReady);
    } else {
      onResultsReady();
    }
  }

  // don't bother doing any requests if start > end or limit === 0
  if (keyRangeError || limit === 0) {
    return;
  }
  if (keys) {
    return allDocsKeys(opts.keys, docStore, onBatch);
  }
  if (limit === -1) { // just fetch everything
    return getAll(docStore, keyRange, onGetAll);
  }
  // else do a cursor
  // choose a batch size based on the skip, since we'll need to skip that many
  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
function checkBlobSupport(txn) {
  return new Promise(function (resolve) {
    var blob$$1 = createBlob(['']);
    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');

    req.onsuccess = function () {
      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);
      var matchedEdge = navigator.userAgent.match(/Edge\\//);
      // MS Edge pretends to be Chrome 42:
      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
      resolve(matchedEdge || !matchedChrome ||
        parseInt(matchedChrome[1], 10) >= 43);
    };

    req.onerror = txn.onabort = function (e) {
      // If the transaction aborts now its due to not being able to
      // write to the database, likely due to the disk being full
      e.preventDefault();
      e.stopPropagation();
      resolve(false);
    };
  }).catch(function () {
    return false; // error, so assume unsupported
  });
}

function countDocs(txn, cb) {
  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
    cb(e.target.result);
  };
}

// This task queue ensures that IDB open calls are done in their own tick

var running = false;
var queue = [];

function tryCode(fun, err, res, PouchDB) {
  try {
    fun(err, res);
  } catch (err) {
    // Shouldn't happen, but in some odd cases
    // IndexedDB implementations might throw a sync
    // error, in which case this will at least log it.
    PouchDB.emit('error', err);
  }
}

function applyNext() {
  if (running || !queue.length) {
    return;
  }
  running = true;
  queue.shift()();
}

function enqueueTask(action, callback, PouchDB) {
  queue.push(function runAction() {
    action(function runCallback(err, res) {
      tryCode(callback, err, res, PouchDB);
      running = false;
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function runNext() {
        applyNext(PouchDB);
      });
    });
  });
  applyNext();
}

function changes(opts, api, dbName, idb) {
  opts = clone(opts);

  if (opts.continuous) {
    var id = dbName + ':' + uuid();
    changesHandler.addListener(dbName, id, api, opts);
    changesHandler.notify(dbName);
    return {
      cancel: function () {
        changesHandler.removeListener(dbName, id);
      }
    };
  }

  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);

  opts.since = opts.since || 0;
  var lastSeq = opts.since;

  var limit = 'limit' in opts ? opts.limit : -1;
  if (limit === 0) {
    limit = 1; // per CouchDB _changes spec
  }

  var results = [];
  var numResults = 0;
  var filter = filterChange(opts);
  var docIdsToMetadata = new ExportedMap();

  var txn;
  var bySeqStore;
  var docStore;
  var docIdRevIndex;

  function onBatch(batchKeys, batchValues, cursor) {
    if (!cursor || !batchKeys.length) { // done
      return;
    }

    var winningDocs = new Array(batchKeys.length);
    var metadatas = new Array(batchKeys.length);

    function processMetadataAndWinningDoc(metadata, winningDoc) {
      var change = opts.processChange(winningDoc, metadata, opts);
      lastSeq = change.seq = metadata.seq;

      var filtered = filter(change);
      if (typeof filtered === 'object') { // anything but true/false indicates error
        return Promise.reject(filtered);
      }

      if (!filtered) {
        return Promise.resolve();
      }
      numResults++;
      if (opts.return_docs) {
        results.push(change);
      }
      // process the attachment immediately
      // for the benefit of live listeners
      if (opts.attachments && opts.include_docs) {
        return new Promise(function (resolve) {
          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
            postProcessAttachments([change], opts.binary).then(function () {
              resolve(change);
            });
          });
        });
      } else {
        return Promise.resolve(change);
      }
    }

    function onBatchDone() {
      var promises = [];
      for (var i = 0, len = winningDocs.length; i < len; i++) {
        if (numResults === limit) {
          break;
        }
        var winningDoc = winningDocs[i];
        if (!winningDoc) {
          continue;
        }
        var metadata = metadatas[i];
        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));
      }

      Promise.all(promises).then(function (changes) {
        for (var i = 0, len = changes.length; i < len; i++) {
          if (changes[i]) {
            opts.onChange(changes[i]);
          }
        }
      }).catch(opts.complete);

      if (numResults !== limit) {
        cursor.continue();
      }
    }

    // Fetch all metadatas/winningdocs from this batch in parallel, then process
    // them all only once all data has been collected. This is done in parallel
    // because it's faster than doing it one-at-a-time.
    var numDone = 0;
    batchValues.forEach(function (value, i) {
      var doc = decodeDoc(value);
      var seq = batchKeys[i];
      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {
        metadatas[i] = metadata;
        winningDocs[i] = winningDoc;
        if (++numDone === batchKeys.length) {
          onBatchDone();
        }
      });
    });
  }

  function onGetMetadata(doc, seq, metadata, cb) {
    if (metadata.seq !== seq) {
      // some other seq is later
      return cb();
    }

    if (metadata.winningRev === doc._rev) {
      // this is the winning doc
      return cb(metadata, doc);
    }

    // fetch winning doc in separate request
    var docIdRev = doc._id + '::' + metadata.winningRev;
    var req = docIdRevIndex.get(docIdRev);
    req.onsuccess = function (e) {
      cb(metadata, decodeDoc(e.target.result));
    };
  }

  function fetchWinningDocAndMetadata(doc, seq, cb) {
    if (docIds && !docIds.has(doc._id)) {
      return cb();
    }

    var metadata = docIdsToMetadata.get(doc._id);
    if (metadata) { // cached
      return onGetMetadata(doc, seq, metadata, cb);
    }
    // metadata not cached, have to go fetch it
    docStore.get(doc._id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      docIdsToMetadata.set(doc._id, metadata);
      onGetMetadata(doc, seq, metadata, cb);
    };
  }

  function finish() {
    opts.complete(null, {
      results: results,
      last_seq: lastSeq
    });
  }

  function onTxnComplete() {
    if (!opts.continuous && opts.attachments) {
      // cannot guarantee that postProcessing was already done,
      // so do it again
      postProcessAttachments(results).then(finish);
    } else {
      finish();
    }
  }

  var objectStores = [DOC_STORE, BY_SEQ_STORE];
  if (opts.attachments) {
    objectStores.push(ATTACH_STORE);
  }
  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');
  if (txnResult.error) {
    return opts.complete(txnResult.error);
  }
  txn = txnResult.txn;
  txn.onabort = idbError(opts.complete);
  txn.oncomplete = onTxnComplete;

  bySeqStore = txn.objectStore(BY_SEQ_STORE);
  docStore = txn.objectStore(DOC_STORE);
  docIdRevIndex = bySeqStore.index('_doc_id_rev');

  var keyRange = (opts.since && !opts.descending) ?
    IDBKeyRange.lowerBound(opts.since, true) : null;

  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);
}

var cachedDBs = new ExportedMap();
var blobSupportPromise;
var openReqList = new ExportedMap();

function IdbPouch(opts, callback) {
  var api = this;

  enqueueTask(function (thisCallback) {
    init(api, opts, thisCallback);
  }, callback, api.constructor);
}

function init(api, opts, callback) {

  var dbName = opts.name;

  var idb = null;
  api._meta = null;

  // called when creating a fresh new database
  function createSchema(db) {
    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});
    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});
    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);

    // added in v2
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    // added in v3
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});

    // added in v4
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 2
  // unfortunately "deletedOrLocal" is a misnomer now that we no longer
  // store local docs in the main doc-store, but whaddyagonnado
  function addDeletedOrLocalIndex(txn, callback) {
    var docStore = txn.objectStore(DOC_STORE);
    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});

    docStore.openCursor().onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var deleted = isDeleted(metadata);
        metadata.deletedOrLocal = deleted ? "1" : "0";
        docStore.put(metadata);
        cursor.continue();
      } else {
        callback();
      }
    };
  }

  // migration to version 3 (part 1)
  function createLocalStoreSchema(db) {
    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})
      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});
  }

  // migration to version 3 (part 2)
  function migrateLocalStore(txn, cb) {
    var localStore = txn.objectStore(LOCAL_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var seqStore = txn.objectStore(BY_SEQ_STORE);

    var cursor = docStore.openCursor();
    cursor.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
        var metadata = cursor.value;
        var docId = metadata.id;
        var local = isLocalId(docId);
        var rev$$1 = winningRev(metadata);
        if (local) {
          var docIdRev = docId + "::" + rev$$1;
          // remove all seq entries
          // associated with this docId
          var start = docId + "::";
          var end = docId + "::~";
          var index = seqStore.index('_doc_id_rev');
          var range = IDBKeyRange.bound(start, end, false, false);
          var seqCursor = index.openCursor(range);
          seqCursor.onsuccess = function (e) {
            seqCursor = e.target.result;
            if (!seqCursor) {
              // done
              docStore.delete(cursor.primaryKey);
              cursor.continue();
            } else {
              var data = seqCursor.value;
              if (data._doc_id_rev === docIdRev) {
                localStore.put(data);
              }
              seqStore.delete(seqCursor.primaryKey);
              seqCursor.continue();
            }
          };
        } else {
          cursor.continue();
        }
      } else if (cb) {
        cb();
      }
    };
  }

  // migration to version 4 (part 1)
  function addAttachAndSeqStore(db) {
    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
      {autoIncrement: true});
    attAndSeqStore.createIndex('seq', 'seq');
    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});
  }

  // migration to version 4 (part 2)
  function migrateAttsAndSeqs(txn, callback) {
    var seqStore = txn.objectStore(BY_SEQ_STORE);
    var attStore = txn.objectStore(ATTACH_STORE);
    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

    // need to actually populate the table. this is the expensive part,
    // so as an optimization, check first that this database even
    // contains attachments
    var req = attStore.count();
    req.onsuccess = function (e) {
      var count = e.target.result;
      if (!count) {
        return callback(); // done
      }

      seqStore.openCursor().onsuccess = function (e) {
        var cursor = e.target.result;
        if (!cursor) {
          return callback(); // done
        }
        var doc = cursor.value;
        var seq = cursor.primaryKey;
        var atts = Object.keys(doc._attachments || {});
        var digestMap = {};
        for (var j = 0; j < atts.length; j++) {
          var att = doc._attachments[atts[j]];
          digestMap[att.digest] = true; // uniq digests, just in case
        }
        var digests = Object.keys(digestMap);
        for (j = 0; j < digests.length; j++) {
          var digest = digests[j];
          attAndSeqStore.put({
            seq: seq,
            digestSeq: digest + '::' + seq
          });
        }
        cursor.continue();
      };
    };
  }

  // migration to version 5
  // Instead of relying on on-the-fly migration of metadata,
  // this brings the doc-store to its modern form:
  // - metadata.winningrev
  // - metadata.seq
  // - stringify the metadata when storing it
  function migrateMetadata(txn) {

    function decodeMetadataCompat(storedObject) {
      if (!storedObject.data) {
        // old format, when we didn't store it stringified
        storedObject.deleted = storedObject.deletedOrLocal === '1';
        return storedObject;
      }
      return decodeMetadata(storedObject);
    }

    // ensure that every metadata has a winningRev and seq,
    // which was previously created on-the-fly but better to migrate
    var bySeqStore = txn.objectStore(BY_SEQ_STORE);
    var docStore = txn.objectStore(DOC_STORE);
    var cursor = docStore.openCursor();
    cursor.onsuccess = function (e) {
      var cursor = e.target.result;
      if (!cursor) {
        return; // done
      }
      var metadata = decodeMetadataCompat(cursor.value);

      metadata.winningRev = metadata.winningRev ||
        winningRev(metadata);

      function fetchMetadataSeq() {
        // metadata.seq was added post-3.2.0, so if it's missing,
        // we need to fetch it manually
        var start = metadata.id + '::';
        var end = metadata.id + '::\\uffff';
        var req = bySeqStore.index('_doc_id_rev').openCursor(
          IDBKeyRange.bound(start, end));

        var metadataSeq = 0;
        req.onsuccess = function (e) {
          var cursor = e.target.result;
          if (!cursor) {
            metadata.seq = metadataSeq;
            return onGetMetadataSeq();
          }
          var seq = cursor.primaryKey;
          if (seq > metadataSeq) {
            metadataSeq = seq;
          }
          cursor.continue();
        };
      }

      function onGetMetadataSeq() {
        var metadataToStore = encodeMetadata(metadata,
          metadata.winningRev, metadata.deleted);

        var req = docStore.put(metadataToStore);
        req.onsuccess = function () {
          cursor.continue();
        };
      }

      if (metadata.seq) {
        return onGetMetadataSeq();
      }

      fetchMetadataSeq();
    };

  }

  api._remote = false;
  api.type = function () {
    return 'idb';
  };

  api._id = toPromise(function (callback) {
    callback(null, api._meta.instanceId);
  });

  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
    idbBulkDocs(opts, req, reqOpts, api, idb, callback);
  };

  // First we look up the metadata in the ids database, then we fetch the
  // current revision(s) from the by sequence store
  api._get = function idb_get(id, opts, callback) {
    var doc;
    var metadata;
    var err;
    var txn = opts.ctx;
    if (!txn) {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }

    function finish() {
      callback(err, {doc: doc, metadata: metadata, ctx: txn});
    }

    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
      metadata = decodeMetadata(e.target.result);
      // we can determine the result here if:
      // 1. there is no such document
      // 2. the document is deleted and we don't ask about specific rev
      // When we ask with opts.rev we expect the answer to be either
      // doc (possibly with _deleted=true) or missing error
      if (!metadata) {
        err = createError(MISSING_DOC, 'missing');
        return finish();
      }

      var rev$$1;
      if (!opts.rev) {
        rev$$1 = metadata.winningRev;
        var deleted = isDeleted(metadata);
        if (deleted) {
          err = createError(MISSING_DOC, "deleted");
          return finish();
        }
      } else {
        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;
      }

      var objectStore = txn.objectStore(BY_SEQ_STORE);
      var key = metadata.id + '::' + rev$$1;

      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
        doc = e.target.result;
        if (doc) {
          doc = decodeDoc(doc);
        }
        if (!doc) {
          err = createError(MISSING_DOC, 'missing');
          return finish();
        }
        finish();
      };
    };
  };

  api._getAttachment = function (docId, attachId, attachment, opts, callback) {
    var txn;
    if (opts.ctx) {
      txn = opts.ctx;
    } else {
      var txnResult = openTransactionSafely(idb,
        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      txn = txnResult.txn;
    }
    var digest = attachment.digest;
    var type = attachment.content_type;

    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
      var body = e.target.result.body;
      readBlobData(body, type, opts.binary, function (blobData) {
        callback(null, blobData);
      });
    };
  };

  api._info = function idb_info(callback) {
    var updateSeq;
    var docCount;

    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      docCount = e.target.result.docCount;
    };
    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {
      var cursor = e.target.result;
      updateSeq = cursor ? cursor.key : 0;
    };

    txn.oncomplete = function () {
      callback(null, {
        doc_count: docCount,
        update_seq: updateSeq,
        // for debugging
        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')
      });
    };
  };

  api._allDocs = function idb_allDocs(opts, callback) {
    idbAllDocs(opts, idb, callback);
  };

  api._changes = function idbChanges(opts) {
    return changes(opts, api, dbName, idb);
  };

  api._close = function (callback) {
    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
    // "Returns immediately and closes the connection in a separate thread..."
    idb.close();
    cachedDBs.delete(dbName);
    callback();
  };

  api._getRevisionTree = function (docId, callback) {
    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;
    var req = txn.objectStore(DOC_STORE).get(docId);
    req.onsuccess = function (event) {
      var doc = decodeMetadata(event.target.result);
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        callback(null, doc.rev_tree);
      }
    };
  };

  // This function removes revisions of document docId
  // which are listed in revs and sets this document
  // revision to to rev_tree
  api._doCompaction = function (docId, revs, callback) {
    var stores = [
      DOC_STORE,
      BY_SEQ_STORE,
      ATTACH_STORE,
      ATTACH_AND_SEQ_STORE
    ];
    var txnResult = openTransactionSafely(idb, stores, 'readwrite');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var txn = txnResult.txn;

    var docStore = txn.objectStore(DOC_STORE);

    docStore.get(docId).onsuccess = function (event) {
      var metadata = decodeMetadata(event.target.result);
      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                         revHash, ctx, opts) {
        var rev$$1 = pos + '-' + revHash;
        if (revs.indexOf(rev$$1) !== -1) {
          opts.status = 'missing';
        }
      });
      compactRevs(revs, docId, txn);
      var winningRev$$1 = metadata.winningRev;
      var deleted = metadata.deleted;
      txn.objectStore(DOC_STORE).put(
        encodeMetadata(metadata, winningRev$$1, deleted));
    };
    txn.onabort = idbError(callback);
    txn.oncomplete = function () {
      callback();
    };
  };


  api._getLocal = function (id, callback) {
    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');
    if (txnResult.error) {
      return callback(txnResult.error);
    }
    var tx = txnResult.txn;
    var req = tx.objectStore(LOCAL_STORE).get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var doc = e.target.result;
      if (!doc) {
        callback(createError(MISSING_DOC));
      } else {
        delete doc['_doc_id_rev']; // for backwards compat
        callback(null, doc);
      }
    };
  };

  api._putLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    delete doc._revisions; // ignore this, trust the rev
    var oldRev = doc._rev;
    var id = doc._id;
    if (!oldRev) {
      doc._rev = '0-1';
    } else {
      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
    }

    var tx = opts.ctx;
    var ret;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.onerror = idbError(callback);
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }

    var oStore = tx.objectStore(LOCAL_STORE);
    var req;
    if (oldRev) {
      req = oStore.get(id);
      req.onsuccess = function (e) {
        var oldDoc = e.target.result;
        if (!oldDoc || oldDoc._rev !== oldRev) {
          callback(createError(REV_CONFLICT));
        } else { // update
          var req = oStore.put(doc);
          req.onsuccess = function () {
            ret = {ok: true, id: doc._id, rev: doc._rev};
            if (opts.ctx) { // return immediately
              callback(null, ret);
            }
          };
        }
      };
    } else { // new doc
      req = oStore.add(doc);
      req.onerror = function (e) {
        // constraint error, already exists
        callback(createError(REV_CONFLICT));
        e.preventDefault(); // avoid transaction abort
        e.stopPropagation(); // avoid transaction onerror
      };
      req.onsuccess = function () {
        ret = {ok: true, id: doc._id, rev: doc._rev};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      };
    }
  };

  api._removeLocal = function (doc, opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var tx = opts.ctx;
    if (!tx) {
      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
      if (txnResult.error) {
        return callback(txnResult.error);
      }
      tx = txnResult.txn;
      tx.oncomplete = function () {
        if (ret) {
          callback(null, ret);
        }
      };
    }
    var ret;
    var id = doc._id;
    var oStore = tx.objectStore(LOCAL_STORE);
    var req = oStore.get(id);

    req.onerror = idbError(callback);
    req.onsuccess = function (e) {
      var oldDoc = e.target.result;
      if (!oldDoc || oldDoc._rev !== doc._rev) {
        callback(createError(MISSING_DOC));
      } else {
        oStore.delete(id);
        ret = {ok: true, id: id, rev: '0-0'};
        if (opts.ctx) { // return immediately
          callback(null, ret);
        }
      }
    };
  };

  api._destroy = function (opts, callback) {
    changesHandler.removeAllListeners(dbName);

    //Close open request for "dbName" database to fix ie delay.
    var openReq = openReqList.get(dbName);
    if (openReq && openReq.result) {
      openReq.result.close();
      cachedDBs.delete(dbName);
    }
    var req = indexedDB.deleteDatabase(dbName);

    req.onsuccess = function () {
      //Remove open request from the list.
      openReqList.delete(dbName);
      if (hasLocalStorage() && (dbName in localStorage)) {
        delete localStorage[dbName];
      }
      callback(null, { 'ok': true });
    };

    req.onerror = idbError(callback);
  };

  var cached = cachedDBs.get(dbName);

  if (cached) {
    idb = cached.idb;
    api._meta = cached.global;
    return immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
      callback(null, api);
    });
  }

  var req = indexedDB.open(dbName, ADAPTER_VERSION);
  openReqList.set(dbName, req);

  req.onupgradeneeded = function (e) {
    var db = e.target.result;
    if (e.oldVersion < 1) {
      return createSchema(db); // new db, initial schema
    }
    // do migrations

    var txn = e.currentTarget.transaction;
    // these migrations have to be done in this function, before
    // control is returned to the event loop, because IndexedDB

    if (e.oldVersion < 3) {
      createLocalStoreSchema(db); // v2 -> v3
    }
    if (e.oldVersion < 4) {
      addAttachAndSeqStore(db); // v3 -> v4
    }

    var migrations = [
      addDeletedOrLocalIndex, // v1 -> v2
      migrateLocalStore,      // v2 -> v3
      migrateAttsAndSeqs,     // v3 -> v4
      migrateMetadata         // v4 -> v5
    ];

    var i = e.oldVersion;

    function next() {
      var migration = migrations[i - 1];
      i++;
      if (migration) {
        migration(txn, next);
      }
    }

    next();
  };

  req.onsuccess = function (e) {

    idb = e.target.result;

    idb.onversionchange = function () {
      idb.close();
      cachedDBs.delete(dbName);
    };

    idb.onabort = function (e) {
      guardedConsole('error', 'Database has a global failure', e.target.error);
      idb.close();
      cachedDBs.delete(dbName);
    };

    // Do a few setup operations (in parallel as much as possible):
    // 1. Fetch meta doc
    // 2. Check blob support
    // 3. Calculate docCount
    // 4. Generate an instanceId if necessary
    // 5. Store docCount and instanceId on meta doc

    var txn = idb.transaction([
      META_STORE,
      DETECT_BLOB_SUPPORT_STORE,
      DOC_STORE
    ], 'readwrite');

    var storedMetaDoc = false;
    var metaDoc;
    var docCount;
    var blobSupport;
    var instanceId;

    function completeSetup() {
      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {
        return;
      }
      api._meta = {
        name: dbName,
        instanceId: instanceId,
        blobSupport: blobSupport
      };

      cachedDBs.set(dbName, {
        idb: idb,
        global: api._meta
      });
      callback(null, api);
    }

    function storeMetaDocIfReady() {
      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {
        return;
      }
      var instanceKey = dbName + '_id';
      if (instanceKey in metaDoc) {
        instanceId = metaDoc[instanceKey];
      } else {
        metaDoc[instanceKey] = instanceId = uuid();
      }
      metaDoc.docCount = docCount;
      txn.objectStore(META_STORE).put(metaDoc);
    }

    //
    // fetch or generate the instanceId
    //
    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
      metaDoc = e.target.result || { id: META_STORE };
      storeMetaDocIfReady();
    };

    //
    // countDocs
    //
    countDocs(txn, function (count) {
      docCount = count;
      storeMetaDocIfReady();
    });

    //
    // check blob support
    //
    if (!blobSupportPromise) {
      // make sure blob support is only checked once
      blobSupportPromise = checkBlobSupport(txn);
    }

    blobSupportPromise.then(function (val) {
      blobSupport = val;
      completeSetup();
    });

    // only when the metadata put transaction has completed,
    // consider the setup done
    txn.oncomplete = function () {
      storedMetaDoc = true;
      completeSetup();
    };
    txn.onabort = idbError(callback);
  };

  req.onerror = function (e) {
    var msg = e.target.error && e.target.error.message;

    if (!msg) {
      msg = 'Failed to open indexedDB, are you in private browsing mode?';
    } else if (msg.indexOf("stored database is a higher version") !== -1) {
      msg = new Error('This DB was created with the newer "indexeddb" adapter, but you are trying to open it with the older "idb" adapter');
    }

    guardedConsole('error', msg);
    callback(createError(IDB_ERROR, msg));
  };
}

IdbPouch.valid = function () {
  // Following #7085 buggy idb versions (typically Safari < 10.1) are
  // considered valid.

  // On Firefox SecurityError is thrown while referencing indexedDB if cookies
  // are not allowed. \`typeof indexedDB\` also triggers the error.
  try {
    // some outdated implementations of IDB that appear on Samsung
    // and HTC Android devices <4.4 are missing IDBKeyRange
    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
  } catch (e) {
    return false;
  }
};

function IDBPouch (PouchDB) {
  PouchDB.adapter('idb', IdbPouch, true);
}

// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool
// but much smaller in code size. limits the number of concurrent promises that are executed


function pool(promiseFactories, limit) {
  return new Promise(function (resolve, reject) {
    var running = 0;
    var current = 0;
    var done = 0;
    var len = promiseFactories.length;
    var err;

    function runNext() {
      running++;
      promiseFactories[current++]().then(onSuccess, onError);
    }

    function doNext() {
      if (++done === len) {
        /* istanbul ignore if */
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      } else {
        runNextBatch();
      }
    }

    function onSuccess() {
      running--;
      doNext();
    }

    /* istanbul ignore next */
    function onError(thisErr) {
      running--;
      err = err || thisErr;
      doNext();
    }

    function runNextBatch() {
      while (running < limit && current < len) {
        runNext();
      }
    }

    runNextBatch();
  });
}

var CHANGES_BATCH_SIZE = 25;
var MAX_SIMULTANEOUS_REVS = 50;
var CHANGES_TIMEOUT_BUFFER = 5000;
var DEFAULT_HEARTBEAT = 10000;

var supportsBulkGetMap = {};

function readAttachmentsAsBlobOrBuffer(row) {
  var doc = row.doc || row.ok;
  var atts = doc && doc._attachments;
  if (!atts) {
    return;
  }
  Object.keys(atts).forEach(function (filename) {
    var att = atts[filename];
    att.data = b64ToBluffer(att.data, att.content_type);
  });
}

function encodeDocId(id) {
  if (/^_design/.test(id)) {
    return '_design/' + encodeURIComponent(id.slice(8));
  }
  if (/^_local/.test(id)) {
    return '_local/' + encodeURIComponent(id.slice(7));
  }
  return encodeURIComponent(id);
}

function preprocessAttachments$1(doc) {
  if (!doc._attachments || !Object.keys(doc._attachments)) {
    return Promise.resolve();
  }

  return Promise.all(Object.keys(doc._attachments).map(function (key) {
    var attachment = doc._attachments[key];
    if (attachment.data && typeof attachment.data !== 'string') {
      return new Promise(function (resolve) {
        blobToBase64(attachment.data, resolve);
      }).then(function (b64) {
        attachment.data = b64;
      });
    }
  }));
}

function hasUrlPrefix(opts) {
  if (!opts.prefix) {
    return false;
  }
  var protocol = parseUri(opts.prefix).protocol;
  return protocol === 'http' || protocol === 'https';
}

// Get all the information you possibly can about the URI given by name and
// return it as a suitable object.
function getHost(name, opts) {
  // encode db name if opts.prefix is a url (#5574)
  if (hasUrlPrefix(opts)) {
    var dbName = opts.name.substr(opts.prefix.length);
    // Ensure prefix has a trailing slash
    var prefix = opts.prefix.replace(/\\/?$/, '/');
    name = prefix + encodeURIComponent(dbName);
  }

  var uri = parseUri(name);
  if (uri.user || uri.password) {
    uri.auth = {username: uri.user, password: uri.password};
  }

  // Split the path part of the URI into parts using '/' as the delimiter
  // after removing any leading '/' and any trailing '/'
  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');

  uri.db = parts.pop();
  // Prevent double encoding of URI component
  if (uri.db.indexOf('%') === -1) {
    uri.db = encodeURIComponent(uri.db);
  }

  uri.path = parts.join('/');

  return uri;
}

// Generate a URL with the host data given by opts and the given path
function genDBUrl(opts, path) {
  return genUrl(opts, opts.db + '/' + path);
}

// Generate a URL with the host data given by opts and the given path
function genUrl(opts, path) {
  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  var pathDel = !opts.path ? '' : '/';

  // If the host already has a path, then we need to have a path delimiter
  // Otherwise, the path delimiter is the empty string
  return opts.protocol + '://' + opts.host +
         (opts.port ? (':' + opts.port) : '') +
         '/' + opts.path + pathDel + path;
}

function paramsToStr(params) {
  return '?' + Object.keys(params).map(function (k) {
    return k + '=' + encodeURIComponent(params[k]);
  }).join('&');
}

function shouldCacheBust(opts) {
  var ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?
      navigator.userAgent.toLowerCase() : '';
  var isIE = ua.indexOf('msie') !== -1;
  var isTrident = ua.indexOf('trident') !== -1;
  var isEdge = ua.indexOf('edge') !== -1;
  var isGET = !('method' in opts) || opts.method === 'GET';
  return (isIE || isTrident || isEdge) && isGET;
}

// Implements the PouchDB API for dealing with CouchDB instances over HTTP
function HttpPouch(opts, callback) {

  // The functions that will be publicly available for HttpPouch
  var api = this;

  var host = getHost(opts.name, opts);
  var dbUrl = genDBUrl(host, '');

  opts = clone(opts);

  var ourFetch = function (url, options) {

    options = options || {};
    options.headers = options.headers || new h();

    options.credentials = 'include';

    if (opts.auth || host.auth) {
      var nAuth = opts.auth || host.auth;
      var str = nAuth.username + ':' + nAuth.password;
      var token = thisBtoa(unescape(encodeURIComponent(str)));
      options.headers.set('Authorization', 'Basic ' + token);
    }

    var headers = opts.headers || {};
    Object.keys(headers).forEach(function (key) {
      options.headers.append(key, headers[key]);
    });

    /* istanbul ignore if */
    if (shouldCacheBust(options)) {
      url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();
    }

    var fetchFun = opts.fetch || f$1;
    return fetchFun(url, options);
  };

  function adapterFun$$1(name, fun) {
    return adapterFun(name, argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
      setup().then(function () {
        return fun.apply(this, args);
      }).catch(function (e) {
        var callback = args.pop();
        callback(e);
      });
    })).bind(api);
  }

  function fetchJSON(url, options, callback) {

    var result = {};

    options = options || {};
    options.headers = options.headers || new h();

    if (!options.headers.get('Content-Type')) {
      options.headers.set('Content-Type', 'application/json');
    }
    if (!options.headers.get('Accept')) {
      options.headers.set('Accept', 'application/json');
    }

    return ourFetch(url, options).then(function (response) {
      result.ok = response.ok;
      result.status = response.status;
      return response.json();
    }).then(function (json) {
      result.data = json;
      if (!result.ok) {
        result.data.status = result.status;
        var err = generateErrorFromResponse(result.data);
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }

      if (Array.isArray(result.data)) {
        result.data = result.data.map(function (v) {
          if (v.error || v.missing) {
            return generateErrorFromResponse(v);
          } else {
            return v;
          }
        });
      }

      if (callback) {
        callback(null, result.data);
      } else {
        return result;
      }
    });
  }

  var setupPromise;

  function setup() {
    if (opts.skip_setup) {
      return Promise.resolve();
    }

    // If there is a setup in process or previous successful setup
    // done then we will use that
    // If previous setups have been rejected we will try again
    if (setupPromise) {
      return setupPromise;
    }

    setupPromise = fetchJSON(dbUrl).catch(function (err) {
      if (err && err.status && err.status === 404) {
        // Doesnt exist, create it
        explainError(404, 'PouchDB is just detecting if the remote exists.');
        return fetchJSON(dbUrl, {method: 'PUT'});
      } else {
        return Promise.reject(err);
      }
    }).catch(function (err) {
      // If we try to create a database that already exists, skipped in
      // istanbul since its catching a race condition.
      /* istanbul ignore if */
      if (err && err.status && err.status === 412) {
        return true;
      }
      return Promise.reject(err);
    });

    setupPromise.catch(function () {
      setupPromise = null;
    });

    return setupPromise;
  }

  immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
    callback(null, api);
  });

  api._remote = true;

  /* istanbul ignore next */
  api.type = function () {
    return 'http';
  };

  api.id = adapterFun$$1('id', function (callback) {
    ourFetch(genUrl(host, '')).then(function (response) {
      return response.json();
    }).catch(function () {
      return {};
    }).then(function (result) {
      // Bad response or missing \`uuid\` should not prevent ID generation.
      var uuid$$1 = (result && result.uuid) ?
          (result.uuid + host.db) : genDBUrl(host, '');
      callback(null, uuid$$1);
    });
  });

  // Sends a POST request to the host calling the couchdb _compact function
  //    version: The version of CouchDB it is running
  api.compact = adapterFun$$1('compact', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'}).then(function () {
      function ping() {
        api.info(function (err, res) {
          // CouchDB may send a "compact_running:true" if it's
          // already compacting. PouchDB Server doesn't.
          /* istanbul ignore else */
          if (res && !res.compact_running) {
            callback(null, {ok: true});
          } else {
            setTimeout(ping, opts.interval || 200);
          }
        });
      }
      // Ping the http if it's finished compaction
      ping();
    });
  });

  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {
    var self = this;

    function doBulkGet(cb) {
      var params = {};
      if (opts.revs) {
        params.revs = true;
      }
      if (opts.attachments) {
        /* istanbul ignore next */
        params.attachments = true;
      }
      if (opts.latest) {
        params.latest = true;
      }
      fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {
        method: 'POST',
        body: JSON.stringify({ docs: opts.docs})
      }).then(function (result) {
        if (opts.attachments && opts.binary) {
          result.data.results.forEach(function (res) {
            res.docs.forEach(readAttachmentsAsBlobOrBuffer);
          });
        }
        cb(null, result.data);
      }).catch(cb);
    }

    /* istanbul ignore next */
    function doBulkGetShim() {
      // avoid "url too long error" by splitting up into multiple requests
      var batchSize = MAX_SIMULTANEOUS_REVS;
      var numBatches = Math.ceil(opts.docs.length / batchSize);
      var numDone = 0;
      var results = new Array(numBatches);

      function onResult(batchNum) {
        return function (err, res) {
          // err is impossible because shim returns a list of errs in that case
          results[batchNum] = res.results;
          if (++numDone === numBatches) {
            callback(null, {results: flatten(results)});
          }
        };
      }

      for (var i = 0; i < numBatches; i++) {
        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);
        subOpts.docs = opts.docs.slice(i * batchSize,
          Math.min(opts.docs.length, (i + 1) * batchSize));
        bulkGet(self, subOpts, onResult(i));
      }
    }

    // mark the whole database as either supporting or not supporting _bulk_get
    var dbUrl = genUrl(host, '');
    var supportsBulkGet = supportsBulkGetMap[dbUrl];

    /* istanbul ignore next */
    if (typeof supportsBulkGet !== 'boolean') {
      // check if this database supports _bulk_get
      doBulkGet(function (err, res) {
        if (err) {
          supportsBulkGetMap[dbUrl] = false;
          explainError(
            err.status,
            'PouchDB is just detecting if the remote ' +
            'supports the _bulk_get API.'
          );
          doBulkGetShim();
        } else {
          supportsBulkGetMap[dbUrl] = true;
          callback(null, res);
        }
      });
    } else if (supportsBulkGet) {
      doBulkGet(callback);
    } else {
      doBulkGetShim();
    }
  });

  // Calls GET on the host, which gets back a JSON string containing
  //    couchdb: A welcome string
  //    version: The version of CouchDB it is running
  api._info = function (callback) {
    setup().then(function () {
      return ourFetch(genDBUrl(host, ''));
    }).then(function (response) {
      return response.json();
    }).then(function (info) {
      info.host = genDBUrl(host, '');
      callback(null, info);
    }).catch(callback);
  };

  api.fetch = function (path, options) {
    return setup().then(function () {
      var url = path.substring(0, 1) === '/' ?
        genUrl(host, path.substring(1)) :
        genDBUrl(host, path);
      return ourFetch(url, options);
    });
  };

  // Get the document with the given id from the database given by host.
  // The id could be solely the _id in the database, or it may be a
  // _design/ID or _local/ID path
  api.get = adapterFun$$1('get', function (id, opts, callback) {
    // If no options were given, set the callback to the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};

    if (opts.revs) {
      params.revs = true;
    }

    if (opts.revs_info) {
      params.revs_info = true;
    }

    if (opts.latest) {
      params.latest = true;
    }

    if (opts.open_revs) {
      if (opts.open_revs !== "all") {
        opts.open_revs = JSON.stringify(opts.open_revs);
      }
      params.open_revs = opts.open_revs;
    }

    if (opts.rev) {
      params.rev = opts.rev;
    }

    if (opts.conflicts) {
      params.conflicts = opts.conflicts;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = opts.update_seq;
    }

    id = encodeDocId(id);

    function fetchAttachments(doc) {
      var atts = doc._attachments;
      var filenames = atts && Object.keys(atts);
      if (!atts || !filenames.length) {
        return;
      }
      // we fetch these manually in separate XHRs, because
      // Sync Gateway would normally send it back as multipart/mixed,
      // which we cannot parse. Also, this is more efficient than
      // receiving attachments as base64-encoded strings.
      function fetchData(filename) {
        var att = atts[filename];
        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +
            '?rev=' + doc._rev;
        return ourFetch(genDBUrl(host, path)).then(function (response) {
          if ('buffer' in response) {
            return response.buffer();
          } else {
            /* istanbul ignore next */
            return response.blob();
          }
        }).then(function (blob) {
          if (opts.binary) {
            var typeFieldDescriptor = Object.getOwnPropertyDescriptor(blob.__proto__, 'type');
            if (!typeFieldDescriptor || typeFieldDescriptor.set) {
              blob.type = att.content_type;
            }
            return blob;
          }
          return new Promise(function (resolve) {
            blobToBase64(blob, resolve);
          });
        }).then(function (data) {
          delete att.stub;
          delete att.length;
          att.data = data;
        });
      }

      var promiseFactories = filenames.map(function (filename) {
        return function () {
          return fetchData(filename);
        };
      });

      // This limits the number of parallel xhr requests to 5 any time
      // to avoid issues with maximum browser request limits
      return pool(promiseFactories, 5);
    }

    function fetchAllAttachments(docOrDocs) {
      if (Array.isArray(docOrDocs)) {
        return Promise.all(docOrDocs.map(function (doc) {
          if (doc.ok) {
            return fetchAttachments(doc.ok);
          }
        }));
      }
      return fetchAttachments(docOrDocs);
    }

    var url = genDBUrl(host, id + paramsToStr(params));
    fetchJSON(url).then(function (res) {
      return Promise.resolve().then(function () {
        if (opts.attachments) {
          return fetchAllAttachments(res.data);
        }
      }).then(function () {
        callback(null, res.data);
      });
    }).catch(function (e) {
      e.docId = id;
      callback(e);
    });
  });


  // Delete the document given by doc from the database given by host.
  api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, cb) {
    var doc;
    if (typeof optsOrRev === 'string') {
      // id, rev, opts, callback style
      doc = {
        _id: docOrId,
        _rev: optsOrRev
      };
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
    } else {
      // doc, opts, callback style
      doc = docOrId;
      if (typeof optsOrRev === 'function') {
        cb = optsOrRev;
        opts = {};
      } else {
        cb = opts;
        opts = optsOrRev;
      }
    }

    var rev$$1 = (doc._rev || opts.rev);
    var url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1;

    fetchJSON(url, {method: 'DELETE'}, cb).catch(cb);
  });

  function encodeAttachmentId(attachmentId) {
    return attachmentId.split("/").map(encodeURIComponent).join("/");
  }

  // Get the attachment
  api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId,
                                                            opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    var params = opts.rev ? ('?rev=' + opts.rev) : '';
    var url = genDBUrl(host, encodeDocId(docId)) + '/' +
        encodeAttachmentId(attachmentId) + params;
    var contentType;
    ourFetch(url, {method: 'GET'}).then(function (response) {
      contentType = response.headers.get('content-type');
      if (!response.ok) {
        throw response;
      } else {
        if (typeof process !== 'undefined' && !process.browser && typeof response.buffer === 'function') {
          return response.buffer();
        } else {
          /* istanbul ignore next */
          return response.blob();
        }
      }
    }).then(function (blob) {
      // TODO: also remove
      if (typeof process !== 'undefined' && !process.browser) {
        blob.type = contentType;
      }
      callback(null, blob);
    }).catch(function (err) {
      callback(err);
    });
  });

  // Remove the attachment given by the id and rev
  api.removeAttachment =  adapterFun$$1('removeAttachment', function (docId,
                                                                   attachmentId,
                                                                   rev$$1,
                                                                   callback) {
    var url = genDBUrl(host, encodeDocId(docId) + '/' +
                       encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;
    fetchJSON(url, {method: 'DELETE'}, callback).catch(callback);
  });

  // Add the attachment given by blob and its contentType property
  // to the document with the given id, the revision given by rev, and
  // add it to the database given by host.
  api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId,
                                                            rev$$1, blob,
                                                            type, callback) {
    if (typeof type === 'function') {
      callback = type;
      type = blob;
      blob = rev$$1;
      rev$$1 = null;
    }
    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
    var url = genDBUrl(host, id);
    if (rev$$1) {
      url += '?rev=' + rev$$1;
    }

    if (typeof blob === 'string') {
      // input is assumed to be a base64 string
      var binary;
      try {
        binary = thisAtob(blob);
      } catch (err) {
        return callback(createError(BAD_ARG,
                        'Attachment is not a valid base64 string'));
      }
      blob = binary ? binStringToBluffer(binary, type) : '';
    }

    // Add the attachment
    fetchJSON(url, {
      headers: new h({'Content-Type': type}),
      method: 'PUT',
      body: blob
    }, callback).catch(callback);
  });

  // Update/create multiple documents given by req in the database
  // given by host.
  api._bulkDocs = function (req, opts, callback) {
    // If new_edits=false then it prevents the database from creating
    // new revision numbers for the documents. Instead it just uses
    // the old ones. This is used in database replication.
    req.new_edits = opts.new_edits;

    setup().then(function () {
      return Promise.all(req.docs.map(preprocessAttachments$1));
    }).then(function () {
      // Update/create the documents
      return fetchJSON(genDBUrl(host, '_bulk_docs'), {
        method: 'POST',
        body: JSON.stringify(req)
      }, callback);
    }).catch(callback);
  };


  // Update/create document
  api._put = function (doc, opts, callback) {
    setup().then(function () {
      return preprocessAttachments$1(doc);
    }).then(function () {
      return fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {
        method: 'PUT',
        body: JSON.stringify(doc)
      });
    }).then(function (result) {
      callback(null, result.data);
    }).catch(function (err) {
      err.docId = doc && doc._id;
      callback(err);
    });
  };


  // Get a listing of the documents in the database given
  // by host and ordered by increasing id.
  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = clone(opts);

    // List of parameters to add to the GET request
    var params = {};
    var body;
    var method = 'GET';

    if (opts.conflicts) {
      params.conflicts = true;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    if (opts.include_docs) {
      params.include_docs = true;
    }

    // added in CouchDB 1.6.0
    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.key) {
      params.key = JSON.stringify(opts.key);
    }

    if (opts.start_key) {
      opts.startkey = opts.start_key;
    }

    if (opts.startkey) {
      params.startkey = JSON.stringify(opts.startkey);
    }

    if (opts.end_key) {
      opts.endkey = opts.end_key;
    }

    if (opts.endkey) {
      params.endkey = JSON.stringify(opts.endkey);
    }

    if (typeof opts.inclusive_end !== 'undefined') {
      params.inclusive_end = !!opts.inclusive_end;
    }

    if (typeof opts.limit !== 'undefined') {
      params.limit = opts.limit;
    }

    if (typeof opts.skip !== 'undefined') {
      params.skip = opts.skip;
    }

    var paramStr = paramsToStr(params);

    if (typeof opts.keys !== 'undefined') {
      method = 'POST';
      body = {keys: opts.keys};
    }

    fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {
       method: method,
      body: JSON.stringify(body)
    }).then(function (result) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);
      }
      callback(null, result.data);
    }).catch(callback);
  });

  // Get a list of changes made to documents in the database given by host.
  // TODO According to the README, there should be two other methods here,
  // api.changes.addListener and api.changes.removeListener.
  api._changes = function (opts) {

    // We internally page the results of a changes request, this means
    // if there is a large set of changes to be returned we can start
    // processing them quicker instead of waiting on the entire
    // set of changes to return and attempting to process them at once
    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;

    opts = clone(opts);

    if (opts.continuous && !('heartbeat' in opts)) {
      opts.heartbeat = DEFAULT_HEARTBEAT;
    }

    var requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;

    // ensure CHANGES_TIMEOUT_BUFFER applies
    if ('timeout' in opts && opts.timeout &&
      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;
    }

    /* istanbul ignore if */
    if ('heartbeat' in opts && opts.heartbeat &&
       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {
        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;
    }

    var params = {};
    if ('timeout' in opts && opts.timeout) {
      params.timeout = opts.timeout;
    }

    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
    var leftToFetch = limit;

    if (opts.style) {
      params.style = opts.style;
    }

    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
      params.include_docs = true;
    }

    if (opts.attachments) {
      params.attachments = true;
    }

    if (opts.continuous) {
      params.feed = 'longpoll';
    }

    if (opts.seq_interval) {
      params.seq_interval = opts.seq_interval;
    }

    if (opts.conflicts) {
      params.conflicts = true;
    }

    if (opts.descending) {
      params.descending = true;
    }

    /* istanbul ignore if */
    if (opts.update_seq) {
      params.update_seq = true;
    }

    if ('heartbeat' in opts) {
      // If the heartbeat value is false, it disables the default heartbeat
      if (opts.heartbeat) {
        params.heartbeat = opts.heartbeat;
      }
    }

    if (opts.filter && typeof opts.filter === 'string') {
      params.filter = opts.filter;
    }

    if (opts.view && typeof opts.view === 'string') {
      params.filter = '_view';
      params.view = opts.view;
    }

    // If opts.query_params exists, pass it through to the changes request.
    // These parameters may be used by the filter on the source database.
    if (opts.query_params && typeof opts.query_params === 'object') {
      for (var param_name in opts.query_params) {
        /* istanbul ignore else */
        if (opts.query_params.hasOwnProperty(param_name)) {
          params[param_name] = opts.query_params[param_name];
        }
      }
    }

    var method = 'GET';
    var body;

    if (opts.doc_ids) {
      // set this automagically for the user; it's annoying that couchdb
      // requires both a "filter" and a "doc_ids" param.
      params.filter = '_doc_ids';
      method = 'POST';
      body = {doc_ids: opts.doc_ids };
    }
    /* istanbul ignore next */
    else if (opts.selector) {
      // set this automagically for the user, similar to above
      params.filter = '_selector';
      method = 'POST';
      body = {selector: opts.selector };
    }

    var controller = new a();
    var lastFetchedSeq;

    // Get all the changes starting wtih the one immediately after the
    // sequence number given by since.
    var fetchData = function (since, callback) {
      if (opts.aborted) {
        return;
      }
      params.since = since;
      // "since" can be any kind of json object in Cloudant/CouchDB 2.x
      /* istanbul ignore next */
      if (typeof params.since === "object") {
        params.since = JSON.stringify(params.since);
      }

      if (opts.descending) {
        if (limit) {
          params.limit = leftToFetch;
        }
      } else {
        params.limit = (!limit || leftToFetch > batchSize) ?
          batchSize : leftToFetch;
      }

      // Set the options for the ajax call
      var url = genDBUrl(host, '_changes' + paramsToStr(params));
      var fetchOpts = {
        signal: controller.signal,
        method: method,
        body: JSON.stringify(body)
      };
      lastFetchedSeq = since;

      /* istanbul ignore if */
      if (opts.aborted) {
        return;
      }

      // Get the changes
      setup().then(function () {
        return fetchJSON(url, fetchOpts, callback);
      }).catch(callback);
    };

    // If opts.since exists, get all the changes from the sequence
    // number given by opts.since. Otherwise, get all the changes
    // from the sequence number 0.
    var results = {results: []};

    var fetched = function (err, res) {
      if (opts.aborted) {
        return;
      }
      var raw_results_length = 0;
      // If the result of the ajax call (res) contains changes (res.results)
      if (res && res.results) {
        raw_results_length = res.results.length;
        results.last_seq = res.last_seq;
        var pending = null;
        var lastSeq = null;
        // Attach 'pending' property if server supports it (CouchDB 2.0+)
        /* istanbul ignore if */
        if (typeof res.pending === 'number') {
          pending = res.pending;
        }
        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {
          lastSeq = results.last_seq;
        }
        // For each change
        var req = {};
        req.query = opts.query_params;
        res.results = res.results.filter(function (c) {
          leftToFetch--;
          var ret = filterChange(opts)(c);
          if (ret) {
            if (opts.include_docs && opts.attachments && opts.binary) {
              readAttachmentsAsBlobOrBuffer(c);
            }
            if (opts.return_docs) {
              results.results.push(c);
            }
            opts.onChange(c, pending, lastSeq);
          }
          return ret;
        });
      } else if (err) {
        // In case of an error, stop listening for changes and call
        // opts.complete
        opts.aborted = true;
        opts.complete(err);
        return;
      }

      // The changes feed may have timed out with no results
      // if so reuse last update sequence
      if (res && res.last_seq) {
        lastFetchedSeq = res.last_seq;
      }

      var finished = (limit && leftToFetch <= 0) ||
        (res && raw_results_length < batchSize) ||
        (opts.descending);

      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {
        // Queue a call to fetch again with the newest sequence number
        immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () { fetchData(lastFetchedSeq, fetched); });
      } else {
        // We're done, call the callback
        opts.complete(null, results);
      }
    };

    fetchData(opts.since || 0, fetched);

    // Return a method to cancel this method from processing any more
    return {
      cancel: function () {
        opts.aborted = true;
        controller.abort();
      }
    };
  };

  // Given a set of document/revision IDs (given by req), tets the subset of
  // those that do NOT correspond to revisions stored in the database.
  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {
    // If no options were given, set the callback to be the second parameter
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }

    // Get the missing document/revision IDs
    fetchJSON(genDBUrl(host, '_revs_diff'), {
      method: 'POST',
      body: JSON.stringify(req)
    }, callback).catch(callback);
  });

  api._close = function (callback) {
    callback();
  };

  api._destroy = function (options, callback) {
    fetchJSON(genDBUrl(host, ''), {method: 'DELETE'}).then(function (json) {
      callback(null, json);
    }).catch(function (err) {
      /* istanbul ignore if */
      if (err.status === 404) {
        callback(null, {ok: true});
      } else {
        callback(err);
      }
    });
  };
}

// HttpPouch is a valid adapter.
HttpPouch.valid = function () {
  return true;
};

function HttpPouch$1 (PouchDB) {
  PouchDB.adapter('http', HttpPouch, false);
  PouchDB.adapter('https', HttpPouch, false);
}

function QueryParseError(message) {
  this.status = 400;
  this.name = 'query_parse_error';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, QueryParseError);
  } catch (e) {}
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(QueryParseError, Error);

function NotFoundError(message) {
  this.status = 404;
  this.name = 'not_found';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, NotFoundError);
  } catch (e) {}
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(NotFoundError, Error);

function BuiltInError(message) {
  this.status = 500;
  this.name = 'invalid_value';
  this.message = message;
  this.error = true;
  try {
    Error.captureStackTrace(this, BuiltInError);
  } catch (e) {}
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(BuiltInError, Error);

function promisedCallback(promise, callback) {
  if (callback) {
    promise.then(function (res) {
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
        callback(null, res);
      });
    }, function (reason) {
      immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
        callback(reason);
      });
    });
  }
  return promise;
}

function callbackify(fun) {
  return argsarray__WEBPACK_IMPORTED_MODULE_4___default()(function (args) {
    var cb = args.pop();
    var promise = fun.apply(this, args);
    if (typeof cb === 'function') {
      promisedCallback(promise, cb);
    }
    return promise;
  });
}

// Promise finally util similar to Q.finally
function fin(promise, finalPromiseFactory) {
  return promise.then(function (res) {
    return finalPromiseFactory().then(function () {
      return res;
    });
  }, function (reason) {
    return finalPromiseFactory().then(function () {
      throw reason;
    });
  });
}

function sequentialize(queue, promiseFactory) {
  return function () {
    var args = arguments;
    var that = this;
    return queue.add(function () {
      return promiseFactory.apply(that, args);
    });
  };
}

// uniq an array of strings, order not guaranteed
// similar to underscore/lodash _.uniq
function uniq(arr) {
  var theSet = new ExportedSet(arr);
  var result = new Array(theSet.size);
  var index = -1;
  theSet.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

function mapToKeysArray(map) {
  var result = new Array(map.size);
  var index = -1;
  map.forEach(function (value, key) {
    result[++index] = key;
  });
  return result;
}

function createBuiltInError(name) {
  var message = 'builtin ' + name +
    ' function requires map values to be numbers' +
    ' or number arrays';
  return new BuiltInError(message);
}

function sum(values) {
  var result = 0;
  for (var i = 0, len = values.length; i < len; i++) {
    var num = values[i];
    if (typeof num !== 'number') {
      if (Array.isArray(num)) {
        // lists of numbers are also allowed, sum them separately
        result = typeof result === 'number' ? [result] : result;
        for (var j = 0, jLen = num.length; j < jLen; j++) {
          var jNum = num[j];
          if (typeof jNum !== 'number') {
            throw createBuiltInError('_sum');
          } else if (typeof result[j] === 'undefined') {
            result.push(jNum);
          } else {
            result[j] += jNum;
          }
        }
      } else { // not array/number
        throw createBuiltInError('_sum');
      }
    } else if (typeof result === 'number') {
      result += num;
    } else { // add number to array
      result[0] += num;
    }
  }
  return result;
}

var log = guardedConsole.bind(null, 'log');
var isArray = Array.isArray;
var toJSON = JSON.parse;

function evalFunctionWithEval(func, emit) {
  return scopeEval(
    "return (" + func.replace(/;\\s*$/, "") + ");",
    {
      emit: emit,
      sum: sum,
      log: log,
      isArray: isArray,
      toJSON: toJSON
    }
  );
}

/*
 * Simple task queue to sequentialize actions. Assumes
 * callbacks will eventually fire (once).
 */


function TaskQueue$1() {
  this.promise = new Promise(function (fulfill) {fulfill(); });
}
TaskQueue$1.prototype.add = function (promiseFactory) {
  this.promise = this.promise.catch(function () {
    // just recover
  }).then(function () {
    return promiseFactory();
  });
  return this.promise;
};
TaskQueue$1.prototype.finish = function () {
  return this.promise;
};

function stringify(input) {
  if (!input) {
    return 'undefined'; // backwards compat for empty reduce
  }
  // for backwards compat with mapreduce, functions/strings are stringified
  // as-is. everything else is JSON-stringified.
  switch (typeof input) {
    case 'function':
      // e.g. a mapreduce map
      return input.toString();
    case 'string':
      // e.g. a mapreduce built-in _reduce function
      return input.toString();
    default:
      // e.g. a JSON object in the case of mango queries
      return JSON.stringify(input);
  }
}

/* create a string signature for a view so we can cache it and uniq it */
function createViewSignature(mapFun, reduceFun) {
  // the "undefined" part is for backwards compatibility
  return stringify(mapFun) + stringify(reduceFun) + 'undefined';
}

function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {
  var viewSignature = createViewSignature(mapFun, reduceFun);

  var cachedViews;
  if (!temporary) {
    // cache this to ensure we don't try to update the same view twice
    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};
    if (cachedViews[viewSignature]) {
      return cachedViews[viewSignature];
    }
  }

  var promiseForView = sourceDB.info().then(function (info) {

    var depDbName = info.db_name + '-mrview-' +
      (temporary ? 'temp' : stringMd5(viewSignature));

    // save the view name in the source db so it can be cleaned up if necessary
    // (e.g. when the _design doc is deleted, remove all associated view data)
    function diffFunction(doc) {
      doc.views = doc.views || {};
      var fullViewName = viewName;
      if (fullViewName.indexOf('/') === -1) {
        fullViewName = viewName + '/' + viewName;
      }
      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
      /* istanbul ignore if */
      if (depDbs[depDbName]) {
        return; // no update necessary
      }
      depDbs[depDbName] = true;
      return doc;
    }
    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {
      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
        var db = res.db;
        db.auto_compaction = true;
        var view = {
          name: depDbName,
          db: db,
          sourceDB: sourceDB,
          adapter: sourceDB.adapter,
          mapFun: mapFun,
          reduceFun: reduceFun
        };
        return view.db.get('_local/lastSeq').catch(function (err) {
          /* istanbul ignore if */
          if (err.status !== 404) {
            throw err;
          }
        }).then(function (lastSeqDoc) {
          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
          if (cachedViews) {
            view.db.once('destroyed', function () {
              delete cachedViews[viewSignature];
            });
          }
          return view;
        });
      });
    });
  });

  if (cachedViews) {
    cachedViews[viewSignature] = promiseForView;
  }
  return promiseForView;
}

var persistentQueues = {};
var tempViewQueue = new TaskQueue$1();
var CHANGES_BATCH_SIZE$1 = 50;

function parseViewName(name) {
  // can be either 'ddocname/viewname' or just 'viewname'
  // (where the ddoc name is the same)
  return name.indexOf('/') === -1 ? [name, name] : name.split('/');
}

function isGenOne(changes) {
  // only return true if the current change is 1-
  // and there are no other leafs
  return changes.length === 1 && /^1-/.test(changes[0].rev);
}

function emitError(db, e) {
  try {
    db.emit('error', e);
  } catch (err) {
    guardedConsole('error',
      'The user\\'s map/reduce function threw an uncaught error.\\n' +
      'You can debug this error by doing:\\n' +
      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +
      'Please double-check your map/reduce function.');
    guardedConsole('error', e);
  }
}

/**
 * Returns an "abstract" mapreduce object of the form:
 *
 *   {
 *     query: queryFun,
 *     viewCleanup: viewCleanupFun
 *   }
 *
 * Arguments are:
 *
 * localDoc: string
 *   This is for the local doc that gets saved in order to track the
 *   "dependent" DBs and clean them up for viewCleanup. It should be
 *   unique, so that indexer plugins don't collide with each other.
 * mapper: function (mapFunDef, emit)
 *   Returns a map function based on the mapFunDef, which in the case of
 *   normal map/reduce is just the de-stringified function, but may be
 *   something else, such as an object in the case of pouchdb-find.
 * reducer: function (reduceFunDef)
 *   Ditto, but for reducing. Modules don't have to support reducing
 *   (e.g. pouchdb-find).
 * ddocValidator: function (ddoc, viewName)
 *   Throws an error if the ddoc or viewName is not valid.
 *   This could be a way to communicate to the user that the configuration for the
 *   indexer is invalid.
 */
function createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {

  function tryMap(db, fun, doc) {
    // emit an event if there was an error thrown by a map function.
    // putting try/catches in a single function also avoids deoptimizations.
    try {
      fun(doc);
    } catch (e) {
      emitError(db, e);
    }
  }

  function tryReduce(db, fun, keys, values, rereduce) {
    // same as above, but returning the result or an error. there are two separate
    // functions to avoid extra memory allocations since the tryCode() case is used
    // for custom map functions (common) vs this function, which is only used for
    // custom reduce functions (rare)
    try {
      return {output : fun(keys, values, rereduce)};
    } catch (e) {
      emitError(db, e);
      return {error: e};
    }
  }

  function sortByKeyThenValue(x, y) {
    var keyCompare = collate(x.key, y.key);
    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
  }

  function sliceResults(results, limit, skip) {
    skip = skip || 0;
    if (typeof limit === 'number') {
      return results.slice(skip, limit + skip);
    } else if (skip > 0) {
      return results.slice(skip);
    }
    return results;
  }

  function rowToDocId(row) {
    var val = row.value;
    // Users can explicitly specify a joined doc _id, or it
    // defaults to the doc _id that emitted the key/value.
    var docId = (val && typeof val === 'object' && val._id) || row.id;
    return docId;
  }

  function readAttachmentsAsBlobOrBuffer(res) {
    res.rows.forEach(function (row) {
      var atts = row.doc && row.doc._attachments;
      if (!atts) {
        return;
      }
      Object.keys(atts).forEach(function (filename) {
        var att = atts[filename];
        atts[filename].data = b64ToBluffer(att.data, att.content_type);
      });
    });
  }

  function postprocessAttachments(opts) {
    return function (res) {
      if (opts.include_docs && opts.attachments && opts.binary) {
        readAttachmentsAsBlobOrBuffer(res);
      }
      return res;
    };
  }

  function addHttpParam(paramName, opts, params, asJson) {
    // add an http param from opts to params, optionally json-encoded
    var val = opts[paramName];
    if (typeof val !== 'undefined') {
      if (asJson) {
        val = encodeURIComponent(JSON.stringify(val));
      }
      params.push(paramName + '=' + val);
    }
  }

  function coerceInteger(integerCandidate) {
    if (typeof integerCandidate !== 'undefined') {
      var asNumber = Number(integerCandidate);
      // prevents e.g. '1foo' or '1.1' being coerced to 1
      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {
        return asNumber;
      } else {
        return integerCandidate;
      }
    }
  }

  function coerceOptions(opts) {
    opts.group_level = coerceInteger(opts.group_level);
    opts.limit = coerceInteger(opts.limit);
    opts.skip = coerceInteger(opts.skip);
    return opts;
  }

  function checkPositiveInteger(number) {
    if (number) {
      if (typeof number !== 'number') {
        return  new QueryParseError('Invalid value for integer: "' +
          number + '"');
      }
      if (number < 0) {
        return new QueryParseError('Invalid value for positive integer: ' +
          '"' + number + '"');
      }
    }
  }

  function checkQueryParseError(options, fun) {
    var startkeyName = options.descending ? 'endkey' : 'startkey';
    var endkeyName = options.descending ? 'startkey' : 'endkey';

    if (typeof options[startkeyName] !== 'undefined' &&
      typeof options[endkeyName] !== 'undefined' &&
      collate(options[startkeyName], options[endkeyName]) > 0) {
      throw new QueryParseError('No rows can match your key range, ' +
        'reverse your start_key and end_key or set {descending : true}');
    } else if (fun.reduce && options.reduce !== false) {
      if (options.include_docs) {
        throw new QueryParseError('{include_docs:true} is invalid for reduce');
      } else if (options.keys && options.keys.length > 1 &&
        !options.group && !options.group_level) {
        throw new QueryParseError('Multi-key fetches for reduce views must use ' +
          '{group: true}');
      }
    }
    ['group_level', 'limit', 'skip'].forEach(function (optionName) {
      var error = checkPositiveInteger(options[optionName]);
      if (error) {
        throw error;
      }
    });
  }

  function httpQuery(db, fun, opts) {
    // List of parameters to add to the PUT request
    var params = [];
    var body;
    var method = 'GET';
    var ok, status;

    // If opts.reduce exists and is defined, then add it to the list
    // of parameters.
    // If reduce=false then the results are that of only the map function
    // not the final result of map and reduce.
    addHttpParam('reduce', opts, params);
    addHttpParam('include_docs', opts, params);
    addHttpParam('attachments', opts, params);
    addHttpParam('limit', opts, params);
    addHttpParam('descending', opts, params);
    addHttpParam('group', opts, params);
    addHttpParam('group_level', opts, params);
    addHttpParam('skip', opts, params);
    addHttpParam('stale', opts, params);
    addHttpParam('conflicts', opts, params);
    addHttpParam('startkey', opts, params, true);
    addHttpParam('start_key', opts, params, true);
    addHttpParam('endkey', opts, params, true);
    addHttpParam('end_key', opts, params, true);
    addHttpParam('inclusive_end', opts, params);
    addHttpParam('key', opts, params, true);
    addHttpParam('update_seq', opts, params);

    // Format the list of parameters into a valid URI query string
    params = params.join('&');
    params = params === '' ? '' : '?' + params;

    // If keys are supplied, issue a POST to circumvent GET query string limits
    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
    if (typeof opts.keys !== 'undefined') {
      var MAX_URL_LENGTH = 2000;
      // according to http://stackoverflow.com/a/417184/680742,
      // the de facto URL length limit is 2000 characters

      var keysAsString =
        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
        // If the keys are short enough, do a GET. we do this to work around
        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)
        params += (params[0] === '?' ? '&' : '?') + keysAsString;
      } else {
        method = 'POST';
        if (typeof fun === 'string') {
          body = {keys: opts.keys};
        } else { // fun is {map : mapfun}, so append to this
          fun.keys = opts.keys;
        }
      }
    }

    // We are referencing a query defined in the design doc
    if (typeof fun === 'string') {
      var parts = parseViewName(fun);
      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {
        headers: new h({'Content-Type': 'application/json'}),
        method: method,
        body: JSON.stringify(body)
      }).then(function (response) {
        ok = response.ok;
        status = response.status;
        return response.json();
      }).then(function (result) {
        if (!ok) {
          result.status = status;
          throw generateErrorFromResponse(result);
        }
        // fail the entire request if the result contains an error
        result.rows.forEach(function (row) {
          /* istanbul ignore if */
          if (row.value && row.value.error && row.value.error === "builtin_reduce_error") {
            throw new Error(row.reason);
          }
        });
        return result;
      }).then(postprocessAttachments(opts));
    }

    // We are using a temporary view, terrible for performance, good for testing
    body = body || {};
    Object.keys(fun).forEach(function (key) {
      if (Array.isArray(fun[key])) {
        body[key] = fun[key];
      } else {
        body[key] = fun[key].toString();
      }
    });

    return db.fetch('_temp_view' + params, {
      headers: new h({'Content-Type': 'application/json'}),
      method: 'POST',
      body: JSON.stringify(body)
    }).then(function (response) {
        ok = response.ok;
        status = response.status;
      return response.json();
    }).then(function (result) {
      if (!ok) {
        result.status = status;
        throw generateErrorFromResponse(result);
      }
      return result;
    }).then(postprocessAttachments(opts));
  }

  // custom adapters can define their own api._query
  // and override the default behavior
  /* istanbul ignore next */
  function customQuery(db, fun, opts) {
    return new Promise(function (resolve, reject) {
      db._query(fun, opts, function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  // custom adapters can define their own api._viewCleanup
  // and override the default behavior
  /* istanbul ignore next */
  function customViewCleanup(db) {
    return new Promise(function (resolve, reject) {
      db._viewCleanup(function (err, res) {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  }

  function defaultsTo(value) {
    return function (reason) {
      /* istanbul ignore else */
      if (reason.status === 404) {
        return value;
      } else {
        throw reason;
      }
    };
  }

  // returns a promise for a list of docs to update, based on the input docId.
  // the order doesn't matter, because post-3.2.0, bulkDocs
  // is an atomic operation in all three adapters.
  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
    var metaDocId = '_local/doc_' + docId;
    var defaultMetaDoc = {_id: metaDocId, keys: []};
    var docData = docIdsToChangesAndEmits.get(docId);
    var indexableKeysToKeyValues = docData[0];
    var changes = docData[1];

    function getMetaDoc() {
      if (isGenOne(changes)) {
        // generation 1, so we can safely assume initial state
        // for performance reasons (avoids unnecessary GETs)
        return Promise.resolve(defaultMetaDoc);
      }
      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));
    }

    function getKeyValueDocs(metaDoc) {
      if (!metaDoc.keys.length) {
        // no keys, no need for a lookup
        return Promise.resolve({rows: []});
      }
      return view.db.allDocs({
        keys: metaDoc.keys,
        include_docs: true
      });
    }

    function processKeyValueDocs(metaDoc, kvDocsRes) {
      var kvDocs = [];
      var oldKeys = new ExportedSet();

      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
        var row = kvDocsRes.rows[i];
        var doc = row.doc;
        if (!doc) { // deleted
          continue;
        }
        kvDocs.push(doc);
        oldKeys.add(doc._id);
        doc._deleted = !indexableKeysToKeyValues.has(doc._id);
        if (!doc._deleted) {
          var keyValue = indexableKeysToKeyValues.get(doc._id);
          if ('value' in keyValue) {
            doc.value = keyValue.value;
          }
        }
      }
      var newKeys = mapToKeysArray(indexableKeysToKeyValues);
      newKeys.forEach(function (key) {
        if (!oldKeys.has(key)) {
          // new doc
          var kvDoc = {
            _id: key
          };
          var keyValue = indexableKeysToKeyValues.get(key);
          if ('value' in keyValue) {
            kvDoc.value = keyValue.value;
          }
          kvDocs.push(kvDoc);
        }
      });
      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));
      kvDocs.push(metaDoc);

      return kvDocs;
    }

    return getMetaDoc().then(function (metaDoc) {
      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
        return processKeyValueDocs(metaDoc, kvDocsRes);
      });
    });
  }

  // updates all emitted key/value docs and metaDocs in the mrview database
  // for the given batch of documents from the source database
  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
    var seqDocId = '_local/lastSeq';
    return view.db.get(seqDocId)
      .catch(defaultsTo({_id: seqDocId, seq: 0}))
      .then(function (lastSeqDoc) {
        var docIds = mapToKeysArray(docIdsToChangesAndEmits);
        return Promise.all(docIds.map(function (docId) {
          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
        })).then(function (listOfDocsToPersist) {
          var docsToPersist = flatten(listOfDocsToPersist);
          lastSeqDoc.seq = seq;
          docsToPersist.push(lastSeqDoc);
          // write all docs in a single operation, update the seq once
          return view.db.bulkDocs({docs : docsToPersist});
        });
      });
  }

  function getQueue(view) {
    var viewName = typeof view === 'string' ? view : view.name;
    var queue = persistentQueues[viewName];
    if (!queue) {
      queue = persistentQueues[viewName] = new TaskQueue$1();
    }
    return queue;
  }

  function updateView(view) {
    return sequentialize(getQueue(view), function () {
      return updateViewInQueue(view);
    })();
  }

  function updateViewInQueue(view) {
    // bind the emit function once
    var mapResults;
    var doc;

    function emit(key, value) {
      var output = {id: doc._id, key: normalizeKey(key)};
      // Don't explicitly store the value unless it's defined and non-null.
      // This saves on storage space, because often people don't use it.
      if (typeof value !== 'undefined' && value !== null) {
        output.value = normalizeKey(value);
      }
      mapResults.push(output);
    }

    var mapFun = mapper(view.mapFun, emit);

    var currentSeq = view.seq || 0;

    function processChange(docIdsToChangesAndEmits, seq) {
      return function () {
        return saveKeyValues(view, docIdsToChangesAndEmits, seq);
      };
    }

    var queue = new TaskQueue$1();

    function processNextBatch() {
      return view.sourceDB.changes({
        return_docs: true,
        conflicts: true,
        include_docs: true,
        style: 'all_docs',
        since: currentSeq,
        limit: CHANGES_BATCH_SIZE$1
      }).then(processBatch);
    }

    function processBatch(response) {
      var results = response.results;
      if (!results.length) {
        return;
      }
      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);
      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
      if (results.length < CHANGES_BATCH_SIZE$1) {
        return;
      }
      return processNextBatch();
    }

    function createDocIdsToChangesAndEmits(results) {
      var docIdsToChangesAndEmits = new ExportedMap();
      for (var i = 0, len = results.length; i < len; i++) {
        var change = results[i];
        if (change.doc._id[0] !== '_') {
          mapResults = [];
          doc = change.doc;

          if (!doc._deleted) {
            tryMap(view.sourceDB, mapFun, doc);
          }
          mapResults.sort(sortByKeyThenValue);

          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);
          docIdsToChangesAndEmits.set(change.doc._id, [
            indexableKeysToKeyValues,
            change.changes
          ]);
        }
        currentSeq = change.seq;
      }
      return docIdsToChangesAndEmits;
    }

    function createIndexableKeysToKeyValues(mapResults) {
      var indexableKeysToKeyValues = new ExportedMap();
      var lastKey;
      for (var i = 0, len = mapResults.length; i < len; i++) {
        var emittedKeyValue = mapResults[i];
        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];
        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {
          complexKey.push(i); // dup key+id, so make it unique
        }
        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);
        lastKey = emittedKeyValue.key;
      }
      return indexableKeysToKeyValues;
    }

    return processNextBatch().then(function () {
      return queue.finish();
    }).then(function () {
      view.seq = currentSeq;
    });
  }

  function reduceView(view, results, options) {
    if (options.group_level === 0) {
      delete options.group_level;
    }

    var shouldGroup = options.group || options.group_level;

    var reduceFun = reducer(view.reduceFun);

    var groups = [];
    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :
      options.group_level;
    results.forEach(function (e) {
      var last = groups[groups.length - 1];
      var groupKey = shouldGroup ? e.key : null;

      // only set group_level for array keys
      if (shouldGroup && Array.isArray(groupKey)) {
        groupKey = groupKey.slice(0, lvl);
      }

      if (last && collate(last.groupKey, groupKey) === 0) {
        last.keys.push([e.key, e.id]);
        last.values.push(e.value);
        return;
      }
      groups.push({
        keys: [[e.key, e.id]],
        values: [e.value],
        groupKey: groupKey
      });
    });
    results = [];
    for (var i = 0, len = groups.length; i < len; i++) {
      var e = groups[i];
      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);
      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {
        // CouchDB returns an error if a built-in errors out
        throw reduceTry.error;
      }
      results.push({
        // CouchDB just sets the value to null if a non-built-in errors out
        value: reduceTry.error ? null : reduceTry.output,
        key: e.groupKey
      });
    }
    // no total_rows/offset when reducing
    return {rows: sliceResults(results, options.limit, options.skip)};
  }

  function queryView(view, opts) {
    return sequentialize(getQueue(view), function () {
      return queryViewInQueue(view, opts);
    })();
  }

  function queryViewInQueue(view, opts) {
    var totalRows;
    var shouldReduce = view.reduceFun && opts.reduce !== false;
    var skip = opts.skip || 0;
    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
      // equivalent query
      opts.limit = 0;
      delete opts.keys;
    }

    function fetchFromView(viewOpts) {
      viewOpts.include_docs = true;
      return view.db.allDocs(viewOpts).then(function (res) {
        totalRows = res.total_rows;
        return res.rows.map(function (result) {

          // implicit migration - in older versions of PouchDB,
          // we explicitly stored the doc as {id: ..., key: ..., value: ...}
          // this is tested in a migration test
          /* istanbul ignore next */
          if ('value' in result.doc && typeof result.doc.value === 'object' &&
            result.doc.value !== null) {
            var keys = Object.keys(result.doc.value).sort();
            // this detection method is not perfect, but it's unlikely the user
            // emitted a value which was an object with these 3 exact keys
            var expectedKeys = ['id', 'key', 'value'];
            if (!(keys < expectedKeys || keys > expectedKeys)) {
              return result.doc.value;
            }
          }

          var parsedKeyAndDocId = parseIndexableString(result.doc._id);
          return {
            key: parsedKeyAndDocId[0],
            id: parsedKeyAndDocId[1],
            value: ('value' in result.doc ? result.doc.value : null)
          };
        });
      });
    }

    function onMapResultsReady(rows) {
      var finalResults;
      if (shouldReduce) {
        finalResults = reduceView(view, rows, opts);
      } else {
        finalResults = {
          total_rows: totalRows,
          offset: skip,
          rows: rows
        };
      }
      /* istanbul ignore if */
      if (opts.update_seq) {
        finalResults.update_seq = view.seq;
      }
      if (opts.include_docs) {
        var docIds = uniq(rows.map(rowToDocId));

        return view.sourceDB.allDocs({
          keys: docIds,
          include_docs: true,
          conflicts: opts.conflicts,
          attachments: opts.attachments,
          binary: opts.binary
        }).then(function (allDocsRes) {
          var docIdsToDocs = new ExportedMap();
          allDocsRes.rows.forEach(function (row) {
            docIdsToDocs.set(row.id, row.doc);
          });
          rows.forEach(function (row) {
            var docId = rowToDocId(row);
            var doc = docIdsToDocs.get(docId);
            if (doc) {
              row.doc = doc;
            }
          });
          return finalResults;
        });
      } else {
        return finalResults;
      }
    }

    if (typeof opts.keys !== 'undefined') {
      var keys = opts.keys;
      var fetchPromises = keys.map(function (key) {
        var viewOpts = {
          startkey : toIndexableString([key]),
          endkey   : toIndexableString([key, {}])
        };
        /* istanbul ignore if */
        if (opts.update_seq) {
          viewOpts.update_seq = true;
        }
        return fetchFromView(viewOpts);
      });
      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);
    } else { // normal query, no 'keys'
      var viewOpts = {
        descending : opts.descending
      };
      /* istanbul ignore if */
      if (opts.update_seq) {
        viewOpts.update_seq = true;
      }
      var startkey;
      var endkey;
      if ('start_key' in opts) {
        startkey = opts.start_key;
      }
      if ('startkey' in opts) {
        startkey = opts.startkey;
      }
      if ('end_key' in opts) {
        endkey = opts.end_key;
      }
      if ('endkey' in opts) {
        endkey = opts.endkey;
      }
      if (typeof startkey !== 'undefined') {
        viewOpts.startkey = opts.descending ?
          toIndexableString([startkey, {}]) :
          toIndexableString([startkey]);
      }
      if (typeof endkey !== 'undefined') {
        var inclusiveEnd = opts.inclusive_end !== false;
        if (opts.descending) {
          inclusiveEnd = !inclusiveEnd;
        }

        viewOpts.endkey = toIndexableString(
          inclusiveEnd ? [endkey, {}] : [endkey]);
      }
      if (typeof opts.key !== 'undefined') {
        var keyStart = toIndexableString([opts.key]);
        var keyEnd = toIndexableString([opts.key, {}]);
        if (viewOpts.descending) {
          viewOpts.endkey = keyStart;
          viewOpts.startkey = keyEnd;
        } else {
          viewOpts.startkey = keyStart;
          viewOpts.endkey = keyEnd;
        }
      }
      if (!shouldReduce) {
        if (typeof opts.limit === 'number') {
          viewOpts.limit = opts.limit;
        }
        viewOpts.skip = skip;
      }
      return fetchFromView(viewOpts).then(onMapResultsReady);
    }
  }

  function httpViewCleanup(db) {
    return db.fetch('_view_cleanup', {
      headers: new h({'Content-Type': 'application/json'}),
      method: 'POST'
    }).then(function (response) {
      return response.json();
    });
  }

  function localViewCleanup(db) {
    return db.get('_local/' + localDocName).then(function (metaDoc) {
      var docsToViews = new ExportedMap();
      Object.keys(metaDoc.views).forEach(function (fullViewName) {
        var parts = parseViewName(fullViewName);
        var designDocName = '_design/' + parts[0];
        var viewName = parts[1];
        var views = docsToViews.get(designDocName);
        if (!views) {
          views = new ExportedSet();
          docsToViews.set(designDocName, views);
        }
        views.add(viewName);
      });
      var opts = {
        keys : mapToKeysArray(docsToViews),
        include_docs : true
      };
      return db.allDocs(opts).then(function (res) {
        var viewsToStatus = {};
        res.rows.forEach(function (row) {
          var ddocName = row.key.substring(8); // cuts off '_design/'
          docsToViews.get(row.key).forEach(function (viewName) {
            var fullViewName = ddocName + '/' + viewName;
            /* istanbul ignore if */
            if (!metaDoc.views[fullViewName]) {
              // new format, without slashes, to support PouchDB 2.2.0
              // migration test in pouchdb's browser.migration.js verifies this
              fullViewName = viewName;
            }
            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
            // design doc deleted, or view function nonexistent
            var statusIsGood = row.doc && row.doc.views &&
              row.doc.views[viewName];
            viewDBNames.forEach(function (viewDBName) {
              viewsToStatus[viewDBName] =
                viewsToStatus[viewDBName] || statusIsGood;
            });
          });
        });
        var dbsToDelete = Object.keys(viewsToStatus).filter(
          function (viewDBName) { return !viewsToStatus[viewDBName]; });
        var destroyPromises = dbsToDelete.map(function (viewDBName) {
          return sequentialize(getQueue(viewDBName), function () {
            return new db.constructor(viewDBName, db.__opts).destroy();
          })();
        });
        return Promise.all(destroyPromises).then(function () {
          return {ok: true};
        });
      });
    }, defaultsTo({ok: true}));
  }

  function queryPromised(db, fun, opts) {
    /* istanbul ignore next */
    if (typeof db._query === 'function') {
      return customQuery(db, fun, opts);
    }
    if (isRemote(db)) {
      return httpQuery(db, fun, opts);
    }

    if (typeof fun !== 'string') {
      // temp_view
      checkQueryParseError(opts, fun);

      tempViewQueue.add(function () {
        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ 'temp_view/temp_view',
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ true,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          return fin(updateView(view).then(function () {
            return queryView(view, opts);
          }), function () {
            return view.db.destroy();
          });
        });
      });
      return tempViewQueue.finish();
    } else {
      // persistent view
      var fullViewName = fun;
      var parts = parseViewName(fullViewName);
      var designDocName = parts[0];
      var viewName = parts[1];
      return db.get('_design/' + designDocName).then(function (doc) {
        var fun = doc.views && doc.views[viewName];

        if (!fun) {
          // basic validator; it's assumed that every subclass would want this
          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +
            viewName);
        }

        ddocValidator(doc, viewName);
        checkQueryParseError(opts, fun);

        var createViewPromise = createView(
          /* sourceDB */ db,
          /* viewName */ fullViewName,
          /* mapFun */ fun.map,
          /* reduceFun */ fun.reduce,
          /* temporary */ false,
          /* localDocName */ localDocName);
        return createViewPromise.then(function (view) {
          if (opts.stale === 'ok' || opts.stale === 'update_after') {
            if (opts.stale === 'update_after') {
              immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
                updateView(view);
              });
            }
            return queryView(view, opts);
          } else { // stale not ok
            return updateView(view).then(function () {
              return queryView(view, opts);
            });
          }
        });
      });
    }
  }

  function abstractQuery(fun, opts, callback) {
    var db = this;
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    opts = opts ? coerceOptions(opts) : {};

    if (typeof fun === 'function') {
      fun = {map : fun};
    }

    var promise = Promise.resolve().then(function () {
      return queryPromised(db, fun, opts);
    });
    promisedCallback(promise, callback);
    return promise;
  }

  var abstractViewCleanup = callbackify(function () {
    var db = this;
    /* istanbul ignore next */
    if (typeof db._viewCleanup === 'function') {
      return customViewCleanup(db);
    }
    if (isRemote(db)) {
      return httpViewCleanup(db);
    }
    return localViewCleanup(db);
  });

  return {
    query: abstractQuery,
    viewCleanup: abstractViewCleanup
  };
}

var builtInReduce = {
  _sum: function (keys, values) {
    return sum(values);
  },

  _count: function (keys, values) {
    return values.length;
  },

  _stats: function (keys, values) {
    // no need to implement rereduce=true, because Pouch
    // will never call it
    function sumsqr(values) {
      var _sumsqr = 0;
      for (var i = 0, len = values.length; i < len; i++) {
        var num = values[i];
        _sumsqr += (num * num);
      }
      return _sumsqr;
    }
    return {
      sum     : sum(values),
      min     : Math.min.apply(null, values),
      max     : Math.max.apply(null, values),
      count   : values.length,
      sumsqr : sumsqr(values)
    };
  }
};

function getBuiltIn(reduceFunString) {
  if (/^_sum/.test(reduceFunString)) {
    return builtInReduce._sum;
  } else if (/^_count/.test(reduceFunString)) {
    return builtInReduce._count;
  } else if (/^_stats/.test(reduceFunString)) {
    return builtInReduce._stats;
  } else if (/^_/.test(reduceFunString)) {
    throw new Error(reduceFunString + ' is not a supported reduce function.');
  }
}

function mapper(mapFun, emit) {
  // for temp_views one can use emit(doc, emit), see #38
  if (typeof mapFun === "function" && mapFun.length === 2) {
    var origMap = mapFun;
    return function (doc) {
      return origMap(doc, emit);
    };
  } else {
    return evalFunctionWithEval(mapFun.toString(), emit);
  }
}

function reducer(reduceFun) {
  var reduceFunString = reduceFun.toString();
  var builtIn = getBuiltIn(reduceFunString);
  if (builtIn) {
    return builtIn;
  } else {
    return evalFunctionWithEval(reduceFunString);
  }
}

function ddocValidator(ddoc, viewName) {
  var fun = ddoc.views && ddoc.views[viewName];
  if (typeof fun.map !== 'string') {
    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +
      viewName + ', instead found object of type: ' + typeof fun.map);
  }
}

var localDocName = 'mrviews';
var abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);

function query(fun, opts, callback) {
  return abstract.query.call(this, fun, opts, callback);
}

function viewCleanup(callback) {
  return abstract.viewCleanup.call(this, callback);
}

var mapreduce = {
  query: query,
  viewCleanup: viewCleanup
};

function isGenOne$1(rev$$1) {
  return /^1-/.test(rev$$1);
}

function fileHasChanged(localDoc, remoteDoc, filename) {
  return !localDoc._attachments ||
         !localDoc._attachments[filename] ||
         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;
}

function getDocAttachments(db, doc) {
  var filenames = Object.keys(doc._attachments);
  return Promise.all(filenames.map(function (filename) {
    return db.getAttachment(doc._id, filename, {rev: doc._rev});
  }));
}

function getDocAttachmentsFromTargetOrSource(target, src, doc) {
  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);
  var filenames = Object.keys(doc._attachments);

  if (!doCheckForLocalAttachments) {
    return getDocAttachments(src, doc);
  }

  return target.get(doc._id).then(function (localDoc) {
    return Promise.all(filenames.map(function (filename) {
      if (fileHasChanged(localDoc, doc, filename)) {
        return src.getAttachment(doc._id, filename);
      }

      return target.getAttachment(localDoc._id, filename);
    }));
  }).catch(function (error) {
    /* istanbul ignore if */
    if (error.status !== 404) {
      throw error;
    }

    return getDocAttachments(src, doc);
  });
}

function createBulkGetOpts(diffs) {
  var requests = [];
  Object.keys(diffs).forEach(function (id) {
    var missingRevs = diffs[id].missing;
    missingRevs.forEach(function (missingRev) {
      requests.push({
        id: id,
        rev: missingRev
      });
    });
  });

  return {
    docs: requests,
    revs: true,
    latest: true
  };
}

//
// Fetch all the documents from the src as described in the "diffs",
// which is a mapping of docs IDs to revisions. If the state ever
// changes to "cancelled", then the returned promise will be rejected.
// Else it will be resolved with a list of fetched documents.
//
function getDocs(src, target, diffs, state) {
  diffs = clone(diffs); // we do not need to modify this

  var resultDocs = [],
      ok = true;

  function getAllDocs() {

    var bulkGetOpts = createBulkGetOpts(diffs);

    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests
      return;
    }

    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {
      /* istanbul ignore if */
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {
        return Promise.all(bulkGetInfo.docs.map(function (doc) {
          var remoteDoc = doc.ok;

          if (doc.error) {
            // when AUTO_COMPACTION is set, docs can be returned which look
            // like this: {"missing":"1-7c3ac256b693c462af8442f992b83696"}
            ok = false;
          }

          if (!remoteDoc || !remoteDoc._attachments) {
            return remoteDoc;
          }

          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)
                   .then(function (attachments) {
                           var filenames = Object.keys(remoteDoc._attachments);
                           attachments
                             .forEach(function (attachment, i) {
                                        var att = remoteDoc._attachments[filenames[i]];
                                        delete att.stub;
                                        delete att.length;
                                        att.data = attachment;
                                      });

                                      return remoteDoc;
                                    });
        }));
      }))

      .then(function (results) {
        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));
      });
    });
  }

  function hasAttachments(doc) {
    return doc._attachments && Object.keys(doc._attachments).length > 0;
  }

  function hasConflicts(doc) {
    return doc._conflicts && doc._conflicts.length > 0;
  }

  function fetchRevisionOneDocs(ids) {
    // Optimization: fetch gen-1 docs and attachments in
    // a single request using _all_docs
    return src.allDocs({
      keys: ids,
      include_docs: true,
      conflicts: true
    }).then(function (res) {
      if (state.cancelled) {
        throw new Error('cancelled');
      }
      res.rows.forEach(function (row) {
        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||
            hasAttachments(row.doc) || hasConflicts(row.doc)) {
          // if any of these conditions apply, we need to fetch using get()
          return;
        }

        // strip _conflicts array to appease CSG (#5793)
        /* istanbul ignore if */
        if (row.doc._conflicts) {
          delete row.doc._conflicts;
        }

        // the doc we got back from allDocs() is sufficient
        resultDocs.push(row.doc);
        delete diffs[row.id];
      });
    });
  }

  function getRevisionOneDocs() {
    // filter out the generation 1 docs and get them
    // leaving the non-generation one docs to be got otherwise
    var ids = Object.keys(diffs).filter(function (id) {
      var missing = diffs[id].missing;
      return missing.length === 1 && isGenOne$1(missing[0]);
    });
    if (ids.length > 0) {
      return fetchRevisionOneDocs(ids);
    }
  }

  function returnResult() {
    return { ok:ok, docs:resultDocs };
  }

  return Promise.resolve()
    .then(getRevisionOneDocs)
    .then(getAllDocs)
    .then(returnResult);
}

var CHECKPOINT_VERSION = 1;
var REPLICATOR = "pouchdb";
// This is an arbitrary number to limit the
// amount of replication history we save in the checkpoint.
// If we save too much, the checkpoing docs will become very big,
// if we save fewer, we'll run a greater risk of having to
// read all the changes from 0 when checkpoint PUTs fail
// CouchDB 2.0 has a more involved history pruning,
// but let's go for the simple version for now.
var CHECKPOINT_HISTORY_SIZE = 5;
var LOWEST_SEQ = 0;

function updateCheckpoint(db, id, checkpoint, session, returnValue) {
  return db.get(id).catch(function (err) {
    if (err.status === 404) {
      if (db.adapter === 'http' || db.adapter === 'https') {
        explainError(
          404, 'PouchDB is just checking if a remote checkpoint exists.'
        );
      }
      return {
        session_id: session,
        _id: id,
        history: [],
        replicator: REPLICATOR,
        version: CHECKPOINT_VERSION
      };
    }
    throw err;
  }).then(function (doc) {
    if (returnValue.cancelled) {
      return;
    }

    // if the checkpoint has not changed, do not update
    if (doc.last_seq === checkpoint) {
      return;
    }

    // Filter out current entry for this replication
    doc.history = (doc.history || []).filter(function (item) {
      return item.session_id !== session;
    });

    // Add the latest checkpoint to history
    doc.history.unshift({
      last_seq: checkpoint,
      session_id: session
    });

    // Just take the last pieces in history, to
    // avoid really big checkpoint docs.
    // see comment on history size above
    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);

    doc.version = CHECKPOINT_VERSION;
    doc.replicator = REPLICATOR;

    doc.session_id = session;
    doc.last_seq = checkpoint;

    return db.put(doc).catch(function (err) {
      if (err.status === 409) {
        // retry; someone is trying to write a checkpoint simultaneously
        return updateCheckpoint(db, id, checkpoint, session, returnValue);
      }
      throw err;
    });
  });
}

function Checkpointer(src, target, id, returnValue, opts) {
  this.src = src;
  this.target = target;
  this.id = id;
  this.returnValue = returnValue;
  this.opts = opts || {};
}

Checkpointer.prototype.writeCheckpoint = function (checkpoint, session) {
  var self = this;
  return this.updateTarget(checkpoint, session).then(function () {
    return self.updateSource(checkpoint, session);
  });
};

Checkpointer.prototype.updateTarget = function (checkpoint, session) {
  if (this.opts.writeTargetCheckpoint) {
    return updateCheckpoint(this.target, this.id, checkpoint,
      session, this.returnValue);
  } else {
    return Promise.resolve(true);
  }
};

Checkpointer.prototype.updateSource = function (checkpoint, session) {
  if (this.opts.writeSourceCheckpoint) {
    var self = this;
    return updateCheckpoint(this.src, this.id, checkpoint,
      session, this.returnValue)
      .catch(function (err) {
        if (isForbiddenError(err)) {
          self.opts.writeSourceCheckpoint = false;
          return true;
        }
        throw err;
      });
  } else {
    return Promise.resolve(true);
  }
};

var comparisons = {
  "undefined": function (targetDoc, sourceDoc) {
    // This is the previous comparison function
    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {
      return sourceDoc.last_seq;
    }
    /* istanbul ignore next */
    return 0;
  },
  "1": function (targetDoc, sourceDoc) {
    // This is the comparison function ported from CouchDB
    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;
  }
};

Checkpointer.prototype.getCheckpoint = function () {
  var self = this;

  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {
    return self.src.get(self.id).then(function (sourceDoc) {
      return sourceDoc.last_seq || LOWEST_SEQ;
    }).catch(function (err) {
      /* istanbul ignore if */
      if (err.status !== 404) {
        throw err;
      }
      return LOWEST_SEQ;
    });
  }

  return self.target.get(self.id).then(function (targetDoc) {
    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {
      return targetDoc.last_seq || LOWEST_SEQ;
    }

    return self.src.get(self.id).then(function (sourceDoc) {
      // Since we can't migrate an old version doc to a new one
      // (no session id), we just go with the lowest seq in this case
      /* istanbul ignore if */
      if (targetDoc.version !== sourceDoc.version) {
        return LOWEST_SEQ;
      }

      var version;
      if (targetDoc.version) {
        version = targetDoc.version.toString();
      } else {
        version = "undefined";
      }

      if (version in comparisons) {
        return comparisons[version](targetDoc, sourceDoc);
      }
      /* istanbul ignore next */
      return LOWEST_SEQ;
    }, function (err) {
      if (err.status === 404 && targetDoc.last_seq) {
        return self.src.put({
          _id: self.id,
          last_seq: LOWEST_SEQ
        }).then(function () {
          return LOWEST_SEQ;
        }, function (err) {
          if (isForbiddenError(err)) {
            self.opts.writeSourceCheckpoint = false;
            return targetDoc.last_seq;
          }
          /* istanbul ignore next */
          return LOWEST_SEQ;
        });
      }
      throw err;
    });
  }).catch(function (err) {
    if (err.status !== 404) {
      throw err;
    }
    return LOWEST_SEQ;
  });
};
// This checkpoint comparison is ported from CouchDBs source
// they come from here:
// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906

function compareReplicationLogs(srcDoc, tgtDoc) {
  if (srcDoc.session_id === tgtDoc.session_id) {
    return {
      last_seq: srcDoc.last_seq,
      history: srcDoc.history
    };
  }

  return compareReplicationHistory(srcDoc.history, tgtDoc.history);
}

function compareReplicationHistory(sourceHistory, targetHistory) {
  // the erlang loop via function arguments is not so easy to repeat in JS
  // therefore, doing this as recursion
  var S = sourceHistory[0];
  var sourceRest = sourceHistory.slice(1);
  var T = targetHistory[0];
  var targetRest = targetHistory.slice(1);

  if (!S || targetHistory.length === 0) {
    return {
      last_seq: LOWEST_SEQ,
      history: []
    };
  }

  var sourceId = S.session_id;
  /* istanbul ignore if */
  if (hasSessionId(sourceId, targetHistory)) {
    return {
      last_seq: S.last_seq,
      history: sourceHistory
    };
  }

  var targetId = T.session_id;
  if (hasSessionId(targetId, sourceRest)) {
    return {
      last_seq: T.last_seq,
      history: targetRest
    };
  }

  return compareReplicationHistory(sourceRest, targetRest);
}

function hasSessionId(sessionId, history) {
  var props = history[0];
  var rest = history.slice(1);

  if (!sessionId || history.length === 0) {
    return false;
  }

  if (sessionId === props.session_id) {
    return true;
  }

  return hasSessionId(sessionId, rest);
}

function isForbiddenError(err) {
  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;
}

var STARTING_BACK_OFF = 0;

function backOff(opts, returnValue, error, callback) {
  if (opts.retry === false) {
    returnValue.emit('error', error);
    returnValue.removeAllListeners();
    return;
  }
  /* istanbul ignore if */
  if (typeof opts.back_off_function !== 'function') {
    opts.back_off_function = defaultBackOff;
  }
  returnValue.emit('requestError', error);
  if (returnValue.state === 'active' || returnValue.state === 'pending') {
    returnValue.emit('paused', error);
    returnValue.state = 'stopped';
    var backOffSet = function backoffTimeSet() {
      opts.current_back_off = STARTING_BACK_OFF;
    };
    var removeBackOffSetter = function removeBackOffTimeSet() {
      returnValue.removeListener('active', backOffSet);
    };
    returnValue.once('paused', removeBackOffSetter);
    returnValue.once('active', backOffSet);
  }

  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;
  opts.current_back_off = opts.back_off_function(opts.current_back_off);
  setTimeout(callback, opts.current_back_off);
}

function sortObjectPropertiesByKey(queryParams) {
  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {
    result[key] = queryParams[key];
    return result;
  }, {});
}

// Generate a unique id particular to this replication.
// Not guaranteed to align perfectly with CouchDB's rep ids.
function generateReplicationId(src, target, opts) {
  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';
  var filterFun = opts.filter ? opts.filter.toString() : '';
  var queryParams = '';
  var filterViewName =  '';
  var selector = '';

  // possibility for checkpoints to be lost here as behaviour of
  // JSON.stringify is not stable (see #6226)
  /* istanbul ignore if */
  if (opts.selector) {
    selector = JSON.stringify(opts.selector);
  }

  if (opts.filter && opts.query_params) {
    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));
  }

  if (opts.filter && opts.filter === '_view') {
    filterViewName = opts.view.toString();
  }

  return Promise.all([src.id(), target.id()]).then(function (res) {
    var queryData = res[0] + res[1] + filterFun + filterViewName +
      queryParams + docIds + selector;
    return new Promise(function (resolve) {
      binaryMd5(queryData, resolve);
    });
  }).then(function (md5sum) {
    // can't use straight-up md5 alphabet, because
    // the char '/' is interpreted as being for attachments,
    // and + is also not url-safe
    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');
    return '_local/' + md5sum;
  });
}

function replicate(src, target, opts, returnValue, result) {
  var batches = [];               // list of batches to be processed
  var currentBatch;               // the batch currently being processed
  var pendingBatch = {
    seq: 0,
    changes: [],
    docs: []
  }; // next batch, not yet ready to be processed
  var writingCheckpoint = false;  // true while checkpoint is being written
  var changesCompleted = false;   // true when all changes received
  var replicationCompleted = false; // true when replication has completed
  var last_seq = 0;
  var continuous = opts.continuous || opts.live || false;
  var batch_size = opts.batch_size || 100;
  var batches_limit = opts.batches_limit || 10;
  var changesPending = false;     // true while src.changes is running
  var doc_ids = opts.doc_ids;
  var selector = opts.selector;
  var repId;
  var checkpointer;
  var changedDocs = [];
  // Like couchdb, every replication gets a unique session id
  var session = uuid();

  result = result || {
    ok: true,
    start_time: new Date().toISOString(),
    docs_read: 0,
    docs_written: 0,
    doc_write_failures: 0,
    errors: []
  };

  var changesOpts = {};
  returnValue.ready(src, target);

  function initCheckpointer() {
    if (checkpointer) {
      return Promise.resolve();
    }
    return generateReplicationId(src, target, opts).then(function (res) {
      repId = res;

      var checkpointOpts = {};
      if (opts.checkpoint === false) {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'source') {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };
      } else if (opts.checkpoint === 'target') {
        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };
      } else {
        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };
      }

      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);
    });
  }

  function writeDocs() {
    changedDocs = [];

    if (currentBatch.docs.length === 0) {
      return;
    }
    var docs = currentBatch.docs;
    var bulkOpts = {timeout: opts.timeout};
    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }

      // \`res\` doesn't include full documents (which live in \`docs\`), so we create a map of 
      // (id -> error), and check for errors while iterating over \`docs\`
      var errorsById = Object.create(null);
      res.forEach(function (res) {
        if (res.error) {
          errorsById[res.id] = res;
        }
      });

      var errorsNo = Object.keys(errorsById).length;
      result.doc_write_failures += errorsNo;
      result.docs_written += docs.length - errorsNo;

      docs.forEach(function (doc) {
        var error = errorsById[doc._id];
        if (error) {
          result.errors.push(error);
          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
          var errorName = (error.name || '').toLowerCase();
          if (errorName === 'unauthorized' || errorName === 'forbidden') {
            returnValue.emit('denied', clone(error));
          } else {
            throw error;
          }
        } else {
          changedDocs.push(doc);
        }
      });

    }, function (err) {
      result.doc_write_failures += docs.length;
      throw err;
    });
  }

  function finishBatch() {
    if (currentBatch.error) {
      throw new Error('There was a problem getting docs.');
    }
    result.last_seq = last_seq = currentBatch.seq;
    var outResult = clone(result);
    if (changedDocs.length) {
      outResult.docs = changedDocs;
      // Attach 'pending' property if server supports it (CouchDB 2.0+)
      /* istanbul ignore if */
      if (typeof currentBatch.pending === 'number') {
        outResult.pending = currentBatch.pending;
        delete currentBatch.pending;
      }
      returnValue.emit('change', outResult);
    }
    writingCheckpoint = true;
    return checkpointer.writeCheckpoint(currentBatch.seq,
        session).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      currentBatch = undefined;
      getChanges();
    }).catch(function (err) {
      onCheckpointError(err);
      throw err;
    });
  }

  function getDiffs() {
    var diff = {};
    currentBatch.changes.forEach(function (change) {
      // Couchbase Sync Gateway emits these, but we can ignore them
      /* istanbul ignore if */
      if (change.id === "_user/") {
        return;
      }
      diff[change.id] = change.changes.map(function (x) {
        return x.rev;
      });
    });
    return target.revsDiff(diff).then(function (diffs) {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        throw new Error('cancelled');
      }
      // currentBatch.diffs elements are deleted as the documents are written
      currentBatch.diffs = diffs;
    });
  }

  function getBatchDocs() {
    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {
      currentBatch.error = !got.ok;
      got.docs.forEach(function (doc) {
        delete currentBatch.diffs[doc._id];
        result.docs_read++;
        currentBatch.docs.push(doc);
      });
    });
  }

  function startNextBatch() {
    if (returnValue.cancelled || currentBatch) {
      return;
    }
    if (batches.length === 0) {
      processPendingBatch(true);
      return;
    }
    currentBatch = batches.shift();
    getDiffs()
      .then(getBatchDocs)
      .then(writeDocs)
      .then(finishBatch)
      .then(startNextBatch)
      .catch(function (err) {
        abortReplication('batch processing terminated with error', err);
      });
  }


  function processPendingBatch(immediate$$1) {
    if (pendingBatch.changes.length === 0) {
      if (batches.length === 0 && !currentBatch) {
        if ((continuous && changesOpts.live) || changesCompleted) {
          returnValue.state = 'pending';
          returnValue.emit('paused');
        }
        if (changesCompleted) {
          completeReplication();
        }
      }
      return;
    }
    if (
      immediate$$1 ||
      changesCompleted ||
      pendingBatch.changes.length >= batch_size
    ) {
      batches.push(pendingBatch);
      pendingBatch = {
        seq: 0,
        changes: [],
        docs: []
      };
      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {
        returnValue.state = 'active';
        returnValue.emit('active');
      }
      startNextBatch();
    }
  }


  function abortReplication(reason, err) {
    if (replicationCompleted) {
      return;
    }
    if (!err.message) {
      err.message = reason;
    }
    result.ok = false;
    result.status = 'aborting';
    batches = [];
    pendingBatch = {
      seq: 0,
      changes: [],
      docs: []
    };
    completeReplication(err);
  }


  function completeReplication(fatalError) {
    if (replicationCompleted) {
      return;
    }
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      result.status = 'cancelled';
      if (writingCheckpoint) {
        return;
      }
    }
    result.status = result.status || 'complete';
    result.end_time = new Date().toISOString();
    result.last_seq = last_seq;
    replicationCompleted = true;

    if (fatalError) {
      // need to extend the error because Firefox considers ".result" read-only
      fatalError = createError(fatalError);
      fatalError.result = result;

      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)
      var errorName = (fatalError.name || '').toLowerCase();
      if (errorName === 'unauthorized' || errorName === 'forbidden') {
        returnValue.emit('error', fatalError);
        returnValue.removeAllListeners();
      } else {
        backOff(opts, returnValue, fatalError, function () {
          replicate(src, target, opts, returnValue);
        });
      }
    } else {
      returnValue.emit('complete', result);
      returnValue.removeAllListeners();
    }
  }


  function onChange(change, pending, lastSeq) {
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    // Attach 'pending' property if server supports it (CouchDB 2.0+)
    /* istanbul ignore if */
    if (typeof pending === 'number') {
      pendingBatch.pending = pending;
    }

    var filter = filterChange(opts)(change);
    if (!filter) {
      return;
    }
    pendingBatch.seq = change.seq || lastSeq;
    pendingBatch.changes.push(change);
    immediate__WEBPACK_IMPORTED_MODULE_0___default()(function () {
      processPendingBatch(batches.length === 0 && changesOpts.live);
    });
  }


  function onChangesComplete(changes) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }

    // if no results were returned then we're done,
    // else fetch more
    if (changes.results.length > 0) {
      changesOpts.since = changes.results[changes.results.length - 1].seq;
      getChanges();
      processPendingBatch(true);
    } else {

      var complete = function () {
        if (continuous) {
          changesOpts.live = true;
          getChanges();
        } else {
          changesCompleted = true;
        }
        processPendingBatch(true);
      };

      // update the checkpoint so we start from the right seq next time
      if (!currentBatch && changes.results.length === 0) {
        writingCheckpoint = true;
        checkpointer.writeCheckpoint(changes.last_seq,
            session).then(function () {
          writingCheckpoint = false;
          result.last_seq = last_seq = changes.last_seq;
          complete();
        })
        .catch(onCheckpointError);
      } else {
        complete();
      }
    }
  }


  function onChangesError(err) {
    changesPending = false;
    /* istanbul ignore if */
    if (returnValue.cancelled) {
      return completeReplication();
    }
    abortReplication('changes rejected', err);
  }


  function getChanges() {
    if (!(
      !changesPending &&
      !changesCompleted &&
      batches.length < batches_limit
      )) {
      return;
    }
    changesPending = true;
    function abortChanges() {
      changes.cancel();
    }
    function removeListener() {
      returnValue.removeListener('cancel', abortChanges);
    }

    if (returnValue._changes) { // remove old changes() and listeners
      returnValue.removeListener('cancel', returnValue._abortChanges);
      returnValue._changes.cancel();
    }
    returnValue.once('cancel', abortChanges);

    var changes = src.changes(changesOpts)
      .on('change', onChange);
    changes.then(removeListener, removeListener);
    changes.then(onChangesComplete)
      .catch(onChangesError);

    if (opts.retry) {
      // save for later so we can cancel if necessary
      returnValue._changes = changes;
      returnValue._abortChanges = abortChanges;
    }
  }


  function startChanges() {
    initCheckpointer().then(function () {
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      return checkpointer.getCheckpoint().then(function (checkpoint) {
        last_seq = checkpoint;
        changesOpts = {
          since: last_seq,
          limit: batch_size,
          batch_size: batch_size,
          style: 'all_docs',
          doc_ids: doc_ids,
          selector: selector,
          return_docs: true // required so we know when we're done
        };
        if (opts.filter) {
          if (typeof opts.filter !== 'string') {
            // required for the client-side filter in onChange
            changesOpts.include_docs = true;
          } else { // ddoc filter
            changesOpts.filter = opts.filter;
          }
        }
        if ('heartbeat' in opts) {
          changesOpts.heartbeat = opts.heartbeat;
        }
        if ('timeout' in opts) {
          changesOpts.timeout = opts.timeout;
        }
        if (opts.query_params) {
          changesOpts.query_params = opts.query_params;
        }
        if (opts.view) {
          changesOpts.view = opts.view;
        }
        getChanges();
      });
    }).catch(function (err) {
      abortReplication('getCheckpoint rejected with ', err);
    });
  }

  /* istanbul ignore next */
  function onCheckpointError(err) {
    writingCheckpoint = false;
    abortReplication('writeCheckpoint completed with error', err);
  }

  /* istanbul ignore if */
  if (returnValue.cancelled) { // cancelled immediately
    completeReplication();
    return;
  }

  if (!returnValue._addedListeners) {
    returnValue.once('cancel', completeReplication);

    if (typeof opts.complete === 'function') {
      returnValue.once('error', opts.complete);
      returnValue.once('complete', function (result) {
        opts.complete(null, result);
      });
    }
    returnValue._addedListeners = true;
  }

  if (typeof opts.since === 'undefined') {
    startChanges();
  } else {
    initCheckpointer().then(function () {
      writingCheckpoint = true;
      return checkpointer.writeCheckpoint(opts.since, session);
    }).then(function () {
      writingCheckpoint = false;
      /* istanbul ignore if */
      if (returnValue.cancelled) {
        completeReplication();
        return;
      }
      last_seq = opts.since;
      startChanges();
    }).catch(onCheckpointError);
  }
}

// We create a basic promise so the caller can cancel the replication possibly
// before we have actually started listening to changes etc
inherits__WEBPACK_IMPORTED_MODULE_5___default()(Replication, events__WEBPACK_IMPORTED_MODULE_6___default.a);
function Replication() {
  events__WEBPACK_IMPORTED_MODULE_6___default.a.call(this);
  this.cancelled = false;
  this.state = 'pending';
  var self = this;
  var promise = new Promise(function (fulfill, reject) {
    self.once('complete', fulfill);
    self.once('error', reject);
  });
  self.then = function (resolve, reject) {
    return promise.then(resolve, reject);
  };
  self.catch = function (reject) {
    return promise.catch(reject);
  };
  // As we allow error handling via "error" event as well,
  // put a stub in here so that rejecting never throws UnhandledError.
  self.catch(function () {});
}

Replication.prototype.cancel = function () {
  this.cancelled = true;
  this.state = 'cancelled';
  this.emit('cancel');
};

Replication.prototype.ready = function (src, target) {
  var self = this;
  if (self._readyCalled) {
    return;
  }
  self._readyCalled = true;

  function onDestroy() {
    self.cancel();
  }
  src.once('destroyed', onDestroy);
  target.once('destroyed', onDestroy);
  function cleanup() {
    src.removeListener('destroyed', onDestroy);
    target.removeListener('destroyed', onDestroy);
  }
  self.once('complete', cleanup);
};

function toPouch(db, opts) {
  var PouchConstructor = opts.PouchConstructor;
  if (typeof db === 'string') {
    return new PouchConstructor(db, opts);
  } else {
    return db;
  }
}

function replicateWrapper(src, target, opts, callback) {

  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }

  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {
    throw createError(BAD_REQUEST,
                       "\`doc_ids\` filter parameter is not a list.");
  }

  opts.complete = callback;
  opts = clone(opts);
  opts.continuous = opts.continuous || opts.live;
  opts.retry = ('retry' in opts) ? opts.retry : false;
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  var replicateRet = new Replication(opts);
  var srcPouch = toPouch(src, opts);
  var targetPouch = toPouch(target, opts);
  replicate(srcPouch, targetPouch, opts, replicateRet);
  return replicateRet;
}

inherits__WEBPACK_IMPORTED_MODULE_5___default()(Sync, events__WEBPACK_IMPORTED_MODULE_6___default.a);
function sync(src, target, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  if (typeof opts === 'undefined') {
    opts = {};
  }
  opts = clone(opts);
  /*jshint validthis:true */
  opts.PouchConstructor = opts.PouchConstructor || this;
  src = toPouch(src, opts);
  target = toPouch(target, opts);
  return new Sync(src, target, opts, callback);
}

function Sync(src, target, opts, callback) {
  var self = this;
  this.canceled = false;

  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;
  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;

  this.push = replicateWrapper(src, target, optsPush);
  this.pull = replicateWrapper(target, src, optsPull);

  this.pushPaused = true;
  this.pullPaused = true;

  function pullChange(change) {
    self.emit('change', {
      direction: 'pull',
      change: change
    });
  }
  function pushChange(change) {
    self.emit('change', {
      direction: 'push',
      change: change
    });
  }
  function pushDenied(doc) {
    self.emit('denied', {
      direction: 'push',
      doc: doc
    });
  }
  function pullDenied(doc) {
    self.emit('denied', {
      direction: 'pull',
      doc: doc
    });
  }
  function pushPaused() {
    self.pushPaused = true;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('paused');
    }
  }
  function pullPaused() {
    self.pullPaused = true;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('paused');
    }
  }
  function pushActive() {
    self.pushPaused = false;
    /* istanbul ignore if */
    if (self.pullPaused) {
      self.emit('active', {
        direction: 'push'
      });
    }
  }
  function pullActive() {
    self.pullPaused = false;
    /* istanbul ignore if */
    if (self.pushPaused) {
      self.emit('active', {
        direction: 'pull'
      });
    }
  }

  var removed = {};

  function removeAll(type) { // type is 'push' or 'pull'
    return function (event, func) {
      var isChange = event === 'change' &&
        (func === pullChange || func === pushChange);
      var isDenied = event === 'denied' &&
        (func === pullDenied || func === pushDenied);
      var isPaused = event === 'paused' &&
        (func === pullPaused || func === pushPaused);
      var isActive = event === 'active' &&
        (func === pullActive || func === pushActive);

      if (isChange || isDenied || isPaused || isActive) {
        if (!(event in removed)) {
          removed[event] = {};
        }
        removed[event][type] = true;
        if (Object.keys(removed[event]).length === 2) {
          // both push and pull have asked to be removed
          self.removeAllListeners(event);
        }
      }
    };
  }

  if (opts.live) {
    this.push.on('complete', self.pull.cancel.bind(self.pull));
    this.pull.on('complete', self.push.cancel.bind(self.push));
  }

  function addOneListener(ee, event, listener) {
    if (ee.listeners(event).indexOf(listener) == -1) {
      ee.on(event, listener);
    }
  }

  this.on('newListener', function (event) {
    if (event === 'change') {
      addOneListener(self.pull, 'change', pullChange);
      addOneListener(self.push, 'change', pushChange);
    } else if (event === 'denied') {
      addOneListener(self.pull, 'denied', pullDenied);
      addOneListener(self.push, 'denied', pushDenied);
    } else if (event === 'active') {
      addOneListener(self.pull, 'active', pullActive);
      addOneListener(self.push, 'active', pushActive);
    } else if (event === 'paused') {
      addOneListener(self.pull, 'paused', pullPaused);
      addOneListener(self.push, 'paused', pushPaused);
    }
  });

  this.on('removeListener', function (event) {
    if (event === 'change') {
      self.pull.removeListener('change', pullChange);
      self.push.removeListener('change', pushChange);
    } else if (event === 'denied') {
      self.pull.removeListener('denied', pullDenied);
      self.push.removeListener('denied', pushDenied);
    } else if (event === 'active') {
      self.pull.removeListener('active', pullActive);
      self.push.removeListener('active', pushActive);
    } else if (event === 'paused') {
      self.pull.removeListener('paused', pullPaused);
      self.push.removeListener('paused', pushPaused);
    }
  });

  this.pull.on('removeListener', removeAll('pull'));
  this.push.on('removeListener', removeAll('push'));

  var promise = Promise.all([
    this.push,
    this.pull
  ]).then(function (resp) {
    var out = {
      push: resp[0],
      pull: resp[1]
    };
    self.emit('complete', out);
    if (callback) {
      callback(null, out);
    }
    self.removeAllListeners();
    return out;
  }, function (err) {
    self.cancel();
    if (callback) {
      // if there's a callback, then the callback can receive
      // the error event
      callback(err);
    } else {
      // if there's no callback, then we're safe to emit an error
      // event, which would otherwise throw an unhandled error
      // due to 'error' being a special event in EventEmitters
      self.emit('error', err);
    }
    self.removeAllListeners();
    if (callback) {
      // no sense throwing if we're already emitting an 'error' event
      throw err;
    }
  });

  this.then = function (success, err) {
    return promise.then(success, err);
  };

  this.catch = function (err) {
    return promise.catch(err);
  };
}

Sync.prototype.cancel = function () {
  if (!this.canceled) {
    this.canceled = true;
    this.push.cancel();
    this.pull.cancel();
  }
};

function replication(PouchDB) {
  PouchDB.replicate = replicateWrapper;
  PouchDB.sync = sync;

  Object.defineProperty(PouchDB.prototype, 'replicate', {
    get: function () {
      var self = this;
      if (typeof this.replicateMethods === 'undefined') {
        this.replicateMethods = {
          from: function (other, opts, callback) {
            return self.constructor.replicate(other, self, opts, callback);
          },
          to: function (other, opts, callback) {
            return self.constructor.replicate(self, other, opts, callback);
          }
        };
      }
      return this.replicateMethods;
    }
  });

  PouchDB.prototype.sync = function (dbName, opts, callback) {
    return this.constructor.sync(this, dbName, opts, callback);
  };
}

PouchDB.plugin(IDBPouch)
  .plugin(HttpPouch$1)
  .plugin(mapreduce)
  .plugin(replication);

/* harmony default export */ __webpack_exports__["default"] = (PouchDB);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/lib/index.es.js?`)},"./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js":function(module,exports){eval(`if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js?`)},"./node_modules/pouchdb-browser/node_modules/spark-md5/spark-md5.js":function(module,exports,__webpack_require__){eval(`(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\\u0080-\\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/spark-md5/spark-md5.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  return (bth[buf[i + 0]] + bth[buf[i + 1]] + bth[buf[i + 2]] + bth[buf[i + 3]] + '-' + bth[buf[i + 4]] + bth[buf[i + 5]] + '-' + bth[buf[i + 6]] + bth[buf[i + 7]] + '-' + bth[buf[i + 8]] + bth[buf[i + 9]] + '-' + bth[buf[i + 10]] + bth[buf[i + 11]] + bth[buf[i + 12]] + bth[buf[i + 13]] + bth[buf[i + 14]] + bth[buf[i + 15]]).toLowerCase();
}

/* harmony default export */ __webpack_exports__["default"] = (bytesToUuid);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/index.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v1", function() { return _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v3", function() { return _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v4", function() { return _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "v5", function() { return _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });






//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/index.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/md5.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ __webpack_exports__["default"] = (md5);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/md5.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rng; });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
var getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
  }

  return getRandomValues(rnds8);
}

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/sha1.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ __webpack_exports__["default"] = (sha1);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/sha1.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v1.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytesToUuid.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js");

 // **\`v1()\` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // \`time_low\`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // \`time_mid\`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // \`time_high_and_version\`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // \`clock_seq_hi_and_reserved\` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // \`clock_seq_low\`

  b[i++] = clockseq & 0xff; // \`node\`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ __webpack_exports__["default"] = (v1);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v1.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v3.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/md5.js");


var v3 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (v3);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v3.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DNS", function() { return DNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URL", function() { return URL; });
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytesToUuid.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js");


function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ __webpack_exports__["default"] = (function (name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value === 'string') value = stringToBytes(value);
    if (typeof namespace === 'string') namespace = uuidToBytes(namespace);

    if (!Array.isArray(value)) {
      throw TypeError('value must be an array of bytes');
    }

    if (!Array.isArray(namespace) || namespace.length !== 16) {
      throw TypeError('namespace must be uuid string or an Array of 16 byte values');
    } // Per 4.3


    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }

    return buf || Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_0__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
});

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v4.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytesToUuid.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/bytesToUuid.js");



function v4(options, buf, offset) {
  if (typeof options === 'string') {
    buf = options === 'binary' ? new Uint8Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and \`clock_seq_hi_and_reserved\`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    var start = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[start + i] = rnds[i];
    }

    return buf;
  }

  return Object(_bytesToUuid_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ __webpack_exports__["default"] = (v4);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v4.js?`)},"./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v5.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = Object(_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (v5);

//# sourceURL=webpack://%5Bname%5D/./node_modules/pouchdb-browser/node_modules/uuid/dist/esm-browser/v5.js?`)},"./node_modules/process/browser.js":function(module,exports){eval(`// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


//# sourceURL=webpack://%5Bname%5D/./node_modules/process/browser.js?`)},"./node_modules/spark-md5/spark-md5.js":function(module,exports,__webpack_require__){eval(`(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\\u0080-\\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} raw     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     raw True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


//# sourceURL=webpack://%5Bname%5D/./node_modules/spark-md5/spark-md5.js?`)},"./node_modules/uri-js/dist/es5/uri.all.js":function(module,exports,__webpack_require__){eval(`/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\\\x0A]",
        SP$$ = "[\\\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]",
        SUB_DELIMS$$ = "[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\\\uE000-\\\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\\\-\\\\.\\\\_\\\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\\\+\\\\-\\\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,1}" + H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,2}" + H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,3}" + H16$) + "?\\\\:\\\\:" + H16$ + "\\\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,4}" + H16$) + "?\\\\:\\\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,5}" + H16$) + "?\\\\:\\\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,6}" + H16$) + "?\\\\:\\\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\\\%25|\\\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:]") + "+"),
        IP_LITERAL$ = subexp("\\\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\\\/\\\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\\\/\\\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\\\/\\\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\\\:" + HIER_PART$ + subexp("\\\\?" + QUERY$) + "?" + subexp("\\\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\\\/\\\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\\\?" + QUERY$) + "?" + subexp("\\\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\\\:" + HIER_PART$ + subexp("\\\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\\\:" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\\\:" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\\\+\\\\-\\\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\\\%\\\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\\\%\\\\[\\\\]\\\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\\\%\\\\/\\\\:\\\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\\\%\\\\/\\\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@\\\\/\\\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@\\\\/\\\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\\\%25|\\\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars
var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a \`RangeError\` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic \`Array#map\` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple \`Array#map\`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to \`@\`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid \`split(regex)\` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see \`punycode.ucs2.encode\`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see \`punycode.ucs2.decode\`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see \`digitToBasic()\`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range \`0\` to \`base - 1\`, or \`base\` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see \`basicToDigit()\`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is \`digit\`, which needs to be in the range
 * \`0\` to \`base - 1\`. If \`flag\` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if \`flag\` is non-zero and \`digit\` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let \`basic\` be the number of input code
	// points before the last delimiter, or \`0\` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// \`index\` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into \`delta\`,
		// which gets added to \`i\`. The overflow checking is easier
		// if we increase \`i\` as we go, then subtract off its starting
		// value at the end to obtain \`delta\`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// \`i\` was supposed to wrap around from \`out\` to \`0\`,
		// incrementing \`n\` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert \`n\` at position \`i\` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// \`handledCPCount\` is the number of code points that have been handled;
	// \`basicLength\` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase \`delta\` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT \`\`AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\\.\\.?\\//;
var RDS2 = /^\\/\\.(\\/|$)/;
var RDS3 = /^\\/\\.\\.(\\/|$)/;
var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\\/\\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~" + (isIRI ? "\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\\`\\\\{\\\\|\\\\}\\\\~]";
//const WSP$$ = "[\\\\x20\\\\x09]";
//const OBS_QTEXT$$ = "[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\\\x21-\\\\x7E]";
//const WSP$$ = "[\\\\x20\\\\x09]";
//const OBS_QP$ = subexp("\\\\\\\\" + merge("[\\\\x00\\\\x0D\\\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\\\x0D\\\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\\\"');
var ATEXT$$ = "[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\\`\\\\{\\\\|\\\\}\\\\~]";
var QTEXT$$ = "[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\\\\"\\\\\\\\]");
var SOME_DELIMS$$ = "[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\\\.]", '[\\\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\\:]+)\\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map


//# sourceURL=webpack://%5Bname%5D/./node_modules/uri-js/dist/es5/uri.all.js?`)},"./node_modules/vuvuzela/index.js":function(module,exports,__webpack_require__){eval(`

/**
 * Stringify/parse functions that don't operate
 * recursively, so they avoid call stack exceeded
 * errors.
 */
exports.stringify = function stringify(input) {
  var queue = [];
  queue.push({obj: input});

  var res = '';
  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
  while ((next = queue.pop())) {
    obj = next.obj;
    prefix = next.prefix || '';
    val = next.val || '';
    res += prefix;
    if (val) {
      res += val;
    } else if (typeof obj !== 'object') {
      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
    } else if (obj === null) {
      res += 'null';
    } else if (Array.isArray(obj)) {
      queue.push({val: ']'});
      for (i = obj.length - 1; i >= 0; i--) {
        arrayPrefix = i === 0 ? '' : ',';
        queue.push({obj: obj[i], prefix: arrayPrefix});
      }
      queue.push({val: '['});
    } else { // object
      keys = [];
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          keys.push(k);
        }
      }
      queue.push({val: '}'});
      for (i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        value = obj[key];
        objPrefix = (i > 0 ? ',' : '');
        objPrefix += JSON.stringify(key) + ':';
        queue.push({obj: value, prefix: objPrefix});
      }
      queue.push({val: '{'});
    }
  }
  return res;
};

// Convenience function for the parse function.
// This pop function is basically copied from
// pouchCollate.parseIndexableString
function pop(obj, stack, metaStack) {
  var lastMetaElement = metaStack[metaStack.length - 1];
  if (obj === lastMetaElement.element) {
    // popping a meta-element, e.g. an object whose value is another object
    metaStack.pop();
    lastMetaElement = metaStack[metaStack.length - 1];
  }
  var element = lastMetaElement.element;
  var lastElementIndex = lastMetaElement.index;
  if (Array.isArray(element)) {
    element.push(obj);
  } else if (lastElementIndex === stack.length - 2) { // obj with key+value
    var key = stack.pop();
    element[key] = obj;
  } else {
    stack.push(obj); // obj with key only
  }
}

exports.parse = function (str) {
  var stack = [];
  var metaStack = []; // stack for arrays and objects
  var i = 0;
  var collationIndex,parsedNum,numChar;
  var parsedString,lastCh,numConsecutiveSlashes,ch;
  var arrayElement, objElement;
  while (true) {
    collationIndex = str[i++];
    if (collationIndex === '}' ||
        collationIndex === ']' ||
        typeof collationIndex === 'undefined') {
      if (stack.length === 1) {
        return stack.pop();
      } else {
        pop(stack.pop(), stack, metaStack);
        continue;
      }
    }
    switch (collationIndex) {
      case ' ':
      case '\\t':
      case '\\n':
      case ':':
      case ',':
        break;
      case 'n':
        i += 3; // 'ull'
        pop(null, stack, metaStack);
        break;
      case 't':
        i += 3; // 'rue'
        pop(true, stack, metaStack);
        break;
      case 'f':
        i += 4; // 'alse'
        pop(false, stack, metaStack);
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        parsedNum = '';
        i--;
        while (true) {
          numChar = str[i++];
          if (/[\\d\\.\\-e\\+]/.test(numChar)) {
            parsedNum += numChar;
          } else {
            i--;
            break;
          }
        }
        pop(parseFloat(parsedNum), stack, metaStack);
        break;
      case '"':
        parsedString = '';
        lastCh = void 0;
        numConsecutiveSlashes = 0;
        while (true) {
          ch = str[i++];
          if (ch !== '"' || (lastCh === '\\\\' &&
              numConsecutiveSlashes % 2 === 1)) {
            parsedString += ch;
            lastCh = ch;
            if (lastCh === '\\\\') {
              numConsecutiveSlashes++;
            } else {
              numConsecutiveSlashes = 0;
            }
          } else {
            break;
          }
        }
        pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
        break;
      case '[':
        arrayElement = { element: [], index: stack.length };
        stack.push(arrayElement.element);
        metaStack.push(arrayElement);
        break;
      case '{':
        objElement = { element: {}, index: stack.length };
        stack.push(objElement.element);
        metaStack.push(objElement);
        break;
      default:
        throw new Error(
          'unexpectedly reached end of input: ' + collationIndex);
    }
  }
};


//# sourceURL=webpack://%5Bname%5D/./node_modules/vuvuzela/index.js?`)},"./node_modules/webpack/buildin/amd-define.js":function(module,exports){eval(`module.exports = function() {
	throw new Error("define cannot be used indirect");
};


//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/amd-define.js?`)},"./node_modules/webpack/buildin/amd-options.js":function(module,exports){eval(`/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/amd-options.js?`)},"./node_modules/webpack/buildin/global.js":function(module,exports){eval(`var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/global.js?`)},"./node_modules/webpack/buildin/module.js":function(module,exports){eval(`module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


//# sourceURL=webpack://%5Bname%5D/(webpack)/buildin/module.js?`)},"./package.json":function(module){eval(`module.exports = JSON.parse("{\\"name\\":\\"imjoy-core\\",\\"version\\":\\"0.14.5\\",\\"private\\":false,\\"description\\":\\"The core library for ImJoy -- a sandboxed plugin framework for computational web applications.\\",\\"author\\":\\"imjoy-team <imjoy.team@gmail.com>\\",\\"license\\":\\"MIT\\",\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/imjoy-team/imjoy-core.git\\"},\\"keywords\\":[\\"ImJoy\\",\\"PWA\\",\\"Deep Learning\\"],\\"bugs\\":{\\"url\\":\\"https://github.com/imjoy-team/ImJoy/issues\\"},\\"homepage\\":\\"https://imjoy.io\\",\\"module\\":\\"index.js\\",\\"scripts\\":{\\"serve\\":\\"webpack-dev-server --config webpack.config.js --mode development\\",\\"build\\":\\"rm -rf dist && npm run build-prod && npm run build-dev\\",\\"build-prod\\":\\"NODE_ENV=production webpack --config webpack.config.js --mode production  --devtool source-map\\",\\"build-dev\\":\\"NODE_ENV=development webpack --config webpack.config.js --mode development\\",\\"watch\\":\\"webpack --watch --progress --config  webpack.config.js --mode development\\",\\"check-format\\":\\"prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"format\\":\\"prettier --write \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"lint\\":\\"eslint \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"check\\":\\"eslint \\\\\\"{src,tests}/**/**\\\\\\" && prettier --check \\\\\\"{src,tests}/**/**\\\\\\"\\",\\"test\\":\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\",\\"test-watch\\":\\"karma start --auto-watch --browsers Chrome,FirefoxHeadless karma.conf.js --debug\\",\\"deploy\\":\\"npm run build && node deploy-site.js\\",\\"publish-npm\\":\\"npm install && npm run build && npm publish\\"},\\"dependencies\\":{\\"ajv\\":\\"^6.9.1\\",\\"axios\\":\\"^0.21.1\\",\\"dompurify\\":\\"^2.0.8\\",\\"file-saver\\":\\"^1.3.3\\",\\"imjoy-rpc\\":\\"^0.5.9\\",\\"js-yaml\\":\\"^3.13.1\\",\\"lodash\\":\\"^4.17.15\\",\\"lz-string\\":\\"^1.4.4\\",\\"minibus\\":\\"^3.1.0\\",\\"pouchdb-browser\\":\\"^7.2.2\\",\\"socket.io-client\\":\\"^2.3.0\\",\\"spark-md5\\":\\"^3.0.0\\"},\\"devDependencies\\":{\\"@babel/core\\":\\"^7.0.0-beta.39\\",\\"@babel/plugin-syntax-dynamic-import\\":\\"^7.0.0-beta.39\\",\\"@babel/polyfill\\":\\"^7.0.0-beta.39\\",\\"@babel/preset-env\\":\\"^7.0.0-beta.39\\",\\"@types/requirejs\\":\\"^2.1.28\\",\\"babel-core\\":\\"^6.26.0\\",\\"babel-eslint\\":\\"^10.1.0\\",\\"babel-loader\\":\\"^8.1.0\\",\\"babel-plugin-lodash\\":\\"^3.3.4\\",\\"babel-runtime\\":\\"^6.26.0\\",\\"chai\\":\\"^4.1.2\\",\\"cname-webpack-plugin\\":\\"^1.0.3\\",\\"copy-webpack-plugin\\":\\"^5.1.1\\",\\"create-file-webpack\\":\\"^1.0.2\\",\\"cross-env\\":\\"^5.0.1\\",\\"cross-spawn\\":\\"^5.0.1\\",\\"eslint\\":\\"^6.8.0\\",\\"eslint-config-prettier\\":\\"^4.2.0\\",\\"gh-pages\\":\\"^2.0.1\\",\\"husky\\":\\"^4.2.3\\",\\"karma\\":\\"^6.1.1\\",\\"karma-chrome-launcher\\":\\"^3.1.0\\",\\"karma-firefox-launcher\\":\\"^1.3.0\\",\\"karma-mocha\\":\\"^2.0.1\\",\\"karma-spec-reporter\\":\\"0.0.32\\",\\"karma-webpack\\":\\"^4.0.2\\",\\"lint-staged\\":\\"^10.0.8\\",\\"mocha\\":\\"^10.2.0\\",\\"postcss-import\\":\\"^15.1.0\\",\\"postcss-loader\\":\\"^7.3.3\\",\\"postcss-url\\":\\"^10.1.3\\",\\"prettier\\":\\"1.17.0\\",\\"raw-loader\\":\\"^1.0.0\\",\\"rename-output-webpack-plugin\\":\\"^1.0.1\\",\\"uglify-es\\":\\"github:mishoo/UglifyJS2#harmony\\",\\"uglify-js\\":\\"^2.8.29\\",\\"url-loader\\":\\"^1.1.2\\",\\"webpack\\":\\"^4.42.0\\",\\"webpack-bundle-analyzer\\":\\"^4.7.0\\",\\"webpack-cli\\":\\"^3.3.6\\",\\"webpack-dev-server\\":\\"^3.1.1\\",\\"worker-loader\\":\\"^2.0.0\\"},\\"eslintConfig\\":{\\"root\\":true,\\"env\\":{\\"browser\\":true,\\"node\\":true,\\"es6\\":true},\\"extends\\":[\\"eslint:recommended\\"],\\"rules\\":{\\"no-console\\":\\"off\\",\\"no-debugger\\":\\"off\\",\\"no-empty\\":[\\"error\\",{\\"allowEmptyCatch\\":true}]},\\"parserOptions\\":{\\"parser\\":\\"babel-eslint\\",\\"ecmaVersion\\":2017,\\"sourceType\\":\\"module\\",\\"ecmaFeatures\\":{\\"modules\\":true}}},\\"prettier\\":{\\"trailingComma\\":\\"es5\\"},\\"postcss\\":{\\"plugins\\":{\\"autoprefixer\\":{}}},\\"browserslist\\":[\\"> 1%\\",\\"last 2 versions\\",\\"not ie <= 8\\"],\\"husky\\":{\\"hooks\\":{\\"pre-commit\\":\\"lint-staged\\"}},\\"lint-staged\\":{\\"{src,tests}/**/**}\\":\\"prettier --write\\"}}");

//# sourceURL=webpack://%5Bname%5D/./package.json?`)},"./src/api.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ajv", function() { return ajv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIGURABLE_FIELDS", function() { return CONFIGURABLE_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLUGIN_CONFIG_FIELDS", function() { return PLUGIN_CONFIG_FIELDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackends", function() { return getBackends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackendByType", function() { return getBackendByType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upgradePluginAPI", function() { return upgradePluginAPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLUGIN_SCHEMA", function() { return PLUGIN_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BACKEND_SCHEMA", function() { return BACKEND_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JOY_SCHEMA", function() { return JOY_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WINDOW_SCHEMA", function() { return WINDOW_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OP_SCHEMA", function() { return OP_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENGINE_FACTORY_SCHEMA", function() { return ENGINE_FACTORY_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENGINE_SCHEMA", function() { return ENGINE_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILE_MANAGER_SCHEMA", function() { return FILE_MANAGER_SCHEMA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONFIG_SCHEMA", function() { return CONFIG_SCHEMA; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceSpec.js */ "./src/serviceSpec.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ajv */ "./node_modules/ajv/lib/ajv.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_2__);



const ajv = new ajv__WEBPACK_IMPORTED_MODULE_2___default.a();
ajv.addKeyword("file", {
  compile: function (config) {
    if (config && !config.mime && !config.ext && !(typeof config === "string")) throw new Error("Invalid config for keyword: file");

    if (config && config.maxSize) {
      if (typeof config.maxSize !== "number") throw new Error("maxSize must be a number");
    }

    if (config && config.minSize) {
      if (typeof config.minSize !== "number") throw new Error("minSize must be a number");
    }

    if (config && config.size) {
      if (typeof config.size !== "number" && !Array.isArray(config.size)) throw new Error("size must be a number");
    }

    return function (data) {
      if (!(data instanceof File)) return false;
      if (!config) return true;

      for (let k in config) {
        if (k === "mime") {
          const mime = config[k];
          let _ok = false;

          if (typeof mime === "string") {
            _ok = data.type.match(mime);
          } else if (Array.isArray(mime)) {
            for (let m of mime) {
              if (data.type.match(m)) {
                _ok = true;
              }
            }
          }

          if (!_ok) return false;
        }

        if (k === "ext") {
          const ext = config[k];
          let _ok = false;

          if (typeof ext === "string") {
            _ok = data.name.endsWith(ext);
          } else if (Array.isArray(ext)) {
            for (let e of ext) {
              if (data.name.endsWith(e)) {
                _ok = true;
              }
            }
          }

          if (!_ok) return false;
        }

        if (k === "maxSize") {
          if (data.size > config[k]) return false;
        }

        if (k === "minSize") {
          if (data.size < config[k]) return false;
        }

        if (k === "size") {
          if (Array.isArray(config[k]) && !config[k].includes(data.size)) return false;
          if (data.size !== config[k]) return false;
        }
      }

      return true;
    };
  }
});
const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;
const _typedarray2dtype = {
  Int8Array: "int8",
  Int16Array: "int16",
  Int32Array: "int32",
  Uint8Array: "uint8",
  Uint16Array: "uint16",
  Uint32Array: "uint32",
  Float32Array: "float32",
  Float64Array: "float64",
  Array: "array"
};

const _dtypes = Object.values(_typedarray2dtype);

ajv.addKeyword("ndarray", {
  compile: function (config) {
    if (config && config.ndim) {
      if (typeof config.ndim !== "number" && !Array.isArray(config.ndim)) {
        throw new Error("ndim must be a number");
      }
    }

    if (config && config.shape) {
      if (!Array.isArray(config.shape)) {
        throw new Error("shape must be an array");
      }

      if (config.ndim) {
        if (typeof config.ndim !== "number" || config.shape.length !== config.ndim) throw new Error("mismatch between shape and ndim");
      }
    }

    if (config && config.dtype) {
      if (typeof config.dtype !== "string" && !Array.isArray(config.dtype)) throw new Error("Invalid dtype format");
      let dtypes;
      if (typeof config.dtype === "string") dtypes = [config.dtype];else dtypes = config.dtype;

      for (let dt of dtypes) {
        if (typeof dt !== "string" || !_dtypes.includes(dt)) {
          throw new Error("Invalid dtype: " + dt + ", valid types: " + _dtypes.join(","));
        }
      }
    }

    return function (data) {
      const isndarray = data._rtype === "ndarray" && data._rvalue && data._rvalue instanceof ArrayBufferView && data._rshape && Array.isArray(data._rshape) && data._rdtype && _dtypes.includes(data._rdtype);

      if (!isndarray) return false;
      if (!config) return true;

      for (let k in config) {
        if (k === "shape") {
          const shape = config[k];
          if (data._rshape.length !== shape.length) return false;

          for (let i = 0; i < data._rshape.length; i++) {
            if (typeof shape[i] === "number" && data._rshape[i] !== shape[i]) {
              return false;
            }
          }
        }

        if (k === "dtype") {
          const dtype = config[k];
          let _ok = false;

          if (typeof dtype === "string") {
            _ok = data._rdtype === config[k];
          } else if (Array.isArray(dtype)) {
            _ok = dtype.includes(data._rdtype);
          }

          if (!_ok) return false;
        }

        if (k === "ndim") {
          const ndim = config[k];
          let _ok = false;

          if (typeof ndim === "number") {
            _ok = data._rshape.length === ndim;
          } else if (Array.isArray(ndim)) {
            _ok = ndim.includes(data._rshape.length);
          }

          if (!_ok) return false;
        }
      }

      return true;
    };
  }
});
ajv.addKeyword("instanceof", {
  compile: function (Class) {
    return function (data) {
      if (Array.isArray(Class)) {
        let match = false;

        for (let c of Class) {
          if (data instanceof c) {
            match = true;
            break;
          }
        }

        return match;
      } else {
        return data instanceof Class;
      }
    };
  }
});
const CONFIGURABLE_FIELDS = ["env", "requirements", "dependencies", "icon", "ui", "type", "flags", "labels", "cover", "base_frame", "base_worker", "passive"];
const PLUGIN_CONFIG_FIELDS = CONFIGURABLE_FIELDS.concat(["name", "type", "tags", "version", "api_version", "defaults", "inputs", "outputs", "permissions"]);
const _backends = {
  "web-worker": {
    type: "internal",
    name: "Web Worker",
    lang: "javascript"
  },
  iframe: {
    type: "internal",
    name: "IFrame",
    lang: "javascript",
    icon: ""
  },
  window: {
    type: "internal",
    name: "Window",
    lang: "javascript"
  },
  "rpc-window": {
    type: "external",
    name: "RPC Window",
    lang: "*",
    icon: ""
  },
  "rpc-worker": {
    type: "external",
    name: "RPC Worker",
    lang: "*",
    icon: ""
  },
  collection: {
    type: "-",
    name: "Collection",
    lang: "*",
    icon: ""
  }
};
function getBackends() {
  return _backends;
}
function getBackendByType(type) {
  return _backends[type];
}
function upgradePluginAPI(config) {
  if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["compareVersions"])(config.api_version, "<=", "0.1.1")) {
    config.type = config.type || config.mode;
    delete config.mode;

    if (config.type === "pyworker") {
      config.type = "native-python";
    } else if (config.type === "webworker") {
      config.type = "web-worker";
    } else if (config.type === "webpython") {
      config.type = "web-python";
    }
  }

  return config;
}
const PLUGIN_SCHEMA = ajv.compile({
  properties: {
    _id: {
      type: ["null", "string"]
    },
    name: {
      type: "string"
    },
    code: {
      type: "string"
    },
    lang: {
      type: ["null", "string"]
    },
    script: {
      type: ["null", "string"]
    }
  }
});
const BACKEND_SCHEMA = ajv.compile({
  properties: {
    type: {
      type: "string"
    },
    name: {
      type: "string"
    },
    lang: {
      type: "string"
    },
    icon: {
      type: ["null", "string"]
    },
    connection: {}
  }
});
const JOY_SCHEMA = ajv.compile({
  properties: {
    name: {
      type: "string"
    },
    type: {
      type: "string"
    },
    init: {
      type: ["null", "string", "array", "object"]
    }
  }
});
const WINDOW_SCHEMA = ajv.compile({
  properties: {
    name: {
      type: "string"
    },
    type: {
      type: "string"
    },
    config: {
      type: ["null", "object"]
    },
    data: {
      type: ["null", "number", "string", "array", "object"]
    },
    //attachments: {}
    panel: {
      type: ["null", "object"]
    }
  }
});
const OP_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["operator"]);
const ENGINE_FACTORY_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["engine-factory"]);
const ENGINE_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["engine"]);
const FILE_MANAGER_SCHEMA = ajv.compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_1__["serviceSpec"]["file-manager"]);
const CONFIG_SCHEMA = ajv.compile({
  properties: {
    allow_execution: {
      type: "boolean"
    },
    auth: {
      type: ["object", "null"]
    },
    api_version: {
      type: "string",
      maxLength: 32
    },
    cover: {
      type: ["string", "array"],
      maxLength: 1024
    },
    dedicated_thread: {
      type: "boolean"
    },
    description: {
      type: "string",
      maxLength: 256
    },
    flags: {
      type: "array",
      maxLength: 32
    },
    icon: {
      type: "string"
    },
    id: {
      type: "string",
      maxLength: 128
    },
    inputs: {
      type: ["object", "array"]
    },
    labels: {
      type: "array",
      maxLength: 32
    },
    lang: {
      type: "string",
      maxLength: 32
    },
    name: {
      type: "string",
      maxLength: 48
    },
    outputs: {
      type: ["object", "array"]
    },
    tags: {
      type: "array",
      maxLength: 32
    },
    type: {
      type: "string",
      enum: Object.keys(_backends)
    },
    ui: {
      type: "string",
      maxLength: 2048
    },
    version: {
      type: "string",
      maxLength: 32
    },
    docs: {
      type: ["string", "object"]
    }
  },
  required: ["name", "version", "description", "api_version", "id", "allow_execution"]
});

//# sourceURL=webpack://%5Bname%5D/./src/api.js?`)},"./src/connection.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicConnection", function() { return BasicConnection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerConnection", function() { return WebWorkerConnection; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");

const all_connections = {};
class BasicConnection extends _utils_js__WEBPACK_IMPORTED_MODULE_0__["MessageEmitter"] {
  constructor(sourceIframe) {
    super();
    this._event_handlers = {};
    this._disconnected = false;
    this.pluginConfig = {};
    this._frame = sourceIframe;
    this._access_token = null;
    this._refresh_token = null;
    this._peer_id = null;
    this._plugin_origin = null;
    this.on("initialized", data => {
      this.pluginConfig = data.config; // peer_id can only be set for once

      this._peer_id = data.peer_id;
      this._plugin_origin = data.origin || "*";
      all_connections[this._peer_id] = this;

      if (this._plugin_origin !== "*") {
        console.log(\`connection to the imjoy-rpc peer \${this._peer_id} is limited to origin \${this._plugin_origin}.\`);
      }

      if (!this._peer_id) {
        throw new Error("Please provide a peer_id for the connection.");
      }

      if (this.pluginConfig.auth) {
        if (this._plugin_origin === "*") {
          console.error("Refuse to transmit the token without an explicit origin, there is a security risk that you may leak the credential to website from other origin. Please specify the \`origin\` explicitly.");
          this._access_token = null;
          this._refresh_token = null;
        }

        if (this.pluginConfig.auth.type !== "jwt") {
          console.error("Unsupported authentication type: " + this.pluginConfig.auth.type);
        } else {
          this._expires_in = this.pluginConfig.auth.expires_in;
          this._access_token = this.pluginConfig.auth.access_token;
          this._refresh_token = this.pluginConfig.auth.refresh_token;
        }
      }
    });
  }

  connect() {
    const messageHandler = e => {
      if (this._frame.contentWindow && e.source === this._frame.contentWindow) {
        const target_id = e.data.target_id;

        if (target_id && this._peer_id && target_id !== this._peer_id) {
          const conn = all_connections[target_id];
          if (conn) conn._fire(e.data.type, e.data);else console.warn(\`connection with target_id \${target_id} not found, discarding data: \`, e.data);
        } else {
          this._fire(e.data.type, e.data);
        }
      }
    };

    this._messageHandler = messageHandler.bind(this);
    window.addEventListener("message", this._messageHandler);

    this._fire("connected");
  }

  execute(code) {
    return new Promise((resolve, reject) => {
      this.once("executed", result => {
        if (result.error) {
          reject(new Error(result.error));
        } else {
          resolve();
        }
      });

      if (this.pluginConfig.allow_execution) {
        this.emit({
          type: "execute",
          code: code
        });
      } else {
        reject("Connection does not allow execution");
      }
    });
  }
  /**
   * Sends a message to the plugin site
   *
   * @param {Object} data to send
   */


  emit(data) {
    let transferables = undefined;

    if (data.__transferables__) {
      transferables = data.__transferables__;
      delete data.__transferables__;
    }

    if (this._access_token) {
      if (Date.now() >= this._expires_in * 1000) {
        //TODO: refresh access token
        throw new Error("Refresh token is not implemented.");
      }

      data.access_token = this._access_token;
    }

    data.peer_id = this._peer_id || data.peer_id;
    this._frame.contentWindow && this._frame.contentWindow.postMessage(data, this._plugin_origin || "*", transferables);
  }
  /**
   * Disconnects the plugin (= kills the frame)
   */


  disconnect(details) {
    if (this._messageHandler) window.removeEventListener("message", this._messageHandler);

    if (!this._disconnected) {
      this._disconnected = true;

      if (typeof this._frame !== "undefined") {
        this._frame.parentNode.removeChild(this._frame);
      } // otherwise farme is not yet created


      this._fire("disconnected", details);
    }

    if (this._peer_id && all_connections[this._peer_id]) delete all_connections[this._peer_id];
  }

}
class WebWorkerConnection extends BasicConnection {
  constructor(worker) {
    super();
    this._worker = worker;
  }

  connect() {
    // TODO: remove listener when disconnected
    this._worker.addEventListener("message", e => {
      const target_id = e.data.target_id;

      if (target_id && this._peer_id && target_id !== this._peer_id) {
        const conn = all_connections[target_id];
        if (conn) conn._fire(e.data.type, e.data);else console.warn(\`connection with target_id \${target_id} not found, discarding data: \`, e.data);
      } else {
        this._fire(e.data.type, e.data);
      }
    });

    this._fire("connected");
  }

  emit(data) {
    let transferables = undefined;

    if (data.__transferables__) {
      transferables = data.__transferables__;
      delete data.__transferables__;
    }

    if (this._access_token) {
      if (Date.now() >= this._expires_in * 1000) {
        //TODO: refresh access token
        throw new Error("Refresh token is not implemented.");
      }

      data.access_token = this._access_token;
    }

    data.peer_id = this._peer_id || data.peer_id;

    this._worker.postMessage(data, transferables);
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/connection.js?`)},"./src/engineManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EngineManager", function() { return EngineManager; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _evilEngine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./evilEngine.js */ "./src/evilEngine.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api.js */ "./src/api.js");



class EngineManager {
  constructor({
    event_bus = null,
    config_db = null,
    client_id = null,
    engine_selector = null
  }) {
    this.event_bus = event_bus;
    this.config_db = config_db;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.event_bus);
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.config_db, "config database is not available");
    this.client_id = client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    this.engines = [];
    this.engine_factories = [];
    this.pm = null;
    this.engine_selector = engine_selector;
  }

  setPluginManager(pm) {
    this.pm = pm;
  }

  async init() {
    this.register(_evilEngine_js__WEBPACK_IMPORTED_MODULE_1__["evil_engine"]);
    this.event_bus.on("register", async ({
      plugin,
      config
    }) => {
      try {
        if (config.type === "engine-factory") {
          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(plugin.config.flags && plugin.config.flags.indexOf("engine-factory") >= 0, "Please add \`engine-factory\` to \`config.flags\` before registering an engine factory.");

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_FACTORY_SCHEMA"])(config)) {
            const error = _api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_FACTORY_SCHEMA"].errors;
            console.error("Error occured registering engine factory", config, error);
            throw error;
          }

          this.registerFactory(config);
          plugin.on("close", () => {
            this.unregisterFactory(config);
          });
        } else if (config.type === "engine") {
          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(plugin.config.flags && plugin.config.flags.indexOf("engine") >= 0, "Please add \`engine\` to \`config.flags\` before registering an engine.");

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_SCHEMA"])(config)) {
            const error = _api_js__WEBPACK_IMPORTED_MODULE_2__["ENGINE_SCHEMA"].errors;
            console.error("Error occured registering engine ", config, error);
            throw error;
          }

          await this.register(config);
          plugin.on("close", () => {
            this.unregister(config);
          });
        }
      } catch (e) {
        this.pm.unregister(plugin, config);
        throw e;
      }
    });
    this.event_bus.on("unregister", async ({
      config
    }) => {
      if (config.type === "engine") {
        this.unregister(config);
      } else if (config.type === "engine-factory") {
        this.unregisterFactory(config);
      }
    });
  }

  matchEngineByType(pluginType) {
    return this.engines.filter(engine => {
      return engine.pluginType === pluginType;
    });
  }

  async findEngine(plugin_config) {
    if (this.engine_selector) return await this.engine_selector(plugin_config, this.engines);
    const egs = this.engines.filter(engine => {
      return plugin_config.type && engine.pluginType === plugin_config.type;
    });

    if (!egs || egs.length <= 0) {
      return null;
    }

    if (plugin_config.engine_mode === "auto") {
      const matched = egs.filter(eg => {
        return eg.connected;
      });

      if (matched.length <= 0) {
        // let's try to connect the first one
        try {
          const engine = egs[0];
          await engine.connect();
          engine.connected = true;
          return engine;
        } catch (e) {
          console.error("Failed to connect", e);
        }

        return null;
      }

      return matched[matched.length - 1];
    }

    return egs.filter(eg => {
      return eg.name === plugin_config.engine_mode;
    })[0];
  }

  getEngineByUrl(url) {
    for (let e of this.engines) {
      if (e.url === url) {
        return e;
      }
    }

    return null;
  }

  getEngineByName(name) {
    for (let e of this.engines) {
      if (e.name === name) {
        return e;
      }
    }

    return null;
  }

  async register(engine_) {
    const engine = Object.assign({}, engine_); // backup the engine api

    engine.api = engine_;

    if (engine_ && engine_ === _evilEngine_js__WEBPACK_IMPORTED_MODULE_1__["evil_engine"]) {
      // make an exception for localhost debugging
      if (window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost") {
        engine._is_evil = false;
      } else {
        engine._is_evil = true;
      }
    } else {
      engine._is_evil = false;
    } // make sure the name is unique


    for (let i = 0; i < this.engines.length; i++) {
      if (engine.name && this.engines[i].name === engine.name) {
        try {
          this.unregister(this.engines[i]);
        } catch (e) {
          console.error(e);
        }
      }
    } // make sure the url is unique


    for (let i = 0; i < this.engines.length; i++) {
      if (engine.url && this.engines[i].url === engine.url) {
        try {
          this.unregister(this.engines[i]);
        } catch (e) {
          console.error(e);
        }
      }
    }

    engine.connected = false;
    engine.engine_status = engine.engine_status || {};

    if (engine.getEngineConfig) {
      Promise.resolve(engine.getEngineConfig()).then(engine_config => {
        engine.engine_config = engine_config;
      });
    }

    const update_connectivity = () => {
      if (engine.connected) {
        this.event_bus.emit("engine_connected", engine);
      } else {
        this.event_bus.emit("engine_disconnected", engine);
      }
    };

    const check_connectivity = async () => {
      const live = await engine.heartbeat();

      if (!engine.connected && live) {
        engine.connected = true;
        update_connectivity();
      } else if (engine.connected && !live) {
        engine.connected = false;
        update_connectivity();

        for (let p of engine._plugins) {
          p.terminate();
        } // clearInterval(timerId);

      } else {
        engine.connected = live;
      }
    };

    engine._plugins = [];

    engine.registerPlugin = p => {
      engine._plugins.push(p);
    };

    this.engines.push(engine);

    if (!engine.lazy_connection) {
      await engine.connect();
      engine.connected = true;
    }

    update_connectivity();

    if (engine.heartbeat) {
      await check_connectivity();
      engine.heartbeat_timer = setInterval(check_connectivity, 5000);
    }
  }

  async unregister(engine) {
    const url = engine.url;
    engine = this.getEngineByUrl(url);
    if (!engine) return false;
    const index = this.engines.indexOf(engine);

    for (let p of engine._plugins) {
      p.terminate();
    }

    if (index > -1) {
      this.engines.splice(index, 1);
    }

    if (engine.heartbeat_timer) clearInterval(engine.heartbeat_timer);
    await engine.disconnect();
    engine.connected = false;
    this.event_bus.emit("engine_disconnected", engine);
    return true;
  }

  registerFactory(factory_) {
    const factory = Object.assign({}, factory_); //backup the factory api

    factory.api = factory_;

    for (let i = 0; i < this.engine_factories.length; i++) {
      if (this.engine_factories[i].name === factory.name) {
        this.engine_factories.splice(i, 1);
        break;
      }
    }

    this.engine_factories.push(factory);
  }

  unregisterFactory(factory) {
    factory = this.getFactory(factory.name);
    if (!factory) return false;
    const index = this.engine_factories.indexOf(factory);

    if (index > -1) {
      this.engine_factories.splice(index, 1);
    }

    return true;
  }

  getFactory(name) {
    for (let e of this.engine_factories) {
      if (e.name === name) {
        return e;
      }
    }

    return null;
  }

  destroy() {
    for (let e of this.engines) {
      this.unregister(e);
    }
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/engineManager.js?`)},"./src/evilEngine.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evil_engine", function() { return evil_engine; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);



async function _importScript(url, scope) {
  const response = await axios__WEBPACK_IMPORTED_MODULE_1___default.a.get(url);

  if (response && response.status == 200 && response.data) {
    const code = response.data; // Avoid loading the script as amd module (requirejs)

    scope["define"] = null;
    evalInScope(code, scope);
  } else {
    throw "Faild to fetch code from " + url;
  }
}

function evalInScope(code, scope) {
  var keys = Object.keys(scope);
  var values = keys.map(function (key) {
    return scope[key];
  });
  var f = Function(keys.join(", "), code); // Note that at this point you could cache the function f.

  return f.apply(undefined, values);
} // evaluates the provided string


var execute = async function (code, api_interface) {
  if (code.type == "requirements") {
    if (code.requirements && (Array.isArray(code.requirements) || typeof code.requirements === "string")) {
      try {
        code.requirements = typeof code.requirements === "string" ? [code.requirements] : code.requirements;

        if (Array.isArray(code.requirements)) {
          for (var i = 0; i < code.requirements.length; i++) {
            if (code.requirements[i].toLowerCase().endsWith(".js") || code.requirements[i].startsWith("js:")) {
              if (code.requirements[i].startsWith("js:")) {
                code.requirements[i] = code.requirements[i].slice(3);
              }

              await _importScript(code.requirements[i], {
                api: api_interface
              });
            } else if (code.requirements[i].startsWith("http")) {
              await _importScript(code.requirements[i], {
                api: api_interface
              });
            } else if (code.requirements[i].startsWith("cache:")) {//ignore cache
            } else {
              console.log("Unprocessed requirements url: " + code.requirements[i]);
            }
          }
        } else {
          throw "Unsupported requirements definition";
        }
      } catch (e) {
        throw \`Failed to import required scripts \${code.requirements}: \${e}\`;
      }
    }
  } else if (code.type === "script") {
    if (code.src) {
      var script_node = document.createElement("script");
      script_node.setAttribute("type", code.attrs.type);
      script_node.setAttribute("src", code.src);
      document.head.appendChild(script_node);
    } else {
      if (code.content && (!code.attrs.type || code.attrs.type === "text/javascript")) {
        // document.addEventListener("DOMContentLoaded", function(){
        evalInScope(code.content, {
          api: api_interface
        }); // });
      } else {
        var node = document.createElement("script");
        node.setAttribute("type", code.attrs.type);
        node.appendChild(document.createTextNode(code.content));
        document.body.appendChild(node);
      }
    }
  } else {
    throw "unsupported code type.";
  }
};

function promisify_functions(obj) {
  for (let k in obj) {
    if (typeof obj[k] === "function") {
      // make sure it returns a promise
      const func = obj[k];

      if (func.constructor.name !== "AsyncFunction") {
        obj[k] = function (...args) {
          return Promise.resolve(func(...args));
        };
      }
    }
  }
}

async function cacheRequirements(requirements) {
  if (requirements && requirements.length > 0) {
    for (let req of requirements) {
      //remove prefix
      if (req.startsWith("js:")) req = req.slice(3);
      if (req.startsWith("css:")) req = req.slice(4);
      if (req.startsWith("cache:")) req = req.slice(6);
      if (!req.startsWith("http")) continue;

      try {
        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["cacheUrlInServiceWorker"])(req);
      } catch (e) {
        console.error(e);
      }
    }
  }
}

const evil_engine = {
  type: "engine",
  pluginType: "evil",
  icon: "",
  name: "imjoy engine",
  url: "https://imjoy.io",
  config: {},
  hide: true,

  connect() {
    this._disconnected = false;
    return true;
  },

  disconnect() {
    this._disconnected = true;
  },

  async startPlugin(config, api_interface) {
    if (this._disconnected) throw "engine is disconnected."; // eslint-disable-next-line no-async-promise-executor

    return new Promise(async (resolve, reject) => {
      const export_api = remote_api => {
        console.log(\`plugin \${config.name} (id=\${config.id}) initialized.\`, Object.keys(remote_api));
        promisify_functions(remote_api);
        resolve(remote_api);
      };

      api_interface = Object.assign({}, api_interface);
      api_interface.export = export_api;
      const raw_register = api_interface.register;

      api_interface.register = config => {
        promisify_functions(config);
        return raw_register(config);
      };

      const raw_on = api_interface.on;

      api_interface.on = (name, cb) => {
        const promise_cb = function (...args) {
          return Promise.resolve(cb(...args));
        };

        return raw_on(name, promise_cb);
      };

      promisify_functions(api_interface);

      try {
        await execute({
          type: "requirements",
          lang: config.lang,
          requirements: config.requirements,
          env: config.env
        }, api_interface);

        for (let i = 0; i < config.scripts.length; i++) {
          await execute({
            type: "script",
            content: config.scripts[i].content,
            lang: config.scripts[i].attrs.lang,
            attrs: config.scripts[i].attrs,
            src: config.scripts[i].attrs.src
          }, api_interface);
        }

        await cacheRequirements(config.requirements);
      } catch (e) {
        reject(e);
      }
    });
  },

  heartbeat: null
};

//# sourceURL=webpack://%5Bname%5D/./src/evilEngine.js?`)},"./src/fileManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileManager", function() { return FileManager; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.js */ "./src/api.js");


class FileManager {
  constructor({
    event_bus = null,
    client_id = null
  }) {
    this.event_bus = event_bus;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.event_bus);
    this.client_id = client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    this.fileManagers = [];
    this.pm = null;
  }

  setPluginManager(pm) {
    this.pm = pm;
  }

  async init() {
    this.event_bus.on("register", async ({
      plugin,
      config
    }) => {
      if (config.type === "file-manager") {
        try {
          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(plugin.config.flags && plugin.config.flags.indexOf("file-manager") >= 0, "Please add \`file-manager\` to \`config.flags\` before registering a file manager.");

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["FILE_MANAGER_SCHEMA"])(config)) {
            const error = _api_js__WEBPACK_IMPORTED_MODULE_1__["FILE_MANAGER_SCHEMA"].errors;
            console.error("Error occured registering file manager", config, error);
            throw error;
          }

          await this.register(config);
          plugin.on("close", () => {
            this.unregister(config);
          });
        } catch (e) {
          this.pm.unregister(config);
          throw e;
        }
      }
    });
    this.event_bus.on("register", async ({
      config
    }) => {
      if (config.type === "file-manager") {
        this.unregister(config);
      }
    });
  }

  getFileManagerByName(name) {
    for (let fm of this.fileManagers) {
      if (fm.name === name) {
        return fm;
      }
    }

    return null;
  }

  getFileManagerByUrl(url) {
    for (let fm of this.fileManagers) {
      if (fm.url === url) {
        return fm;
      }
    }

    return null;
  }

  async register(manager_) {
    const manager = Object.assign({}, manager_); //backup the manager api

    manager.api = manager_;

    for (let i = 0; i < this.fileManagers.length; i++) {
      if (this.fileManagers[i].name === manager.name) {
        this.fileManagers.splice(i, 1);
        break;
      }
    }

    manager.connected = false;

    const check_connectivity = async () => {
      manager.connected = await manager.heartbeat();
    };

    await check_connectivity();
    manager.heart_beat_timer = setInterval(check_connectivity, 10000);
    this.fileManagers.push(manager);
  }

  unregister(manager) {
    manager = this.getFileManagerByUrl(manager.url);
    if (!manager) return false;
    const index = this.fileManagers.indexOf(manager);

    if (index > -1) {
      this.fileManagers.splice(index, 1);
    }

    if (manager.heart_beat_timer) {
      clearInterval(manager.heart_beat_timer);
    }

    return true;
  }

  destroy() {
    for (let e of this.fileManagers) {
      e.destroy();
    }
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/fileManager.js?`)},"./src/imjoyBasicApp.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "injectScript", function() { return injectScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyBasicApp", function() { return loadImJoyBasicApp; });
/* harmony import */ var _imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imjoyBasicApp.template.css */ "./src/imjoyBasicApp.template.css");
/* harmony import */ var _imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imjoyBasicApp.template.html */ "./src/imjoyBasicApp.template.html");
/* harmony import */ var _imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imjoyBasicAppMenu.template.html */ "./src/imjoyBasicAppMenu.template.html");
/* harmony import */ var _imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./imjoyBasicAppWindows.template.html */ "./src/imjoyBasicAppWindows.template.html");
/* harmony import */ var _imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3__);




function injectScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;
    script.addEventListener("load", resolve);
    script.addEventListener("error", () => {
      document.head.removeChild(script);
      reject("Error loading script: " + src);
    });
    script.addEventListener("abort", () => reject("Script loading aborted."));
    document.head.appendChild(script);
  });
}

function getUrlParameter(name) {
  name = name.replace(/[\\[]/, "\\\\[").replace(/[\\]]/, "\\\\]");
  var regex = new RegExp("[\\\\?&]" + name + "=([^&#]*)");
  var results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\\+/g, " "));
}

function loadCss(url) {
  const fileref = document.createElement("link");
  fileref.setAttribute("rel", "stylesheet");
  fileref.setAttribute("type", "text/css");
  fileref.setAttribute("href", url);
  document.getElementsByTagName("head")[0].appendChild(fileref);
}

async function loadImJoyBasicApp(config) {
  await injectScript("https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js");
  await injectScript("https://imjoy-team.github.io/vue-js-modal/index.js");
  loadCss("https://imjoy-team.github.io/vue-js-modal/styles.css");
  await injectScript("https://cdn.jsdelivr.net/npm/@oeway/vue-window@2.4.1-a/lib/index.js");
  config = config || {};
  let app;
  const imjoy_api = {
    showDialog(plugin, cfg, extra_cfg) {
      extra_cfg = extra_cfg || {};
      extra_cfg.dialog = true;
      return imjoy.pm.createWindow(plugin, cfg, extra_cfg);
    },

    createWindow(plugin, cfg, extra_cfg) {
      extra_cfg = extra_cfg || {};
      if (!config.window_manager_container) extra_cfg.dialog = true;
      return imjoy.pm.createWindow(plugin, cfg, extra_cfg);
    },

    showSnackbar(plugin, msg, duration) {
      app.showSnackbar(msg, duration);
    },

    showMessage(plugin, msg) {
      app.showSnackbar(msg, 5);
    },

    showStatus(plugin, msg) {
      app.showSnackbar(msg, 5);
    },

    showProgress(plugin, progress) {
      progress = progress || 0;
      if (progress < 1) progress = progress * 100;
      app.progress = progress;
      app.$forceUpdate();
    }

  };

  if (config.imjoy_api) {
    for (let k of Object.keys(config.imjoy_api)) {
      imjoy_api[k] = config.imjoy_api[k];
    }
  }

  const imjoyCore = await loadImJoyCore(config);
  const imjoy = new imjoyCore.ImJoy({
    imjoy_api,
    expose_api: config.expose_api,
    client_id: config.client_id,
    default_base_frame: config.default_base_frame,
    default_rpc_base_url: config.default_rpc_base_url,
    debug: config.debug,
    flags: config.flags || [],
    engine_selector: config.engine_selector
  });
  await imjoy.start(config);
  console.log("ImJoy Core started successfully!");
  Vue.use(window["vue-js-modal"].default);
  Vue.use(window.VueWindow);
  let elem;

  if (config.main_container) {
    if (typeof config.main_container === "string") elem = document.getElementById(config.main_container);else elem = config.main_container;
  } else {
    elem = document.createElement("div");
    document.body.appendChild(elem);
  }

  elem.style.visibility = "hidden";
  elem.innerHTML = _imjoyBasicApp_template_html__WEBPACK_IMPORTED_MODULE_1___default.a;
  document.head.insertAdjacentHTML("beforeend", \`<style>\${_imjoyBasicApp_template_css__WEBPACK_IMPORTED_MODULE_0___default.a}</style>\`);
  let windowManager;

  if (config.window_manager_container) {
    let windowsElem;
    if (typeof config.window_manager_container === "string") windowsElem = document.getElementById(config.window_manager_container);else windowsElem = config.window_manager_container;
    windowsElem.innerHTML = _imjoyBasicAppWindows_template_html__WEBPACK_IMPORTED_MODULE_3___default.a;
    windowManager = new Vue({
      el: windowsElem,
      data: {
        type: config.window_manager_type || "standard",
        windowSizePosChanging: false,
        windowStyle: config.window_style || {},
        showEmpty: config.show_empty_window || false,
        showWindowTitle: config.show_window_title || false,
        windows: [],
        activeWindow: null
      },
      watch: {
        windowSizePosChanging: function (newVal) {
          app.$emit("window-size-pos-changing", newVal);
        }
      },
      methods: {
        closeWindow(w) {
          this.windowSizePosChanging = false;
          w.hidden = true;
          this.$forceUpdate();
          w.close();
        }

      }
    });
  }

  let menuManager;

  if (config.menu_container) {
    let menuElem;
    if (typeof config.menu_container === "string") menuElem = document.getElementById(config.menu_container);else menuElem = config.menu_container;
    menuElem.innerHTML = _imjoyBasicAppMenu_template_html__WEBPACK_IMPORTED_MODULE_2___default.a;
    menuElem.style.minHeight = "30px";
    menuManager = new Vue({
      el: menuElem,
      data: {
        menuPos: config.menu_pos || "right",
        menuStyle: config.menu_style || {
          "z-index": 999
        },
        activeWindow: null,
        closeWindow: null,
        showAboutImJoy: null,
        extraMenuItems: [],
        loadedPlugins: [],
        allWindows: [],
        showContent: true
      },

      mounted() {
        this.menuStyle = this.menuStyle || {};
        this.menuStyle.float = this.menuPos === "left" ? "left" : "right";
      },

      methods: {
        menuClicked() {
          // force closing the menu for touch screen devices
          this.showContent = false;
          this.$forceUpdate();
          setTimeout(() => {
            this.showContent = true;
            this.$forceUpdate();
          }, 0);
        }

      }
    });
  }

  app = new Vue({
    el: elem,
    data: {
      dialogWindows: [],
      selectedDialogWindow: null,
      selectedWindowsStack: [],
      selectedRegularWindow: null,
      fullscreen: false,
      loading: false,
      snackBarContent: false,
      snackBarTimer: null,
      progress: 0,
      loadedPlugins: [],
      allWindows: [],
      extraMenuItems: [],
      showProgressBar: config.show_progress_bar,
      showLoaderCallback: config.show_loader,
      showWindows: config.show_windows
    },

    mounted() {
      this.$el.style.visibility = "visible";
      imjoy.event_bus.on("close_window", w => {
        this.closeWindow(w);
        this.$forceUpdate();
      });
      imjoy.event_bus.on("add_window", w => {
        this.allWindows.push(w);
        this.addWindow(w);
      });
      this.imjoy = imjoy;

      if (config.process_url_query) {
        this.processURLQuery();
      }

      if (menuManager) {
        menuManager.closeWindow = w => {
          this.closeWindow(w);
        };

        if (!config.hide_about_imjoy) {
          menuManager.showAboutImJoy = () => {
            imjoy.api.showDialog({
              src: "https://imjoy.io/docs/",
              passive: true
            });
          };
        }
      }
    },

    computed: {
      regularWindows: function () {
        return this.allWindows.filter(w => !this.dialogWindows.includes(w) && !w.inline);
      }
    },
    watch: {
      regularWindows: function (newVal) {
        if (windowManager) {
          windowManager.windows = newVal;
          windowManager.$forceUpdate();
        }
      },
      selectedRegularWindow: function (newVal) {
        if (windowManager) {
          windowManager.activeWindow = newVal;
          windowManager.$forceUpdate();
        }

        if (menuManager && config.window_manager_type === "simple") {
          menuManager.activeWindow = newVal;
          menuManager.$forceUpdate();
        }
      },
      extraMenuItems: function (newVal) {
        if (menuManager) {
          menuManager.extraMenuItems = newVal;
          menuManager.$forceUpdate();
        }
      },
      allWindows: function (newVal) {
        if (menuManager) {
          menuManager.allWindows = newVal;
          menuManager.$forceUpdate();
        }
      },
      loadedPlugins: function (newVal) {
        if (menuManager) {
          menuManager.loadedPlugins = newVal;
          menuManager.$forceUpdate();
        }
      }
    },
    methods: {
      async processURLQuery() {
        const engine = getUrlParameter("engine");
        const p = getUrlParameter("plugin") || getUrlParameter("p");
        const binder = getUrlParameter("binder");

        if (engine) {
          const token = getUrlParameter("token");
          const name = getUrlParameter("name");
          await this.setupPluginEngine(engine, token, name);
        }

        if (binder) {
          const name = getUrlParameter("name");
          const spec = getUrlParameter("spec");
          await this.setupBinderEngine(binder, spec, name);
        }

        if (p) {
          this.loadPlugin(p).then(plugin => {
            let config = {},
                data = {},
                tmp;
            tmp = getUrlParameter("data");
            if (tmp) data = JSON.parse(tmp);
            tmp = getUrlParameter("config");
            if (tmp) config = JSON.parse(tmp);
            this.runPlugin(plugin, config, data);
          });
        }
      },

      async runPlugin(plugin, config, data) {
        if (!config && plugin.config.ui && plugin.config.ui.indexOf("{") > -1) {
          config = await imjoy.pm.imjoy_api.showDialog(plugin, plugin.config);
        }

        data = data || {};
        return await plugin.api.run({
          config: config,
          data: data
        });
      },

      async setupPluginEngine(engine, token, name) {
        try {
          console.log("Loading Jupyter-Engine-Manager from Gist...");

          if (!imjoy.em.getFactory("Jupyter-Engine")) {
            await imjoy.pm.reloadPluginRecursively({
              uri: "https://imjoy-team.github.io/jupyter-engine-manager/Jupyter-Engine-Manager.imjoy.html"
            });
            console.log("Jupyter-Engine-Manager loaded.");
            await imjoy.em.unregister("https://mybinder.org");
          }

          const factory = imjoy.em.getFactory("Jupyter-Engine");
          await factory.addEngine({
            name: name,
            url: engine,
            nbUrl: engine + "?token=" + token
          });
          console.log("plugin engine added:", engine);
        } catch (e) {
          console.error(e);
          alert(\`Failed to connect to the engine: \${e}\`);
        }
      },

      async setupBinderEngine(url, spec, name) {
        try {
          console.log("Loading Jupyter-Engine-Manager from Gist...");

          if (!imjoy.em.getFactory("MyBinder-Engine")) {
            await imjoy.pm.reloadPluginRecursively({
              uri: "https://imjoy-team.github.io/jupyter-engine-manager/Jupyter-Engine-Manager.imjoy.html"
            });
            console.log("Jupyter-Engine-Manager loaded.");
            await imjoy.em.unregister("https://mybinder.org");
          }

          const factory = imjoy.em.getFactory("MyBinder-Engine");
          await factory.addEngine({
            name,
            spec,
            url
          });
          console.log("Binder engine added:", url);
        } catch (e) {
          console.error(e);
          alert(\`Failed to connect to the engine: \${e}\`);
        }
      },

      async loadPlugin(uri) {
        try {
          this.loading = true;
          const p = await imjoy.pm.reloadPluginRecursively({
            uri
          });
          this.loadedPlugins.push(p);
          this.showSnackbar(\`Plugin \${p.name} successfully loaded.\`);
          return p;
        } finally {
          this.loading = false;
        }
      },

      addMenuItem(config) {
        this.extraMenuItems.push(config);
        this.$forceUpdate();
      },

      removeMenuItem(label) {
        const item = this.extraMenuItems.filter(it => it.label === label)[0];
        const idx = this.extraMenuItems.indexOf(item);
        if (idx >= 0) this.extraMenuItems.splice(idx, 1);
      },

      showSnackbar(msg, duration) {
        if (this.snackBarTimer) clearTimeout(this.snackBarTimer);
        duration = duration || 3;
        this.snackBarContent = msg;
        this.$forceUpdate();
        this.snackBarTimer = setTimeout(() => {
          this.snackBarContent = null;
          this.snackBarTimer = null;
          this.$forceUpdate();
        }, duration * 1000);
      },

      showLoader(loading) {
        if (this.showLoaderCallback) {
          this.showLoaderCallback(loading);
        } else {
          this.loading = loading;
        }

        this.$forceUpdate();
      },

      addWindow(w) {
        w.api = w.api || {};
        const windowElm = document.getElementById(w.window_id);

        if (windowElm) {
          if (w.window_style) Object.assign(windowElm.style, w.window_style);
          w.inline = true;

          w.api.show = w.show = () => {
            windowElm.scrollIntoView();
          };

          return;
        }

        if (!w.dialog) {
          this.selectedRegularWindow = w;
          setTimeout(() => {
            if (w.fullscreen || w.standalone) {
              w.sizeState = "maximized";
            } else {
              w.sizeState = "normal";
            }

            this.$forceUpdate();
          }, 0);
          const self = this;

          w.api.show = w.show = () => {
            w.sizeState = "restore";
            self.selectedRegularWindow = w;
            self.$forceUpdate();
            imjoy.wm.selectWindow(w);
            w.api.emit("show");
          };
        } else {
          this.dialogWindows.push(w);

          if (this.selectedDialogWindow) {
            this.selectedWindowsStack.push(this.selectedDialogWindow);
          }

          this.selectedDialogWindow = w;
          if (w.fullscreen || w.standalone) this.fullscreen = true;else this.fullscreen = false;
          this.$modal.show("window-modal-dialog");
          this.$forceUpdate();

          w.api.show = w.show = () => {
            this.selectedDialogWindow = w;
            this.$modal.show("window-modal-dialog");
            imjoy.wm.selectWindow(w);
            w.api.emit("show");
          };

          w.api.hide = w.hide = () => {
            if (this.selectedDialogWindow === w) {
              this.$modal.hide("window-modal-dialog");
            }

            w.api.emit("hide");
          };

          setTimeout(() => {
            try {
              w.show();
            } catch (e) {
              console.error(e);
            }
          }, 500);
        }
      },

      showWindow(w) {
        if (w.fullscreen || w.standalone) this.fullscreen = true;else this.fullscreen = false;
        if (w) this.selectedDialogWindow = w;
        this.$modal.show("window-modal-dialog");
      },

      closeWindow(w) {
        let idx = this.dialogWindows.indexOf(w);
        if (idx >= 0) this.dialogWindows.splice(idx, 1);
        idx = this.allWindows.indexOf(w);
        if (idx >= 0) this.allWindows.splice(idx, 1);

        if (w === this.selectedDialogWindow) {
          this.selectedDialogWindow = this.selectedWindowsStack.pop();
        }

        if (!this.selectedDialogWindow) this.$modal.hide("window-modal-dialog");

        if (w === this.selectedRegularWindow) {
          if (this.regularWindows.length > 0) this.selectedRegularWindow = this.regularWindows[this.regularWindows.length - 1] || null;else this.selectedRegularWindow = null;
        }

        this.$forceUpdate();
      },

      minimizeWindow() {
        this.$modal.hide("window-modal-dialog");
      },

      maximizeWindow() {
        this.fullscreen = !this.fullscreen;
      }

    }
  });
  return app;
}

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicApp.js?`)},"./src/imjoyBasicApp.template.css":function(module,exports){eval(`module.exports = ".vm--modal {\\n  max-height: 100% !important;\\n  max-width: 100% !important;\\n}\\n\\n.imjoy-inline-window {\\n  width: 100%;\\n  height: 600px;\\n}\\n\\n.imjoy-progress-border > div {\\n  background-color: #448aff;\\n  height: 3px;\\n}\\n\\n.imjoy-progress-border {\\n  top: 0;\\n  left: 0;\\n  position: absolute;\\n  width: 100%;\\n  height: 3px;\\n}\\n\\n.imjoy-noselect {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n\\nbody {\\n  margin: 0px;\\n}\\n.imjoy-dialog-control {\\n  padding: 0px;\\n  line-height: 10px;\\n  height: 23px;\\n  width: 25px;\\n  border: 0px;\\n  font-size: 1rem;\\n  position: absolute;\\n  color: white;\\n  top: 1px;\\n}\\n\\n.imjoy-dialog-control:focus {\\n  outline: none;\\n}\\n\\n.imjoy-loader {\\n  position: fixed;\\n  top: 40%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  transform: -webkit-translate(-50%, -50%);\\n  transform: -moz-translate(-50%, -50%);\\n  transform: -ms-translate(-50%, -50%);\\n  border: 10px solid #f3f3f3;\\n  /* Light grey */\\n  border-top: 10px solid #448aff;\\n  /* Blue */\\n  border-radius: 50%;\\n  width: 40px;\\n  height: 40px;\\n  animation: spin 2s linear infinite;\\n}\\n\\n@keyframes spin {\\n  0% {\\n    transform: rotate(0deg);\\n  }\\n\\n  100% {\\n    transform: rotate(360deg);\\n  }\\n}\\n\\n/* The snackbar - position it at the bottom and in the middle of the screen */\\n.imjoy-snackbar {\\n  font-family: Arial, Helvetica, sans-serif;\\n  visibility: hidden;\\n  /* Hidden by default. Visible on click */\\n  min-width: 250px;\\n  /* Set a default minimum width */\\n  background-color: #333333c2;\\n  /* Black background color */\\n  color: #fff;\\n  /* White text color */\\n  text-align: center;\\n  /* Centered text */\\n  border-radius: 5px;\\n  /* Rounded borders */\\n  padding: 16px;\\n  /* Padding */\\n  position: fixed;\\n  /* Sit on top of the screen */\\n  z-index: 9999;\\n  /* Add a z-index if needed */\\n  left: 50%;\\n  /* Center the snackbar */\\n  transform: translate(-50%, 0);\\n  bottom: 20px;\\n  /* 20px from the bottom */\\n}\\n\\n.imjoy-window-title-bar {\\n  cursor: move;\\n  background-color: #448aff;\\n  color: white;\\n  text-align: center;\\n  height: 24px;\\n}\\n\\n.imjoy-window-title {\\n  text-align: center;\\n  font-family: Arial, Helvetica, sans-serif;\\n  font-size: 16px;\\n  line-height: 23px;\\n  margin: 0px;\\n}\\n\\n/* Show the snackbar when clicking on a button (class added with JavaScript) */\\n.imjoy-snackbar.show-snackbar {\\n  visibility: visible;\\n  /* Show the snackbar */\\n  /* Add animation: Take 0.5 seconds to fade in and out the snackbar.\\n  However, delay the fade out process for 2.5 seconds */\\n  -webkit-animation: imjoy-fadein 0.5s;\\n  animation: imjoy-fadein 0.5s;\\n}\\n\\n/* Animations to fade the snackbar in and out */\\n@-webkit-keyframes imjoy-fadein {\\n  from {\\n    bottom: 0;\\n    opacity: 0;\\n  }\\n\\n  to {\\n    bottom: 30px;\\n    opacity: 1;\\n  }\\n}\\n\\n@keyframes imjoy-fadein {\\n  from {\\n    bottom: 0;\\n    opacity: 0;\\n  }\\n\\n  to {\\n    bottom: 30px;\\n    opacity: 1;\\n  }\\n}\\n\\n.imjoy-dropdown-btn {\\n  padding: 4px;\\n  font-size: 16px;\\n  border: none;\\n  cursor: pointer;\\n}\\n\\n.imjoy-dropdown {\\n  position: relative;\\n  display: inline-block;\\n}\\n\\n.imjoy-dropdown-content {\\n  display: none;\\n  position: absolute;\\n  right: 0;\\n  background-color: #f9f9f9;\\n  min-width: 200px;\\n  box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);\\n  z-index: 1;\\n}\\n\\n.imjoy-dropdown-content a {\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: black;\\n  padding: 6px 10px;\\n  text-decoration: none;\\n  display: block;\\n}\\n\\n.imjoy-dropdown-content a:hover {\\n  background-color: #f1f1f1;\\n}\\n\\n.imjoy-dropdown:hover .imjoy-dropdown-content {\\n  display: block;\\n}\\n\\n.imjoy-window-container {\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.imjoy-windows {\\n  position: relative;\\n  min-height: 100px;\\n  height: calc(100% - 30px);\\n}\\n\\n.block-pointer-events {\\n  pointer-events: none;\\n}\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicApp.template.css?`)},"./src/imjoyBasicApp.template.html":function(module,exports){eval(`module.exports = "<div v-if=\\"showLoader\\" class=\\"imjoy-loader\\" v-show=\\"loading\\"></div>\\n<div v-if=\\"showProgressBar\\" class=\\"imjoy-progress-border\\" v-show=\\"progress\\">\\n  <div :style=\\"{width: progress+'%'}\\"></div>\\n</div>\\n<div\\n  v-show=\\"snackBarContent\\"\\n  :class=\\"{'show-snackbar': snackBarContent}\\"\\n  class=\\"imjoy-snackbar\\"\\n>\\n  {{snackBarContent}}\\n</div>\\n<modal\\n  name=\\"window-modal-dialog\\"\\n  height=\\"500px\\"\\n  style=\\"max-height: 100%; max-width: 100%\\"\\n  :fullscreen=\\"fullscreen\\"\\n  :resizable=\\"true\\"\\n  draggable=\\".imjoy-drag-handle\\"\\n  :scrollable=\\"true\\"\\n>\\n  <div\\n    v-if=\\"selectedDialogWindow\\"\\n    @dblclick=\\"maximizeWindow()\\"\\n    class=\\"imjoy-drag-handle imjoy-window-title-bar\\"\\n  >\\n    <span class=\\"imjoy-noselect imjoy-window-title\\"\\n      >{{ selectedDialogWindow.name}}</span\\n    >\\n    <button\\n      @click=\\"closeWindow(selectedDialogWindow)\\"\\n      class=\\"imjoy-noselect imjoy-dialog-control\\"\\n      style=\\"background:#ff0000c4;left:1px;\\"\\n    >\\n      x\\n    </button>\\n    <button\\n      @click=\\"minimizeWindow()\\"\\n      class=\\"imjoy-noselect imjoy-dialog-control\\"\\n      style=\\"background:#00cdff61;left:28px;\\"\\n    >\\n      -\\n    </button>\\n    <button\\n      @click=\\"maximizeWindow()\\"\\n      class=\\"imjoy-noselect imjoy-dialog-control\\"\\n      style=\\"background:#00cdff61;left:55px;\\"\\n    >\\n      {{fullscreen?'=': '+'}}\\n    </button>\\n  </div>\\n  <template v-for=\\"wdialog in dialogWindows\\">\\n    <div\\n      :key=\\"wdialog.window_id\\"\\n      v-show=\\"wdialog === selectedDialogWindow\\"\\n      style=\\"height: calc(100% - 18px);\\"\\n    >\\n      <div :id=\\"wdialog.window_id\\" style=\\"width: 100%;height: 100%;\\"></div>\\n    </div>\\n  </template>\\n</modal>\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicApp.template.html?`)},"./src/imjoyBasicAppMenu.template.html":function(module,exports){eval(`module.exports = "<div class=\\"imjoy-dropdown\\" :style=\\"menuStyle\\">\\n  <a class=\\"imjoy-dropdown-btn\\"\\n    ><img\\n      style=\\"width:24px;\\"\\n      src=\\"https://imjoy.io/static/img/imjoy-icon.svg\\"\\n    />\\n  </a>\\n  <div\\n    class=\\"imjoy-dropdown-content\\"\\n    v-if=\\"showContent\\"\\n    @click=\\"menuClicked\\"\\n    :style=\\"{left: menuPos==='left'? 0: null}\\"\\n  >\\n    <a\\n      href=\\"#\\"\\n      v-for=\\"item in extraMenuItems\\"\\n      :key=\\"item.label\\"\\n      @click.prevent=\\"item.callback()\\"\\n      >{{item.label}}</a\\n    >\\n    <hr\\n      style=\\"margin: 0;border-style: solid;color: rgb(157 205 255 / 45%);\\"\\n      v-show=\\"extraMenuItems.length>0 && loadedPlugins.length>0\\"\\n    />\\n    <a\\n      href=\\"#\\"\\n      v-for=\\"p in loadedPlugins\\"\\n      :key=\\"p.id\\"\\n      @click.prevent=\\"p.api.run()\\"\\n      > {{p.name}}</a\\n    >\\n    <hr\\n      style=\\"margin: 0;border-style: solid;color: rgb(157 205 255 / 45%);\\"\\n      v-show=\\"allWindows.length>0 && loadedPlugins.length>0\\"\\n    />\\n    <a href=\\"#\\" v-if=\\"showAboutImJoy\\" @click.prevent=\\"showAboutImJoy()\\"\\n      > About ImJoy</a\\n    >\\n    <hr\\n      style=\\"margin: 0;border-style: solid;color: rgb(157 205 255 / 45%);\\"\\n      v-show=\\"allWindows.length>0 && loadedPlugins.length>0\\"\\n    />\\n    <a\\n      href=\\"#\\"\\n      v-for=\\"w in allWindows\\"\\n      :style=\\"{'background-color': activeWindow===w?'#adcafb78':'', 'font-weight': activeWindow===w? 600:300}\\"\\n      :key=\\"w.id\\"\\n      @click.prevent=\\"w.api.show()\\"\\n      > {{w.name}}</a\\n    >\\n    <a\\n      href=\\"#\\"\\n      v-if=\\"activeWindow && closeWindow\\"\\n      @click.prevent=\\"closeWindow(activeWindow)\\"\\n      > Close Window</a\\n    >\\n  </div>\\n</div>\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicAppMenu.template.html?`)},"./src/imjoyBasicAppWindows.template.html":function(module,exports){eval(`module.exports = "<template v-if=\\"type==='standard'\\">\\n  <hsc-window-style-material>\\n    <hsc-window\\n      v-for=\\"w in windows\\"\\n      :key=\\"w.id\\"\\n      v-show=\\"!w.hidden\\"\\n      :title=\\"w.name\\"\\n      :minimize-style=\\"{display: 'none'}\\"\\n      :close-button=\\"!w.disable_close\\"\\n      @close=\\"closeWindow(w)\\"\\n      :size-state.sync=\\"w.sizeState\\"\\n      :maximize-button=\\"true\\"\\n      :resizable=\\"true\\"\\n      :width=\\"w.w*30\\"\\n      :height=\\"w.h*30\\"\\n      :resizable=\\"true\\"\\n      @resize-start=\\"windowSizePosChanging = true\\"\\n      @resize-end=\\"windowSizePosChanging = false\\"\\n      @move-start=\\"windowSizePosChanging = true\\"\\n      @move-end=\\"windowSizePosChanging = false\\"\\n    >\\n      <div\\n        :class=\\"{'block-pointer-events': windowSizePosChanging }\\"\\n        :id=\\"w.window_id\\"\\n        class=\\"imjoy-window-container\\"\\n      ></div>\\n    </hsc-window>\\n  </hsc-window-style-material>\\n</template>\\n<template v-else>\\n  <div\\n    v-for=\\"w in windows\\"\\n    v-show=\\"w === activeWindow\\"\\n    :key=\\"w.id\\"\\n    class=\\"imjoy-windows\\"\\n    :style=\\"windowStyle\\"\\n  >\\n    <div\\n      v-if=\\"showWindowTitle\\"\\n      style=\\"text-align: center;height:24px; background: #cacaca66;\\"\\n    >\\n      <span\\n        style=\\"font-size:1rem;font-family: Arial, Helvetica, sans-serif;line-height: 24px;\\"\\n        >{{ w.name }}</span\\n      >\\n    </div>\\n    <div\\n      :id=\\"w.window_id\\"\\n      class=\\"imjoy-window-container\\"\\n      :style=\\"{height: showWindowTitle?'calc(100% - 24px)': '100%'}\\"\\n    ></div>\\n  </div>\\n</template>\\n<div\\n  v-if=\\"showEmpty && (!activeWindow || windows.length <= 0)\\"\\n  class=\\"imjoy-windows\\"\\n  :style=\\"windowStyle\\"\\n>\\n  <img\\n    style=\\"width:80px; position:absolute; left:50%; top: 50%; transform: translate(-50%, -50%);\\"\\n    src=\\"https://imjoy.io/static/img/imjoy-icon.svg\\"\\n  />\\n</div>\\n"

//# sourceURL=webpack://%5Bname%5D/./src/imjoyBasicAppWindows.template.html?`)},"./src/imjoyCore.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return utils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImJoy", function() { return ImJoy; });
/* harmony import */ var _pluginManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginManager.js */ "./src/pluginManager.js");
/* harmony import */ var _windowManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./windowManager.js */ "./src/windowManager.js");
/* harmony import */ var _engineManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engineManager.js */ "./src/engineManager.js");
/* harmony import */ var _fileManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fileManager.js */ "./src/fileManager.js");
/* harmony import */ var _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jailedPlugin.js */ "./src/jailedPlugin.js");
/* harmony import */ var pouchdb_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pouchdb-browser */ "./node_modules/pouchdb-browser/lib/index.es.js");
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! imjoy-rpc */ "./node_modules/imjoy-rpc/index.js");
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(imjoy_rpc__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var minibus__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! minibus */ "./node_modules/minibus/minibus.js");
/* harmony import */ var minibus__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(minibus__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _joy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./joy */ "./src/joy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Joy", function() { return _joy__WEBPACK_IMPORTED_MODULE_9__["Joy"]; });

/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./api */ "./src/api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ajv", function() { return _api__WEBPACK_IMPORTED_MODULE_10__["ajv"]; });

/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_11___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _package_json__WEBPACK_IMPORTED_MODULE_11__["version"]; });













const utils = _utils_js__WEBPACK_IMPORTED_MODULE_7__;

class ImJoy {
  constructor({
    name = "ImJoy",
    imjoy_api = null,
    event_bus = null,
    client_id = null,
    config_db = null,
    default_base_frame = null,
    default_rpc_base_url = null,
    expose_api = false,
    debug = false,
    flags = [],
    engine_selector = null
  }) {
    this.name = name;
    this.config_db = config_db || new pouchdb_browser__WEBPACK_IMPORTED_MODULE_5__["default"]("imjoy_config", {
      revs_limit: 2,
      auto_compaction: true
    });
    this.expose_api = expose_api;
    this.event_bus = event_bus || minibus__WEBPACK_IMPORTED_MODULE_8___default.a.create();
    this.client_id = client_id || "imjoy_web_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_7__["randId"])();
    this.imjoy_api = imjoy_api || {};
    this.engine_selector = engine_selector;
    this.flags = flags;
    this.em = new _engineManager_js__WEBPACK_IMPORTED_MODULE_2__["EngineManager"]({
      event_bus: this.event_bus,
      config_db: this.config_db,
      client_id: this.client_id,
      engine_selector: this.engine_selector
    });
    this.wm = new _windowManager_js__WEBPACK_IMPORTED_MODULE_1__["WindowManager"]({
      event_bus: this.event_bus
    });
    this.fm = new _fileManager_js__WEBPACK_IMPORTED_MODULE_3__["FileManager"]({
      event_bus: this.event_bus
    });
    this.pm = new _pluginManager_js__WEBPACK_IMPORTED_MODULE_0__["PluginManager"]({
      event_bus: this.event_bus,
      config_db: this.config_db,
      engine_manager: this.em,
      window_manager: this.wm,
      file_manager: this.fm,
      imjoy_api: this.imjoy_api,
      default_base_frame: default_base_frame,
      default_rpc_base_url: default_rpc_base_url,
      debug: debug,
      flags: this.flags
    });
  }

  async init() {
    await this.fm.init();
    await this.pm.init();
    this.root_plugin = this.pm.root_plugin;
    if (this.root_plugin) this.api = this.pm.root_plugin.getBoundInterface();

    try {
      await this.pm.loadWorkspaceList();
    } catch (e) {
      console.error(e);
      this.event_bus.emit("show_message", "Failed to load the workspace list: " + e.toString());
    }

    try {
      await this.em.init();
      console.log("Successfully initialized the engine manager.");
    } catch (e) {
      console.error(e);
      this.event_bus.emit("show_message", "Failed to initialize the engine manager: " + e.toString());
    } // inside an iframe


    if (this.expose_api && window.self !== window.top) {
      const api = await imjoy_rpc__WEBPACK_IMPORTED_MODULE_6__["imjoyRPC"].setupRPC({
        name: this.name || "ImJoy"
      });
      const root_plugin_config = {
        _id: "root",
        name: this.name || "ImJoy",
        type: "window",
        ui: null,
        tag: null,
        inputs: null,
        outputs: null,
        docs: "https://imjoy.io/docs/",
        attachments: []
      };
      const imjoy_api = this.pm.imjoy_api;
      const wrapped_api = {};
      const rootPlugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_4__["DynamicPlugin"](root_plugin_config, imjoy_api, null, true);

      for (let k in imjoy_api) {
        if (typeof imjoy_api[k] === "function") {
          wrapped_api[k] = function () {
            return imjoy_api[k].apply(imjoy_api, [rootPlugin].concat(Array.prototype.slice.call(arguments)));
          };
        } else if (typeof imjoy_api[k] === "object") {
          wrapped_api[k] = {};

          for (let u in imjoy_api[k]) {
            wrapped_api[k][u] = function () {
              return imjoy_api[k][u].apply(imjoy_api, [rootPlugin].concat(Array.prototype.slice.call(arguments)));
            };
          }
        }
      }

      wrapped_api.setup = function () {
        api.log("ImJoy App loaded successfully.");
      }; // Note: we need to overwrite this run function here, otherwise, api.run function will be called
      // we need to mask out api.run for the first run to make sure the window plugin runs
      // then we can restore the actual api.run


      let firstRun = true;

      wrapped_api.run = function () {
        if (firstRun) {
          firstRun = false;
          return;
        }

        return imjoy_api.run.apply(imjoy_api, [rootPlugin].concat(Array.prototype.slice.call(arguments)));
      };

      api.export(wrapped_api);
    }
  }

  async start(config) {
    config = config || {};
    await this.init();

    if (config.workspace) {
      await this.pm.loadWorkspace(config.workspace);
      await this.pm.reloadPlugins();
    } else {
      await this.pm.reloadInternalPlugins(true);
    }
  }

  async destroy() {
    this.pm.destroy();
    this.em.destroy();
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/imjoyCore.js?`)},"./src/imjoyLoader.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyCore", function() { return loadImJoyCore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "latest_rpc_version", function() { return latest_rpc_version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyRPC", function() { return loadImJoyRPC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImJoyRPCSocketIO", function() { return loadImJoyRPCSocketIO; });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony import */ var _imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imjoyBasicApp.js */ "./src/imjoyBasicApp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImJoyBasicApp", function() { return _imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["loadImJoyBasicApp"]; });



/**
 * Get the URL parameters
 * source: https://css-tricks.com/snippets/javascript/get-url-variables/
 * @param  {String} url The URL
 * @return {Object}     The URL parameters
 */

var _getParams = function (url) {
  var params = {};
  var parser = document.createElement("a");
  parser.href = url;
  var query = parser.search.substring(1);
  var vars = query.split("&");

  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split("=");
    params[pair[0]] = decodeURIComponent(pair[1]);
  }

  return params;
}; // Load the imjoy core script
// it support the following options:
// 1) version, you can specify a specific version of the core,
// for example \`version: "0.11.13"\` or \`version: "latest"\`
// 2) debug, by default, the minified version will be used,
// if debug==true, the full version will be served
// 3) base_url, the url for loading the core library


function loadImJoyCore(config) {
  config = config || {}; // eslint-disable-next-line no-async-promise-executor

  return new Promise(async (resolve, reject) => {
    try {
      var baseUrl = config.base_url;

      if (!baseUrl) {
        const version = config.version || "latest";
        baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-core@\${version}/dist/\`;
      }

      delete window.imjoyCore;

      if (config.debug) {
        await Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(baseUrl + "imjoy-core.js");
      } else {
        await Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(baseUrl + "imjoy-core.min.js");
      }

      if (window.imjoyCore) {
        const imjoyCore = window.imjoyCore;
        delete window.imjoyCore;
        resolve(imjoyCore);
      } else if (typeof define === "function" && // eslint-disable-next-line no-undef
      __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) eval("require")(["imjoyCore"], resolve);else reject("Failed to import imjoy-core.");
    } catch (e) {
      reject(e);
    }
  });
}
const _rpc_registry = {}; // get version number from package.json

const latest_rpc_version = _package_json__WEBPACK_IMPORTED_MODULE_0__["dependencies"]["imjoy-rpc"].replace(/[^\\d.-]/g, "");
const _rpc_api_versions = {
  "0.2.0": {
    from: "0.1.10",
    to: "0.1.17",
    skips: []
  },
  "0.2.1": {
    from: "0.1.18",
    to: "0.2.5",
    skips: []
  },
  "0.2.2": {
    from: "0.2.6",
    to: "0.2.6",
    skips: []
  },
  "0.2.3": {
    from: "0.2.7",
    to: latest_rpc_version,
    skips: ["0.2.9", "0.2.15", "0.2.16", "0.2.18", "0.2.23", "0.2.24", "0.2.25"]
  }
}; // specify an api version and this function will return the actual imjoy-rpc version
// if you set latestOnly to true, then it returns always the latest for the api version
// otherwise, it will try to find a compatible version in the cached version.

function findRPCVersionByAPIVersion(apiVersion, latestOnly) {
  if (!apiVersion || !apiVersion.includes(".")) return;
  let cached = Object.keys(_rpc_registry);

  if (_rpc_api_versions[apiVersion]) {
    if (cached.length <= 0 || latestOnly) {
      return _rpc_api_versions[apiVersion].to;
    } // see if we can find a compatible version in the cache
    // sort the cached version


    cached = (f => f(f(cached, 1).sort(), -1))((cached, v) => cached.map(a => a.replace(/\\d+/g, n => +n + v * 100000)));

    for (let c of cached.reverse()) {
      if (_rpc_registry[c].API_VERSION === apiVersion) return c;
    }

    return _rpc_api_versions[apiVersion].to;
  } else {
    return null;
  }
} // Load the script for a plugin to communicate with imjoy-rpc
// This should only be called when the window is inside the iframe
// it support the following options:
// 1) version, you can specify a specific version of the imjoy-rpc,
// for example \`version: "0.11.13"\` or \`version: "latest"\`
// 2) api_version, specify the api version of the imjoy-rpc
// 3) debug, by default, the minified version will be used,
// if debug==true, the full version will be served
// 4) base_url, the url for loading the rpc library


function loadImJoyRPC(config) {
  config = config || {};
  return new Promise((resolve, reject) => {
    var baseUrl = config.base_url;
    let version = config.version;

    if (!baseUrl) {
      if (config.version) {
        baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc@\${config.version}/dist/\`;
      } else {
        if (config.api_version) {
          // find the latest version for this api_version
          version = findRPCVersionByAPIVersion(config.api_version, true);

          if (version) {
            baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc@\${version}/dist/\`;
          } else {
            reject(Error(\`Cannot find a version of imjoy-rpc that supports api v\${config.api_version}\`));
            return;
          }
        } else {
          baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc@latest/dist/\`;
          version = "latest";
          console.info(\`Using imjoy-rpc library from \${baseUrl}.\`);
        }
      }
    }

    if (version && _rpc_registry[version]) {
      console.info(\`Using cached imjoy-rpc library v\${version}.\`);
      resolve(_rpc_registry[version]);
      return;
    }

    let rpc_url = baseUrl + "imjoy-rpc.min.js";

    if (config.debug) {
      rpc_url = baseUrl + "imjoy-rpc.js";
    }

    function checkAndCacheLib(imjoyRPC) {
      if (version && version !== "latest" && version !== imjoyRPC.VERSION) {
        throw new Error(\`imjoy-rpc version mismatch \${version} != \${imjoyRPC.VERSION}\`);
      }

      if (config.api_version && config.api_version !== imjoyRPC.API_VERSION) {
        throw new Error(\`imjoy-rpc api version mismatch \${config.api_version} != \${imjoyRPC.API_VERSION}\`);
      }

      _rpc_registry[imjoyRPC.VERSION] = imjoyRPC;
    }

    delete window.imjoyRPC;
    Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(rpc_url).then(() => {
      if (window.imjoyRPC) {
        const imjoyRPC = window.imjoyRPC;
        delete window.imjoyRPC;

        try {
          checkAndCacheLib(imjoyRPC);
          resolve(imjoyRPC);
        } catch (e) {
          reject(e);
        }
      } else if (typeof define === "function" && // eslint-disable-next-line no-undef
      __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) eval("require")(["imjoyRPC"], imjoyRPC => {
        try {
          checkAndCacheLib(imjoyRPC);
          resolve(imjoyRPC);
        } catch (e) {
          reject(e);
        }
      });else {
        reject("Failed to import imjoy-rpc.");
        return;
      }
    }).catch(reject);
  });
}
function loadImJoyRPCSocketIO(config) {
  config = config || {};
  return new Promise((resolve, reject) => {
    var baseUrl = config.base_url;
    let version = config.version;

    if (!baseUrl) {
      if (config.version) {
        baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc-socketio@\${config.version}/dist/\`;
      } else {
        if (config.api_version) {
          // find the latest version for this api_version
          version = findRPCVersionByAPIVersion(config.api_version, true);

          if (version) {
            baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc-socketio@\${version}/dist/\`;
          } else {
            reject(Error(\`Cannot find a version of imjoy-rpc-socketio that supports api v\${config.api_version}\`));
            return;
          }
        } else {
          baseUrl = \`https://cdn.jsdelivr.net/npm/imjoy-rpc-socketio@latest/dist/\`;
          version = "latest";
          console.info(\`Using imjoy-rpc-socketio library from \${baseUrl}.\`);
        }
      }
    }

    let rpc_url = baseUrl + "imjoy-rpc-socketio.min.js";

    if (config.debug) {
      rpc_url = baseUrl + "imjoy-rpc-socketio.js";
    }

    delete window.imjoyRPCSocketIO;
    Object(_imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["injectScript"])(rpc_url).then(() => {
      if (window.imjoyRPCSocketIO) {
        const imjoyRPCSocketIO = window.imjoyRPCSocketIO;
        delete window.imjoyRPCSocketIO;
        resolve(imjoyRPCSocketIO);
      } else if (typeof define === "function" && // eslint-disable-next-line no-undef
      __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) eval("require")(["imjoyRPCSocketIO"], resolve);else {
        reject("Failed to import imjoy-rpc-socketio.");
      }
    }).catch(reject);
  });
}

async function loadImJoyRPCByQueryString() {
  const urlParams = _getParams(window.location);

  return await loadImJoyRPC(urlParams);
}


window.loadImJoyRPCByQueryString = loadImJoyRPCByQueryString;
window.loadImJoyRPC = loadImJoyRPC;
window.loadImJoyRPCSocketIO = loadImJoyRPCSocketIO;
window.loadImJoyCore = loadImJoyCore;
window.loadImJoyBasicApp = _imjoyBasicApp_js__WEBPACK_IMPORTED_MODULE_1__["loadImJoyBasicApp"];

//# sourceURL=webpack://%5Bname%5D/./src/imjoyLoader.js?`)},"./src/internalPlugins.json":function(module){eval(`module.exports = JSON.parse("{\\"BrowserFS\\":{\\"src\\":\\"https://imjoy-team.github.io/imjoy-core-plugins/BrowserFS.imjoy.html\\",\\"startup\\":false},\\"Jupyter-Engine-Manager\\":{\\"src\\":\\"https://imjoy-team.github.io/jupyter-engine-manager/Jupyter-Engine-Manager.imjoy.html\\",\\"startup\\":true},\\"WebPythonWorker\\":{\\"src\\":\\"https://imjoy-team.github.io/imjoy-core-plugins/WebPythonWorker.imjoy.html\\",\\"startup\\":true}}");

//# sourceURL=webpack://%5Bname%5D/./src/internalPlugins.json?`)},"./src/jailedPlugin.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createIframe", function() { return createIframe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeJailed", function() { return initializeJailed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicPlugin", function() { return DynamicPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExternalPluginConfig", function() { return getExternalPluginConfig; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api.js */ "./src/api.js");
/* harmony import */ var _connection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./connection.js */ "./src/connection.js");
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _imjoyLoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./imjoyLoader.js */ "./src/imjoyLoader.js");
/**
 * @fileoverview Jailed - safe yet flexible sandbox
 *
 * @license MIT, see http://github.com/imjoy-team/imjoy-core
 * Copyright (c) 2020 ImJoy Team <imjoy.team@gmail.com>
 *
 * @license MIT, see http://github.com/asvd/jailed
 * Copyright (c) 2014 asvd <heliosframework@gmail.com>
 */






const JailedConfig = {
  default_rpc_base_url: null,
  default_base_frame: null
};
/**
 * Initializes the library site for web environment
 */

let _initialized = false;

const initializeJailed = config => {
  if (config) {
    for (let k in config) {
      JailedConfig[k] = config[k];
    }
  }

  if (!JailedConfig.default_base_frame) JailedConfig.default_base_frame = "https://lib.imjoy.io/default_base_frame.html";

  if (JailedConfig.default_rpc_base_url && !JailedConfig.default_rpc_base_url.endsWith("/")) {
    JailedConfig.default_rpc_base_url = JailedConfig.default_rpc_base_url + "/";
  }

  _initialized = true;
};

function createIframe(config) {
  var sample = document.createElement("iframe");
  sample.src = config.base_frame;
  sample.sandbox = "";
  sample.frameBorder = "0";
  sample.style.width = "100%";
  sample.style.height = "100%";
  sample.style.margin = "0";
  sample.style.padding = "0";
  sample.style.display = "none";
  const frame = sample.cloneNode(false);
  var perm = ["allow-scripts", "allow-forms", "allow-downloads", "allow-modals", "allow-popups", "allow-same-origin"];
  var allows = "";

  if (config.permissions) {
    if (config.permissions.includes("midi") && !allows.includes("midi *;")) {
      allows += "midi *;";
    }

    if (config.permissions.includes("geolocation") && !allows.includes("geolocation *;")) {
      allows += "geolocation *;";
    }

    if (config.permissions.includes("microphone") && !allows.includes("microphone *;")) {
      allows += "microphone *;";
    }

    if (config.permissions.includes("camera") && !allows.includes("camera *;")) {
      allows += "camera *;";
    }

    if (config.permissions.includes("encrypted-media") && !allows.includes("encrypted-media *;")) {
      allows += "encrypted-media *;";
    }

    if (config.permissions.includes("full-screen")) {
      frame.allowfullscreen = "";
    }

    if (config.permissions.includes("payment-request")) {
      frame.allowpaymentrequest = "";
    }
  }

  frame.sandbox = perm.join(" ");
  frame.allow = allows;
  frame.id = "iframe_" + config.id;
  return frame;
}
/**
 * DynamicPlugin constructor, represents a plugin initialized by a
 * string containing the code to be executed
 *
 * @param {String} code of the plugin
 * @param {Object} _interface to provide to the plugin
 */

class DynamicPlugin {
  constructor(config, _interface, engine, is_proxy, allow_evil, connection) {
    if (!_initialized) throw "Please call \`initializeJailed()\` before using Jailed.";
    this.config = config;
    this.id = config.id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    this._id = config._id;
    this.name = config.name;
    this.tag = config.tag;
    this.tags = config.tags;
    this.type = config.type;
    this.initializing = false;
    this.running = false;
    this._log_history = [];
    this._callbacks = config._callbacks || {};
    this._is_proxy = is_proxy;
    this.backend = Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["getBackendByType"])(this.type);
    this.engine = engine;
    this.allow_evil = allow_evil;
    this._hasVisibleWindow = ["window", "rpc-window"].includes(this.type);

    this._updateUI = _interface && _interface.utils && _interface.utils.$forceUpdate || function () {};

    this._bindInterface(_interface);

    if (is_proxy) {
      this._disconnected = false;
    } else {
      this._disconnected = true; // use the plugin event functions if it doesn't exist (window plugins has their own event functions)

      if (!this._initialInterface.on) this._initialInterface.on = this.on;
      if (!this._initialInterface.off) this._initialInterface.off = this.off;
      if (!this._initialInterface.emit) this._initialInterface.emit = this.emit;
      this.api = null;
      this._connected = new _utils_js__WEBPACK_IMPORTED_MODULE_0__["Whenable"](true);
      this._fail = new _utils_js__WEBPACK_IMPORTED_MODULE_0__["Whenable"](true);
      this._disconnect = new _utils_js__WEBPACK_IMPORTED_MODULE_0__["Whenable"](true);
      this.connected = new Promise((resolve, reject) => {
        this._resolveConnected = resolve;
        this._rejectConnected = reject;
      });

      this._connected.whenEmitted(this._resolveConnected);

      this._fail.whenEmitted(this._rejectConnected);

      if (connection) {
        this._setupRPC(connection, config);

        this._initialized_from_connection = true;
      } else {
        if (!this.backend) {
          this._setupViaEngine();
        } else if (this.type === "web-worker" && this.config.base_worker) {
          this._setupViaWebWorker();
        } else {
          this._setupViaIframe();
        }
      }
    }

    this._updateUI();
  }
  /**
   * Get the bound interface of the plugin
   */


  getBoundInterface() {
    return this._initialInterface;
  }
  /**
   * Bind the first argument of all the interface functions to this plugin
   */


  _bindInterface(_interface) {
    _interface = _interface || {};
    this._initialInterface = {
      _rintf: true
    }; // bind this plugin to api functions

    for (var k in _interface) {
      if (Object.prototype.hasOwnProperty.call(_interface, k)) {
        if (typeof _interface[k] === "function") {
          this._initialInterface[k] = _interface[k].bind(null, this);
        } else if (typeof _interface[k] === "object") {
          var utils = {};

          for (var u in _interface[k]) {
            if (Object.prototype.hasOwnProperty.call(_interface[k], u)) {
              if (typeof _interface[k][u] === "function") {
                utils[u] = _interface[k][u].bind(null, this);
              }
            }
          }

          this._initialInterface[k] = utils;
        } else {
          this._initialInterface[k] = _interface[k];
        }
      }
    }
  }

  _engineSetRemote(remote) {
    // check if the plugin is terminated during startup
    if (!this.engine) {
      console.warn("Plugin " + this.id + " is ready, but it was termianted.");
    }

    this.api = remote;
    this.api._rintf = true;
    this.api.config = {
      id: this.id,
      name: this.config.name,
      workspace: this.config.workspace,
      type: this.config.type,
      namespace: this.config.namespace,
      tag: this.config.tag,
      engine_mode: this.config.engine_mode,
      engine: this.engine.url,
      flags: this.config.flags
    };

    if (this.window_id) {
      this.api.config.window_id = this.config.window_id;
    }

    this._disconnected = false;

    if (this.initializing) {
      this.initializing = false;

      this._updateUI();

      this._connected.emit();

      this.engine.registerPlugin(this);
    }
  }

  async _setupViaEngine() {
    if (this.engine && this.engine._is_evil && this.allow_evil !== "eval is evil") {
      this._fail.emit("Evil engine is not allowed.");

      this._connection = null;
      this.error("Evil engine is not allowed.");

      this._set_disconnected();

      return;
    }

    if (!this.engine || !this.engine.connected) {
      this._fail.emit("Please connect to the Plugin Engine .");

      this._connection = null;
      this.error("Please connect to the Plugin Engine .");

      this._set_disconnected();

      return;
    }

    this.initializing = true;

    this._updateUI();

    const me = this;
    const engine_utils = {
      _rintf: true,

      setPluginAPI(remote) {
        me._engineSetRemote(remote);
      },

      terminatePlugin() {
        me.terminate();
      },

      setPluginStatus(status) {
        if (!me._disconnected) {
          me.running = status.running;

          me._updateUI();
        }
      }

    };

    if (this.config.passive) {
      this.engine.startPlugin(this.config, this._initialInterface, engine_utils);

      this._engineSetRemote({
        passive: true,
        _rintf: true,
        setup: async function () {},
        on: async function () {},
        off: async function () {},
        emit: async function () {}
      });
    } else {
      try {
        const remote = await this.engine.startPlugin(this.config, this._initialInterface, engine_utils); // the plugin can either return the api or call engine_utils.setPluginAPI later

        if (remote) {
          this._engineSetRemote(remote);
        }
      } catch (e) {
        this.error(e);

        this._set_disconnected();
      }
    }
  }

  _setupViaWebWorker() {
    if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["getBackendByType"])(this.type)) {
      throw \`Unsupported backend type (\${this.type})\`;
    }

    let webworker;
    webworker = new Worker(this.config.base_worker, {
      name: this.id
    });
    this.webworker = webworker;
    const connection = new _connection_js__WEBPACK_IMPORTED_MODULE_2__["WebWorkerConnection"](webworker);

    this._setupConnection(connection);
  }

  _setupViaIframe() {
    if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["getBackendByType"])(this.type)) {
      throw \`Unsupported backend type (\${this.type})\`;
    }

    if (!this.config.base_frame) {
      let frame_url = JailedConfig.default_base_frame;

      if (JailedConfig.default_rpc_base_url) {
        frame_url = frame_url + "?base_url=" + JailedConfig.default_rpc_base_url;
        console.log("imjoy-rpc library will be loaded from " + JailedConfig.default_rpc_base_url);
      } else {
        frame_url = frame_url + "?version=" + _imjoyLoader_js__WEBPACK_IMPORTED_MODULE_4__["latest_rpc_version"];
      }

      frame_url = frame_url + "&id=" + this.config.id;
      this.config.base_frame = frame_url;
    }

    const _frame = createIframe(this.config);

    if (this._hasVisibleWindow) {
      let window_id = this.config.window_id;

      if (typeof window_id === "string") {
        window_id = document.getElementById(window_id);
      }

      if (window_id) {
        _frame.style.display = "block";
        window_id.innerHTML = "";
        window_id.appendChild(_frame);
        this.window_id = window_id;
      } else {
        throw new Error(\`Failed to load plugin \${this.config.name}, iframe container (id=\${window_id}) not found.\`);
      }
    } else {
      document.body.appendChild(_frame);
    }

    const connection = new _connection_js__WEBPACK_IMPORTED_MODULE_2__["BasicConnection"](_frame);

    this._setupConnection(connection);
  }

  async _setupRPC(connection, pluginConfig) {
    this._connection = connection;
    this.initializing = true;

    this._updateUI();

    try {
      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"])(pluginConfig)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"].errors;
        console.error("Invalid config " + pluginConfig.name || false, pluginConfig, error);
        throw error;
      }

      const imjoyRPC = await Object(_imjoyLoader_js__WEBPACK_IMPORTED_MODULE_4__["loadImJoyRPC"])({
        base_url: JailedConfig.default_rpc_base_url,
        api_version: pluginConfig.api_version,
        debug: JailedConfig.debug
      });
      console.log(\`loaded imjoy-rpc v\${imjoyRPC.VERSION} for \${pluginConfig.name}\`);

      if (!this._rpc) {
        this._rpc = new imjoyRPC.RPC(this._connection, {
          name: "imjoy-core"
        });

        this._registerRPCEvents(this._rpc);

        this._rpc.setInterface(this._initialInterface);
      }

      await this._sendInterface();
      this._allow_execution = pluginConfig.allow_execution;

      if (pluginConfig.allow_execution) {
        await this._executePlugin();
      }

      this.config.passive = this.config.passive || pluginConfig.passive;

      if (this.config.passive) {
        this.api = {
          passive: true,
          _rintf: true,
          setup: async function () {},
          on: async function () {},
          off: async function () {},
          emit: async function () {}
        };
      } else {
        this.api = await this._requestRemote();
      }

      this.api.config = {
        id: this.id,
        name: this.config.name,
        workspace: this.config.workspace,
        type: this.config.type,
        namespace: this.config.namespace,
        tag: this.config.tag,
        flags: this.config.flags
      };

      if (this.window_id) {
        this.api.config.window_id = this.config.window_id;
      }

      this._disconnected = false;
      this.initializing = false;

      this._updateUI();

      this._connected.emit();
    } catch (error) {
      this._fail.emit(error);

      this.disconnect();
      this.initializing = false;
      if (error) this.error(error.toString());

      if (this._hasVisibleWindow && this.config.window_id) {
        const container = document.getElementById(this.config.window_id);
        container.innerHTML = \`<h5>Oops! failed to load the window.</h5><code>Details: \${dompurify__WEBPACK_IMPORTED_MODULE_3___default.a.sanitize(String(error))}</code>\`;
      }

      this._updateUI();
    }
  }

  _setupConnection(connection) {
    this._connection = connection;
    this.initializing = true;

    this._updateUI();

    initializeIfNeeded(this._connection, this.config);

    this._connection.on("initialized", async data => {
      if (data.error) {
        console.error("Plugin failed to initialize", data.error);
        throw new Error(data.error);
      }

      this._setupRPC(this._connection, data.config);
    }); // TODO: check when this will fire


    this._connection.on("failed", e => {
      this._fail.emit(e);
    });

    this._connection.on("disconnected", details => {
      if (details) {
        if (details.error) {
          this.error(details.error);
        } else if (details.info) {
          this.log(details.info);
        }
      }

      this._set_disconnected();
    });

    this._connection.connect();
  }

  _registerRPCEvents(_rpc) {
    _rpc.on("disconnected", details => {
      this._disconnect.emit();

      if (details) {
        if (details.error) {
          this.error(details.message);
        } else if (details.info) {
          this.log(details.info);
        }
      }

      this._set_disconnected();
    });

    _rpc.on("remoteIdle", () => {
      if (this.running) {
        this.running = false;

        this._updateUI();
      }
    });

    _rpc.on("remoteBusy", () => {
      if (!this._disconnected && !this.running) {
        this.running = true;

        this._updateUI();
      }
    });
  }

  async hotReload() {
    if (!this.backend) {
      this.config.hot_reloading = true;
      await this._setupViaEngine();
    } else {
      if (!this._rpc || this._disconnected) throw new Error("There is no RPC connection to the plugin.");
      this.initializing = true;

      this._updateUI();

      if (this._allow_execution) {
        try {
          await this._executePlugin(true);

          if (!this.config.passive) {
            this.api = await this._requestRemote();
          }
        } catch (error) {
          this.error(error.toString());
          throw error;
        } finally {
          this.initializing = false;

          this._updateUI();
        }
      } else {
        this.initializing = false;

        this._updateUI();

        throw new Error("This plugin does not allow execution.");
      }
    }
  }
  /**
   * Loads the plugin body (executes the code in case of the
   * DynamicPlugin)
   */


  async _executePlugin(hot_reloading) {
    if (hot_reloading && this.config.type === "window") //clear the page
      await this._connection.execute({
        type: "script",
        content: \`document.querySelectorAll('style,link[rel="stylesheet"]').forEach(item => item.remove());document.body.innerHTML = '';\`,
        attrs: {
          type: "application/javascript"
        },
        lang: "javascript"
      });

    if (this.config.requirements) {
      const requirement = {
        type: "requirements",
        lang: this.config.lang,
        requirements: this.config.requirements,
        env: this.config.env
      };
      const serialized_requirement = JSON.stringify(requirement);

      if (!hot_reloading || this._executed_requirements !== serialized_requirement) {
        await this._connection.execute(requirement);
        this._executed_requirements = JSON.stringify(requirement);
      }
    }

    if (this._hasVisibleWindow) {
      // TODO: support hot-reloading of window content
      if (this.config.styles) {
        for (let i = 0; i < this.config.styles.length; i++) {
          await this._connection.execute({
            type: "style",
            content: this.config.styles[i].content,
            attrs: this.config.styles[i].attrs,
            src: this.config.styles[i].attrs.src
          });
        }
      }

      if (this.config.links) {
        for (let i = 0; i < this.config.links.length; i++) {
          await this._connection.execute({
            type: "link",
            rel: this.config.links[i].attrs.rel,
            type_: this.config.links[i].attrs.type,
            attrs: this.config.links[i].attrs,
            href: this.config.links[i].attrs.href
          });
        }
      }

      if (this.config.windows) {
        for (let i = 0; i < this.config.windows.length; i++) {
          await this._connection.execute({
            type: "html",
            content: this.config.windows[i].content,
            attrs: this.config.windows[i].attrs
          });
        }
      }
    }

    if (this.config.scripts) {
      const scripts = [];
      let serialized_script = "";

      for (let i = 0; i < this.config.scripts.length; i++) {
        const script = {
          type: "script",
          content: this.config.scripts[i].content,
          lang: this.config.scripts[i].attrs.lang,
          attrs: this.config.scripts[i].attrs,
          src: this.config.scripts[i].attrs.src
        };
        serialized_script = serialized_script + JSON.stringify(script);
        scripts.push(script);
      }

      if (!hot_reloading || serialized_script !== this._executed_scripts) {
        for (let script of scripts) {
          await this._connection.execute(script);
        }

        this._executed_scripts = serialized_script;
      }
    }
  }
  /**
   * Requests the remote interface from the plugin (which was
   * probably set by the plugin during its initialization), emits
   * the connect event when done, then the plugin is fully usable
   * (meaning both the plugin and the application can use the
   * interfaces provided to each other)
   */


  _requestRemote() {
    return new Promise(resolve => {
      this._rpc.once("remoteReady", () => {
        resolve(this._rpc.getRemote());
      });

      this._rpc.requestRemote();
    });
  }

  _sendInterface() {
    return new Promise(resolve => {
      this._rpc.once("interfaceSetAsRemote", resolve);

      this._rpc.sendInterface();
    });
  }
  /**
   * Disconnects the plugin immideately
   */


  disconnect() {
    if (this._connection) this._connection.disconnect();

    this._disconnect.emit();
  }
  /**
   * Saves the provided function as a handler for the connection
   * failure Whenable event
   *
   * @param {Function} handler to be issued upon disconnect
   */


  onFailed(handler) {
    this._fail.whenEmitted(handler);
  }
  /**
   * Saves the provided function as a handler for the connection
   * success Whenable event
   *
   * @param {Function} handler to be issued upon connection
   */


  onConnected(handler) {
    this._connected.whenEmitted(handler);
  }
  /**
   * Saves the provided function as a handler for the connection
   * failure Whenable event
   *
   * @param {Function} handler to be issued upon connection failure
   */


  onDisconnected(handler) {
    this._disconnect.whenEmitted(handler);
  }

  _set_disconnected() {
    this._disconnected = true;
    this.running = false;
    this.initializing = false;
    this.terminating = false;
    this.engine = null;

    this._updateUI();
  }

  _forceDisconnect() {
    this._set_disconnected();

    if (this._rpc) {
      this._rpc.disconnect();

      this._rpc = null;
    }

    if (this._connection) {
      this._connection.disconnect();

      this._connection = null;
    }
  }

  async terminate(force) {
    if (this._disconnected) {
      this._set_disconnected();

      return;
    } // prevent call loop


    if (this.terminating) {
      return;
    }

    if (force) {
      this._forceDisconnect();
    }

    try {
      if (this.api && this.api.exit && typeof this.api.exit == "function") {
        this.api.exit();
      }
    } catch (e) {
      console.error("error occured when terminating the plugin", e);
    } finally {
      setTimeout((() => {
        this._forceDisconnect();
      }).bind(this), 1000);
    }
  }

  on(name, handler, fire_if_emitted) {
    this._callbacks = this._callbacks || {};

    if (this._callbacks[name]) {
      this._callbacks[name].push(handler);
    } else {
      this._callbacks[name] = [handler];
    }

    if (fire_if_emitted && this._callbacks[name].emitted) {
      handler(this._callbacks[name].emitted_data);
    }
  }

  off(name, handler) {
    if (this._callbacks[name]) {
      if (handler) {
        const handlers = this._callbacks[name];
        const idx = handlers.indexOf(handler);

        if (idx >= 0) {
          handlers.splice(idx, 1);
        } else {
          console.warn(\`callback \${name} does not exist.\`);
        }
      } else {
        delete this._callbacks[name];
      }
    } else {
      console.warn(\`callback \${name} does not exist.\`);
    }
  }

  emit(name, data) {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      const errors = [];

      try {
        if (this._callbacks[name]) {
          for (let cb of this._callbacks[name]) {
            try {
              await cb(data !== undefined ? data : undefined);
            } catch (e) {
              errors.push(e);
              console.error(e);
            }
          }
        } else {
          // if no handler set, store the data
          this._callbacks[name] = [];
          this._callbacks[name].emitted = true;
          this._callbacks[name].emitted_data = data;
        }

        if (errors.length <= 0) {
          resolve();
        } else {
          reject(errors);
        }
      } catch (e) {
        reject(e);
      }
    });
  }

  log(msg) {
    if (typeof msg === "object") {
      this._log_history.push(msg);

      console.log(\`Plugin \${this.id}:\`, msg);
    } else {
      const args = Array.prototype.slice.call(arguments).join(" ");
      this._log_history._info = args.slice(0, 100);

      this._log_history.push({
        type: "info",
        value: args
      });

      console.log(\`Plugin \${this.id}: \${args}\`);
    }
  }

  error() {
    const args = Array.prototype.slice.call(arguments).join(" ");
    this._log_history._error = args.slice(0, 100);

    this._log_history.push({
      type: "error",
      value: args
    });

    console.error(\`Error in Plugin \${this.id}: \${args}\`);
  }

  progress(p) {
    if (p < 1) this._progress = p * 100;else this._progress = p;
  }

}

function initializeIfNeeded(connection, default_config) {
  connection.once("imjoyRPCReady", async data => {
    const config = data.config || {};
    let forwarding_functions = ["close", "on", "off", "emit"];

    if (["rpc-window", "window"].includes(config.type || default_config.type)) {
      forwarding_functions = forwarding_functions.concat(["resize", "show", "hide", "refresh"]);
    }

    let credential;

    if (config.credential_required) {
      if (!Array.isArray(config.credential_fields)) {
        throw new Error("Please specify the \`config.credential_fields\` as an array of object.");
      }

      if (default_config.credential_handler) {
        credential = await default_config.credential_handler(config.credential_fields);
      } else {
        credential = {};

        for (let k in config.credential_fields) {
          credential[k.id] = window.prompt(k.label, k.value);
        }
      }
    }

    connection.emit({
      type: "initialize",
      config: {
        name: default_config.name,
        type: default_config.type,
        allow_execution: true,
        enable_service_worker: false,
        forwarding_functions: forwarding_functions,
        expose_api_globally: true,
        credential: credential
      },
      peer_id: data.peer_id
    });
  });
}

function getExternalPluginConfig(src, container, show) {
  return new Promise((resolve, reject) => {
    let _connection, url, _frame;

    container = container || document.body;

    if (typeof src === "string") {
      _frame = createIframe({
        id: "external_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])(),
        type: "window",
        base_frame: src,
        permissions: []
      });
      if (!show) _frame.style.display = "none";
      container.appendChild(_frame);
      _connection = new _connection_js__WEBPACK_IMPORTED_MODULE_2__["BasicConnection"](_frame);
      url = src;
    } else {
      url = src.url;
      _connection = src;
    }

    const connection_timer = setTimeout(() => {
      reject("Timeout error: failed to connect to the plugin");
    }, 15000);
    initializeIfNeeded(_connection, {});

    _connection.once("initialized", async data => {
      if (_frame) container.removeChild(_frame);
      clearTimeout(connection_timer);
      const pluginConfig = data.config;

      if (data.error) {
        console.error("Plugin failed to initialize", data.error);
        throw new Error(data.error);
      }

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"])(pluginConfig)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_1__["CONFIG_SCHEMA"].errors;
        console.error("Invalid config " + pluginConfig.name || false, pluginConfig, error);
        throw error;
      }

      pluginConfig.base_frame = url;
      pluginConfig.code = \`<config lang="json">\\n\${JSON.stringify(pluginConfig, null, "  ")}\\n</config>\`;
      pluginConfig.uri = url;
      pluginConfig.origin = url;
      resolve(pluginConfig);
    });

    _connection.once("failed", e => {
      clearTimeout(connection_timer);
      if (_frame) container.removeChild(_frame);
      reject(e);
    });

    _connection.connect();
  });
}



//# sourceURL=webpack://%5Bname%5D/./src/jailedPlugin.js?`)},"./src/joy.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Joy", function() { return Joy; });
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lz-string */ "./node_modules/lz-string/libs/lz-string.js");
/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_1__);
/* eslint-disable */

/*****************

JOY.js: make happy little programs

VERSION 0 (the incredibly clunky first version) (sorry)

Created by Nicky Case http://ncase.me/

*****************/

 // THE JOY MASTER

function Joy(options) {
  // You can call this as "new Joy()" or just "Joy()"
  var self = this == window ? {} : this; // Modules to import?

  if (options.modules) {
    for (var i = 0; i < options.modules.length; i++) {
      Joy.loadModule(options.modules[i]);
    }
  } // I'm a Joy.Op!


  Joy.Op.call(self, options); // Initialize References

  Joy.initReferences(self); // Allow previewing of... ops, numbers, variables?

  if (self.previewOps == undefined) self.previewOps = false;
  if (self.previewNumbers == undefined) self.previewNumbers = false; //if(self.previewVariables==undefined) self.previewVariables = false;

  self.activePreview = null;

  self.canPreview = function (type) {
    type = type.charAt(0).toUpperCase() + type.slice(1);
    var allowed = self["preview" + type];
    return allowed && !self.activePreview;
  }; // And: automatically create MY widget!


  self.createWidget();

  if (self.container) {
    // ...and auto-add my DOM to a container, if provided in options
    if (typeof self.container === "string") self.container = document.body.querySelector(self.container);
    self.container.appendChild(self.dom);
  } // Initialize UI & Modal


  Joy.ui.init(self);
  Joy.modal.init(self); // Return to sender

  return self;
}

Joy.normalizeUI = function (ui) {
  if (!ui) {
    return "";
  }

  let normui = "";

  if (Array.isArray(ui)) {
    for (let it of ui) {
      if (typeof it === "string") normui = normui + it + "<br>";else if (typeof it === "object") {
        for (let k in it) {
          if (typeof it[k] === "string") normui = normui + k + ": " + it[k] + "<br>";else normui = normui + k + ": " + JSON.stringify(it[k]) + "<br>";
        }
      } else normui = normui + JSON.stringify(it) + "<br>";
    }
  } else if (typeof ui === "object") {
    throw "ui can not be an object, you can only use a string or an array.";
  } else if (typeof ui === "string") {
    normui = ui.trim();
  } else {
    normui = "";
    console.log("Warning: removing ui string.");
  }

  return normui;
};
/*****************

ACTORS help the Player, Editor & Data talk to each other.

To create an Op, you need to pass it a "options" object like so:
(ALL the parameters are optional, btw)
{
	id: "steps", // by default, this is opID AND dataID
	dataID: "steps", // ONLY if opID=/=dataID. (e.g. two ops modify same data)
	type: "number", // what Op Template to inherit from, if any
	placeholder: 50 // if no data, what should be the placeholder?
}

*****************/


Joy.Op = function (options, parent, data) {
  var self = this; // Meta

  self._class_ = "Op";
  self.options = options;
  self.parent = parent;
  self.top = self.parent ? self.parent.top : self; // if no parent, I'M top dog.
  // Inherit from Op Template, if any. THEN inherit from "options"

  self.type = options.type;

  if (self.type) {
    var opTemplate = Joy.getTemplateByType(self.type);

    _configure(self, opTemplate);
  }

  _configure(self, self.options);

  if (parent && typeof parent.onupdate == "object" && parent.onupdate[self.id]) {
    self.onupdate = parent.onupdate[self.id];
  } // Adding child ops


  self.children = [];

  self.addChild = function (child, data) {
    //get onupdate for the child
    if (typeof self.onupdate == "object" && self.onupdate[child.id]) {
      child.onupdate = self.onupdate[child.id];
    } // If child's not an Op, it's options to create a new Op.


    if (child._class_ != "Op") child = new Joy.Op(child, self, data);
    self.children.push(child); // If it has an ID, reference child with ID

    if (child.id) self[child.id] = child; // gimme

    return child;
  };

  self.removeChild = function (child) {
    _removeFromArray(self.children, child);

    child.kill();
  }; // Kill!


  self.onkill = self.onkill || function () {};

  self.kill = function () {
    // Remove my DOM, if any.
    if (self.dom && self.dom.parentNode) self.dom.parentNode.removeChild(self.dom); // Kill all children, too

    while (self.children.length > 0) {
      self.removeChild(self.children[0]);
    } // On Kill?


    self.onkill(self);
  }; /////////////////////////////////
  // ACTOR <-> DATA: //////////////
  /////////////////////////////////
  // Placeholder... convert to {value:w/e} object.


  if (self.placeholder === undefined) {
    // If nothing, blank object.
    self.placeholder = {};
  }

  if (typeof self.placeholder === "function") {
    // If placeholder's a function, run it!
    self.placeholder = self.placeholder();
  }

  if (typeof self.placeholder !== "object" || Array.isArray(self.placeholder)) {
    // If placeholder value's not an object (or is array)
    self.placeholder = {
      value: _clone(self.placeholder)
    };
  } // If data type not already specified, do that!


  if (!self.placeholder.type) {
    self.placeholder.type = self.type;
  } // If you didn't already pass in a data object, let's figure it out!


  self.data = self.data || data;

  if (!self.data) {
    var parent = self.parent;
    var dataID = self.dataID;

    if (parent && dataID) {
      // if nothing, put placeholder in parent
      if (!parent.data[dataID]) parent.data[dataID] = _clone(self.placeholder);
      self.data = parent.data[dataID]; // i'm parent's sub-data!
    } else {
      // ...otherwise, I'm standalone data.
      self.data = _clone(self.placeholder);
    }
  } // Get & Set!


  self.getData = function (dataID) {
    return self.data[dataID];
  };

  self.setData = function (dataID, newValue, noUpdate) {
    if (newValue === undefined) {
      delete self.data[dataID]; // DELETE the thing!
    } else {
      self.data[dataID] = newValue;
    }

    if (!noUpdate) self.update();
  }; /////////////////////////////////
  // ACTOR <-> EDITOR: "WIDGETS" //
  /////////////////////////////////


  self.dom = null; // to be created in "createWidget"!
  // Init & Create Widget (if none, just put a "todo")

  self.initWidget = self.initWidget || function () {
    self.dom = document.createElement("span");
    self.dom.innerHTML = "[todo: define ui for '" + self.type + "']";
  };

  self.createWidget = function () {
    self.initWidget(self); // bind

    return self.dom;
  }; // "Preview Data"


  self.previewData = null; /////////////////////////////////
  // ACTOR <-> PLAYER: "TARGETS" //
  /////////////////////////////////
  // Ops can ACT ON targets...

  self.onexecute = self.onexecute || function () {
    console.log("no execute function found.");
  };

  self.execute = async function (target, altData) {
    // Real or Preview data?
    var data;

    if (altData) {
      data = _clone(altData);
    } else if (self.previewData) {
      data = _clone(self.previewData);
    } else {
      data = _clone(self.data);
    } // Try to pre-evaluate all data beforehand!


    self.children.forEach(function (childOp) {
      var dataID = childOp.dataID;

      if (dataID) {
        var value = childOp.get(target);
        data[dataID] = value;
      }
    }); // On Execute!

    return await self.onexecute({
      op: self,
      target: target,
      data: data
    });
  }; // Update


  self.update = function () {
    // if(self.onchange && typeof self.onchange == 'function') self.onchange({});
    if (self.parent) self.parent.update();

    if (self.onupdate && typeof self.onupdate === "function") {
      // Real or Preview data?
      var data;

      if (self.previewData) {
        data = _clone(self.previewData);
      } else {
        data = _clone(self.data);
      } // Try to pre-evaluate all data beforehand!


      self.children.forEach(function (childOp) {
        var dataID = childOp.dataID;

        if (dataID) {
          var value = childOp.get({});
          data[dataID] = value;
        }
      });
      var ret = self.onupdate({
        data: data
      }); // TODO: make consistent with .execute()
      // if(ret instanceof Promise){
      // 	ret.then((res)=>{
      // 		try {
      // 			if(res && res.init){
      // 				// TODO: update the widget
      // 				// self.children = [];
      // 				// replace the entire dom
      // 				// Joy.initializeWithString(self, res.init);
      // 				// self.createWidget();
      // 				// if(self.top && self.top.container){
      // 				// 	self.top.container.innerHTML=""
      // 				// 	self.top.container.appendChild(self.dom);
      // 				// }
      // 				var old_dom = self.dom
      // 				self.children = [];
      // 				Joy.initializeWithString(self, res.init);
      // 				self.createWidget();
      // 				if(self.parent && self.parent.dom){
      // 					self.parent.dom.replaceChild(self.dom, old_dom);
      // 				}
      // 			}
      // 		} catch (e) {
      // 			console.error(e)
      // 		}
      // 	}).catch(()=>{
      // 		console.error('failed to run onupdate function in ' + self.id)
      // 	}); //my
      // }
    }
  };

  self.get_config = function (target) {
    target = target || {}; // Real or Preview data?

    var data;

    if (self.previewData) {
      data = _clone(self.previewData);
    } else {
      data = _clone(self.data);
    } // Try to pre-evaluate all data beforehand!


    self.children.forEach(function (childOp) {
      var dataID = childOp.dataID;

      if (dataID && target) {
        var value = childOp.get(target);
        data[dataID] = value;
      }
    });
    return data;
  }; // ...or GET INFO from targets.


  self.onget = self.onget || function (my) {
    return my.data;
  }; // dy default it returns data (my.config)


  self.get = function (target) {
    // Real or Preview data?
    var data = self.previewData ? self.previewData : self.data;
    data = _clone(data); // On Get!

    return self.onget({
      op: self,
      target: target,
      data: data
    });
  }; /////////////////////////////////
  // INITIALIZE ///////////////////
  /////////////////////////////////
  // Initialization: string or function?


  if (self.init) {
    if (typeof self.init === "string") Joy.initializeWithString(self, self.init);
    if (typeof self.init === "function") self.init(self);
  }
};
/*****************

ACTOR TEMPLATES that future Ops can be made from! Looks like this:

Joy.add({
	name: "Turn turtle", // what the Ops Widget calls it
	type: "turtle/turn", // what it's called in Op & Data
	tags: ["turtle", "op"], // meta tags
	init: "Turn {id:'angle', type:'number', placeholder:10} degrees", // for init'ing op & widget
	onexecute: function(my){
		my.target.turn(my.data.angle);
	}
});

*****************/
// Add Template


Joy.templates = [];

Joy.add = function (template) {
  var duplicated = Joy.templates.filter(function (t) {
    if (t.type === undefined || template.type === undefined) return false;else return t.type === template.type;
  });

  if (duplicated.length <= 0) {
    Joy.templates.push(template);
  } else {
    // console.log('replacing template ', template.name, template.type)
    for (var i = 0; i < duplicated.length; i++) _removeFromArray(Joy.templates, duplicated[i]);

    Joy.templates.push(template);
  }
};

Joy.remove = function (type) {
  var duplicated = Joy.templates.filter(function (t) {
    if (t.type === type) return true;
  });

  if (duplicated.length > 0) {
    // console.log('replacing template ', template.name, template.type)
    for (var i = 0; i < duplicated.length; i++) _removeFromArray(Joy.templates, duplicated[i]);
  }
};

Joy.reset = function () {
  Joy.templates = [];
}; // Get Template


Joy.getTemplateByType = function (type) {
  var template = Joy.templates.find(function (template) {
    return template.type === type;
  });
  if (!template) throw Error("No op template of type '" + type + "'!");
  return template;
};

Joy.getTemplatesByTag = function (tag) {
  return Joy.templates.filter(function (template) {
    return template.tags && template.tags.indexOf(tag) >= 0;
  });
}; // Modify Templates


Joy.modify = function () {
  // Arguments: (type, callback) or (type, rename, callback)
  var type, rename, callback;

  if (arguments.length == 2) {
    type = arguments[0];
    callback = arguments[1];
  } else {
    type = arguments[0];
    rename = arguments[1];
    callback = arguments[2];
  } // New Template inherits from old...


  var newTemplate = {};

  var _old = Joy.getTemplateByType(type);

  _configure(newTemplate, _old); // Then inherits from modifications


  var modifications = callback(_old);

  _configure(newTemplate, modifications); // Then, either RENAME or REMOVE old op template!


  if (rename) {
    _old.type = rename;
  } else {
    _removeFromArray(Joy.templates, _old);
  } // And add the new one!


  Joy.add(newTemplate);
}; // Converts a string into an ENTIRE ACTOR


Joy.initializeWithString = function (self, markup) {
  try {
    markup = dompurify__WEBPACK_IMPORTED_MODULE_0___default.a.sanitize(markup);
  } catch (e) {
    console.log("Failed to sanitize the ui string", e);
  }

  var opOptions = [];
  var html = markup; // Split the markup into Op Options & Widget HTML

  var startIndex = -1;
  var endIndex = -1;
  var stack = 0; // Go through each character. When you find a top-level "{...}" JSON string,
  // 1) parse it into an Op Option
  // 2) replace it in the markup with a <span> saying where its widget should go

  for (var i = 0; i < html.length; i++) {
    var character = html[i]; // ONLY the top-level {...}'s...

    if (stack == 0 && character == "{") startIndex = i;
    if (character == "{") stack++;
    if (character == "}") stack--;

    if (stack == 0 && character == "}") {
      endIndex = i + 1; // Cut out start to end, save as JSON & replace markup with <span>

      var json = html.slice(startIndex, endIndex);
      json = json.replace(/(\\w+)\\:/g, "'$1':"); // cleanup: give nameerties quotes

      json = json.replace(/\\'/g, '"'); // cleanup: replace ' with "

      json = JSON.parse(json);
      json.dataID = json.dataID || json.id; // cleanup: dataID=id by default

      opOptions.push(json); // remember option!

      html = html.substr(0, startIndex) + "<span id='widget_" + json.id + "'></span>" + html.substr(endIndex); // replace markup
      // GO BACK TO THE BEGINNING & START OVER
      // because i'm too lazy to calculate where the index should go now

      i = 0;
      startIndex = -1;
      endIndex = -1;
      stack = 0;
    }
  } // Create all child Ops


  opOptions.forEach(function (opOption) {
    self.addChild(opOption);
  }); // Create Widget: html, and replace

  self.createWidget = function () {
    self.dom = document.createElement("span");
    self.dom.innerHTML = html; // Replace all <spans> with childrens' widgets.

    self.children.forEach(function (child) {
      // Make child create a widget!
      child.createWidget(); // Replace <span> with child's widget

      var selector = "#widget_" + child.id;
      var span = self.dom.querySelector(selector);
      self.dom.replaceChild(child.dom, span);
    }); // Return to sender

    return self.dom;
  };
};
/*****************

JOY MODULES

So that a player can slowly step up the staircase of complexity
(also maybe import Ops in the future?)

*****************/


Joy.modules = {};

Joy.module = function (id, callback) {
  Joy.modules[id] = callback;
};

Joy.loadModule = function (id) {
  var module = Joy.modules[id];
  if (!module) throw Error("There's no module called '" + id + "'!");
  module();
};
/******************************

GETTING & SETTING REFERENCES FROM TOP.DATA

This is so you can sync variables, functions, strings, object names, etc.

Each reference should have: Unique ID, Tag, Data, Watchers
// (when Watchers[].length==0, delete that reference. Garbage day)

******************************/


Joy.initReferences = function (op) {
  // Create if not already
  var topdata = op.top.data;
  if (!topdata._references) topdata._references = {}; // Zero out all connected, it's a brand new world.

  for (var id in topdata._references) {
    var ref = topdata._references[id];
    ref.connected = 0;
  }
};

Joy.createReference = function (op, tags, data) {
  // The reference
  var topdata = op.top.data;
  var reference = {
    id: _generateUID(topdata._references),
    tags: _forceToArray(tags),
    data: data,
    connected: 0 // tracks how many ops this thing actually depends on

  };
  topdata._references[reference.id] = reference; // Gimme

  return reference;
};

Joy.getReferenceById = function (op, refID) {
  var topdata = op.top.data;
  return topdata._references[refID];
};

Joy.getReferencesByTag = function (op, tag) {
  var topdata = op.top.data;
  var refs = [];

  for (var id in topdata._references) {
    var ref = topdata._references[id];
    if (ref.tags.indexOf(tag) >= 0) refs.push(ref);
  }

  return refs;
};

Joy.connectReference = function (op, refID) {
  var ref = Joy.getReferenceById(op, refID);
  ref.connected++;
};

Joy.disconnectReference = function (op, refID) {
  var ref = Joy.getReferenceById(op, refID);
  ref.connected--;
  if (ref.connected == 0) Joy.deleteReference(op, refID);
};

Joy.deleteReference = function (op, refID) {
  var topdata = op.top.data;
  var reference = topdata._references[refID];
  delete topdata._references[refID];
};
/*
Joy.watchReference = function(topdata, id){
	var reference = topdata._references[id];
	reference._creators++;
	return reference;
};

Joy.unwatchReference = function(topdata, id){

	// The reference?
	var reference = topdata._references[id];
	reference._creators--;

	// If no more _creators, DELETE.
	if(reference._creators==0) Joy.deleteReference(topdata, id);

	return reference;

};
*/

/******************************

SAVE & LOAD

No need for a server!
Just compresses JSON with LZ-String and puts it in the URL

******************************/


Joy.encodeWorkflow = function (data) {
  var json = JSON.stringify(data); // Stringify

  var compressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.compressToEncodedURIComponent(json); // Compress

  return compressed;
};

Joy.decodeWorkflow = function (hash) {
  var decompressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.decompressFromEncodedURIComponent(hash);

  if (decompressed) {
    var data = JSON.parse(decompressed);
    return data;
  } else {
    return null;
  }
};

Joy.saveToURL = function (data) {
  var json = JSON.stringify(data); // Stringify

  var compressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.compressToEncodedURIComponent(json); // Compress

  var url = window.location.origin + window.location.pathname + "#/app?workflow=" + compressed; // append to current URL
  // TODO: keep # and OTHER query stuff the same, just change ?data

  return url;
};

Joy.loadFromURL = function () {
  var hash = _getParameterByName("workflow");

  var decompressed = lz_string__WEBPACK_IMPORTED_MODULE_1___default.a.decompressFromEncodedURIComponent(hash);

  if (decompressed) {
    var data = JSON.parse(decompressed);
    return data;
  } else {
    return null;
  }
};
/**********************************

RANDOM CRAP TO MAKE MY LIFE EASIER

TODO: namespace these to avoid conflict

**********************************/
// For true believers


Math.TAU = 2 * Math.PI; // Deep clone

var _clone = function (json) {
  return JSON.parse(JSON.stringify(json));
}; // "Configure": or just slap all properties of one object onto another


var _configure = function (target, config) {
  for (var key in config) {
    var value = config[key];
    target[key] = value;
  }
}; // Array stuff


var _removeFromArray = function (array, toDelete) {
  var index = array.indexOf(toDelete);
  if (index < 0) return false;
  array.splice(index, 1);
  return true;
}; // Instant space


var _nbsp = function () {
  var span = document.createElement("span");
  span.innerHTML = "&nbsp;";
  return span;
}; // When in Rome, use a completely unuseable numeric system
// from http://blog.stevenlevithan.com/archives/javascript-roman-numeral-converter


var _numberToRoman = function (num) {
  if (!+num) return NaN;
  var digits = String(+num).split(""),
      key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"],
      roman = "",
      i = 3;

  while (i--) roman = (key[+digits.pop() + i * 10] || "") + roman;

  var result = Array(+digits.join("") + 1).join("M") + roman;
  return result.toLowerCase();
}; // Number to Alphabetic Base 26
// from https://stackoverflow.com/a/8604591


var _numberToAlphabet = function (a) {
  var alpha = "abcdefghijklmnopqrstuvwxyz"; // First figure out how many digits there are.

  var c = 0;
  var x = 1;

  while (a >= x) {
    c++;
    a -= x;
    x *= 26;
  } // Now you can do normal base conversion.


  var s = "";

  for (var i = 0; i < c; i++) {
    s = alpha.charAt(a % 26) + s;
    a = Math.floor(a / 26);
  }

  return s;
}; // Helps prevent copy-pasting weird stuff into contenteditable
// see: http://jsfiddle.net/marinagon/1v63t05q/


var _insertTextAtCursor = function (text) {
  var sel, range, html;

  if (window.getSelection) {
    sel = window.getSelection();

    if (sel.getRangeAt && sel.rangeCount) {
      range = sel.getRangeAt(0);
      range.deleteContents();
      range.insertNode(document.createTextNode(text));
    }
  } else if (document.selection && document.selection.createRange) {
    document.selection.createRange().text = text;
  }
};

var _preventWeirdCopyPaste = function (element) {
  element.addEventListener("paste", function (e) {
    e.preventDefault();

    if (e.clipboardData && e.clipboardData.getData) {
      var text = e.clipboardData.getData("text/plain");
      document.execCommand("insertHTML", false, text);
    } else if (window.clipboardData && window.clipboardData.getData) {
      var text = window.clipboardData.getData("Text");

      _insertTextAtCursor(text);
    }
  });
};

var _selectAll = function (input, collapseToEnd) {
  // select all text in contenteditable
  // see http://stackoverflow.com/a/6150060/145346
  var range = document.createRange();
  range.selectNodeContents(input);
  if (collapseToEnd) range.collapse(false); // total hack

  var selection = window.getSelection();
  selection.removeAllRanges();

  try {
    selection.addRange(range);
  } catch (e) {}
};

var _unselectAll = function () {
  var selection = window.getSelection();
  selection.removeAllRanges();
};

var _fixStringInput = function (input) {
  // Empty? Fix that!
  if (input.innerText == "") {
    input.innerHTML = "&nbsp;"; // Is it empty? Let's fix that.

    _selectAll(input);
  } // Line breaks? HECK NO!


  if (input.innerHTML.search("<br>") >= 0) {
    input.innerHTML = input.innerHTML.replace(/(\\<br\\>)+/g, "&nbsp;");

    _selectAll(input, true);
  }
};

var _blurOnEnter = function (input) {
  input.addEventListener("keypress", function (event) {
    if (event.which === 13) {
      event.preventDefault();
      input.blur();
    }
  });
}; // Find a unique ID within an object


var _generateUID = function (obj) {
  var num = 0;
  var id;

  do {
    //id = Math.floor(Math.random()*1000000)+""; // a MILLION random IDs, hopefully don't go over
    id = "id" + num; // linear time but who cares

    num++;
  } while (obj[id]);

  return id;
}; // Make this an array, if not already


var _forceToArray = function (thing) {
  if (Array.isArray(thing)) return thing;else return [thing];
}; // Generate a deterministically pseudo-random color from an ID
// TODO: not looking like crap. same luminance, etc.
//var _generateColor = function(obj){	};
// Remove all children from a DOM


var _emptyDOM = function (node) {
  while (node.hasChildNodes()) node.removeChild(node.lastChild);
}; // Get Query Param
// thx to https://stackoverflow.com/a/901144


var _getParameterByName = function (name, url) {
  if (!url) url = window.location.href;
  name = name.replace(/[\\[\\]]/g, "\\\\$&");
  var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
      results = regex.exec(url);
  if (!results) return null;
  if (!results[2]) return "";
  return decodeURIComponent(results[2].replace(/\\+/g, " "));
}; ////////////////////////////
// Good Color Shtuff ///////
// thx to: https://stackoverflow.com/questions/17242144/javascript-convert-hsb-hsv-color-to-rgb-accurately/17243070#17243070
////////////////////////////

/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR
 * h, s, v
 */


function _HSVtoRGB(h, s, v) {
  var r, g, b, i, f, p, q, t;

  if (arguments.length === 1) {
    s = h.s, v = h.v, h = h.h;
  }

  h /= 360; // convert, yo.

  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;

    case 1:
      r = q, g = v, b = p;
      break;

    case 2:
      r = p, g = v, b = t;
      break;

    case 3:
      r = p, g = q, b = v;
      break;

    case 4:
      r = t, g = p, b = v;
      break;

    case 5:
      r = v, g = p, b = q;
      break;
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function _HSVToRGBString(h, s, v) {
  if (arguments.length === 1) {
    s = h[1], v = h[2], h = h[0]; // cast to different vars
  }

  var rgb = _HSVtoRGB(h, s, v);

  return "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
} // well, "random"


var _randomHSVIndex = 0;
var _randomHSVArray = [[0, 0.6, 1.0], [30, 0.8, 1.0], //[120, 0.9, 0.9],
[210, 0.8, 1.0], [260, 0.7, 1.0], [310, 0.6, 1.0]];

function _randomHSV() {
  var hsv = _randomHSVArray[_randomHSVIndex];
  _randomHSVIndex = (_randomHSVIndex + 1) % _randomHSVArray.length; //return _HSVToRGBString(hsv[0], hsv[1], hsv[2]);

  return hsv;
}

function _forceToRGB(color) {
  if (Array.isArray(color)) {
    color = _HSVToRGBString(color[0], color[1], color[2]); // HSV
  }

  return color;
}

(function () {
  // SINGLETON
  var ui = {};
  Joy.ui = ui;

  ui.init = function (master) {
    // CSS
    master.dom.classList.add("joy-master"); // Manual Scroll (to prevent it propagating up...)

    master.container.addEventListener("wheel", function (event) {
      var delta = event.deltaY;
      master.container.scrollTop += delta; // event.preventDefault();

      return false;
    }); // Prevent accidental backspace-history
    // because why the heck is this even a thing, jeez.
    // thx: https://stackoverflow.com/a/2768256
    // document.body.addEventListener('keydown', function(event){
    //     if(event.keyCode === 8) {
    //         var doPrevent = true;
    //         var types = ["text", "password", "file", "search", "email", "number", "date", "color", "datetime", "datetime-local", "month", "range", "search", "tel", "time", "url", "week"];
    //         var d = event.srcElement || event.target;
    //         var disabled = d.getAttribute("readonly") || d.getAttribute("disabled");
    //         if (!disabled) {
    //             if (d.isContentEditable) {
    //                 doPrevent = false;
    //             } else if (d.tagName.toUpperCase() == "INPUT") {
    //                 var type = d.getAttribute("type");
    //                 if (type) {
    //                     type = type.toLowerCase();
    //                 }
    //                 if (types.indexOf(type) > -1) {
    //                     doPrevent = false;
    //                 }
    //             } else if (d.tagName.toUpperCase() == "TEXTAREA") {
    //                 doPrevent = false;
    //             }
    //         }
    //         if (doPrevent) {
    //             event.preventDefault();
    //             return false;
    //         }
    //     }
    // });
  };
  /********************
  Button's config:
  {
  label: "derp",
  onclick: function(){},
  styles: ["round", "hollow"] // optional
  }
  ********************/


  ui.Button = function (config) {
    var self = this; // DOM. Pretty simple.

    var dom = document.createElement("div");
    dom.className = "joy-button";
    self.dom = dom; // Setting Label

    config.label = config.label || "";
    self.label = document.createElement("span");
    dom.appendChild(self.label);

    self.setLabel = function (newLabel) {
      self.label.innerHTML = newLabel;
    };

    self.setLabel(config.label); // On Click

    dom.onclick = function () {
      config.onclick();
    }; // Styles


    self.styles = config.styles || [];

    for (var i = 0; i < self.styles.length; i++) dom.classList.add(self.styles[i]);
  };
  /********************
  ChooserButton's config:
  {
  value: [current value], (optional)
  staticLabel: "+", (optional)
  options: options,
  onchange: function(value){},
  position: "left" // optional: for the Joy.modal
  styles: ["round", "hollow"] // optional: for the button
  }
  ********************/


  ui.ChooserButton = function (config) {
    var self = this; // Properties

    self.value = config.value;
    self.options = config.options; // expose, coz may change later

    self.onchange = config.onchange; // IF NO VALUE, PICK FIRST ONE, WHATEVER

    if (!self.value) {
      self.value = self.options[0].value;
    } // This is just a Button that calls Chooser Popup when clicked


    ui.Button.call(self, {
      label: config.staticLabel === undefined ? "" : config.staticLabel,
      onclick: function () {
        // Chooser Modal!
        Joy.modal.Chooser({
          source: self.dom,
          options: self.options,
          onchange: function (value) {
            // Update value & label
            self.value = value;

            _updateLabel(); // On Select callback


            self.onchange(value);
          },
          position: config.position
        });
      },
      styles: config.styles
    }); // Helper method

    var _updateLabel = function () {
      if (config.staticLabel !== undefined) return; // if static, no.
      // Otherwise, find the corresponding label to my current value & set to that.

      var label = self.options.find(function (pair) {
        return pair.value == self.value;
      }).label;
      self.setLabel(label);
    };

    _updateLabel();
  };
  /********************
  Scrubber's config:
  {
  min: 0,
  max: 180,
  value: [current value],
  onchange: function(value){}
  }
  ********************/


  ui.Scrubber = function (config) {
    var self = this; // Config...

    var min = config.min;
    var max = config.max;
    self.value = config.value; // DOM

    var dom = document.createElement("div");
    dom.className = "joy-scrubber";
    self.dom = dom; // DOM *is* Label

    self.setLabel = function (newValue) {
      dom.innerHTML = newValue.toFixed(self.sigfigs);
    }; // On Value Change: make sure it's the right num of sigfigs


    var _onValueChange = function (newValue) {
      newValue = parseFloat(newValue.toFixed(self.sigfigs));
      config.onchange(newValue);
    }; // DRAG IT, BABY


    var isDragging = false;
    var wasDragging = false;
    var lastDragX, startDragValue;
    var delta = 0;

    var _onmousedown = function (event) {
      isDragging = true;
      lastDragX = event.clientX;
      startDragValue = self.value;
      delta = 0;
      if (config.onstart) config.onstart();
    };

    var _onmousemove = function (event) {
      if (isDragging) {
        wasDragging = true; // What's the step?

        var step = Math.pow(0.1, self.sigfigs);
        step = parseFloat(step.toPrecision(1)); // floating point crap
        // Change number

        var velocity = event.clientX - lastDragX;
        lastDragX = event.clientX;
        var multiplier = Math.abs(velocity / 10);
        if (multiplier < 1) multiplier = 1;
        if (multiplier > 3) multiplier = 3;
        delta += velocity * multiplier;
        var dx = Math.floor(delta / 2);
        var newValue = startDragValue + dx * step;
        newValue = _boundNumber(newValue); // Only update if ACTUALLY new.

        if (self.value != newValue) {
          self.value = newValue;
          self.setLabel(newValue);

          _onValueChange(newValue);
        }
      }
    };

    var _boundNumber = function (newValue) {
      if (min !== undefined && newValue < min) newValue = min;
      if (max !== undefined && newValue > max) newValue = max;
      return newValue;
    };

    var _onmouseup = function () {
      isDragging = false;
      if (config.onstop) config.onstop();
      setTimeout(function () {
        wasDragging = false; // so can't "click" if let go on scrubber
      }, 1);
    }; // MOUSE EVENTS


    dom.addEventListener("mousedown", _onmousedown);
    window.addEventListener("mousemove", _onmousemove);
    window.addEventListener("mouseup", _onmouseup); // KILL ALL LISTENERS

    self.kill = function () {
      dom.removeEventListener("mousedown", _onmousedown);
      window.removeEventListener("mousemove", _onmousemove);
      window.removeEventListener("mouseup", _onmouseup);
    }; // On click: edit manually!


    var _manuallyEditing = false;

    dom.onblur = function () {
      if (_manuallyEditing) {
        _manuallyEditing = false;
        dom.contentEditable = false;

        _unselectAll(); // Done manually updating! The new number!


        _countSigFigs(dom.innerText); // re-calc sigfigs


        self.value = _parseNumber();
        self.setLabel(self.value);

        _onValueChange(self.value); // On Stop editing


        if (config.onstop) config.onstop();
      }
    };

    _preventWeirdCopyPaste(dom);

    _blurOnEnter(dom);

    dom.onclick = function () {
      if (wasDragging) return; // can't click if I was just dragging!

      _manuallyEditing = true; // Make it editable, and select it!

      dom.contentEditable = true;
      dom.spellcheck = false;

      _selectAll(dom); // On Start editing


      if (config.onstart) config.onstart();
    };

    dom.oninput = function (event) {
      if (!_manuallyEditing) return; // Also, no non-decimal or numbers

      var regex = /[^0-9.\\-]/g;

      if (dom.innerText.match(regex)) {
        dom.innerText = dom.innerText.replace(regex, "");
      }

      _fixStringInput(dom); // Show that change!


      _onValueChange(_parseNumber());
    };

    var _parseNumber = function () {
      var num = parseFloat(dom.innerText);
      if (isNaN(num)) num = 0;
      num = _boundNumber(num);
      return num;
    }; // How many significant digits?


    self.sigfigs = 0;

    var _countSigFigs = function (string) {
      string = string.toString();
      var sigfigs;
      var positionOfPeriod = string.search(/\\./);

      if (positionOfPeriod >= 0) {
        // has a period
        sigfigs = string.length - 1 - positionOfPeriod;
      } else {
        sigfigs = 0;
      }

      self.sigfigs = sigfigs;
    };

    _countSigFigs(self.value); // Current value...


    self.setLabel(self.value);
  };
  /********************
  String's config:
  {
  prefix: "[",
  suffix: "]",
  color:"whatever",
  value: data.value,
  onchange: function(value){
  data.value = value;
  self.update();
  },
  styles: ["comment"]
  }
  ********************/


  ui.String = function (config) {
    var self = this; // DOM

    var dom = document.createElement("div");
    dom.className = "joy-string";
    self.dom = dom; // The Actual Part that's Content Editable

    var input = document.createElement("span");
    input.contentEditable = true;
    input.spellcheck = false; // Prefix & Suffix & Color: entirely cosmetic

    var prefixDOM = document.createElement("span");
    var suffixDOM = document.createElement("span");
    prefixDOM.innerHTML = config.prefix || "";
    suffixDOM.innerHTML = config.suffix || "";
    dom.appendChild(prefixDOM);
    dom.appendChild(input);
    dom.appendChild(suffixDOM); // On input!

    input.oninput = function (event) {
      _fixStringInput(input);

      var value = input.innerText.replace(/(\\xa0)+/g, ""); // NOT innerHTML

      config.onchange(value); // callback!
    }; // On focus, select all


    input.onfocus = function () {
      _selectAll(input);
    };

    input.onblur = function () {
      _unselectAll();
    };

    _preventWeirdCopyPaste(input); // On pressing <enter>, DON'T line break, just blur


    input.onkeypress = function (e) {
      if (e.which == 13) {
        input.blur();
        return false;
      }

      return true;
    }; // Set String


    self.setString = function (value) {
      input.innerText = value;

      _fixStringInput(input);
    }; // Set Color, why not


    self.setColor = function (color) {
      color = _forceToRGB(color);
      dom.style.color = color;
      dom.style.borderColor = color;
    };

    if (config.color) self.setColor(config.color); // Styles

    self.styles = config.styles || [];

    for (var i = 0; i < self.styles.length; i++) dom.classList.add(self.styles[i]); // Start with the current value


    self.setString(config.value);
  };
  /********************
  TextLine's config:
  {
  multiline: true,
  readonly: true,
  width: number or "[style]",
  onchange: function(newValue){},
  placeholder: "//derp"
  styles: ["box"]
  }
  ********************/
  // TODO: a full WSIYWIG editor?
  // https://hackernoon.com/easily-create-an-html-editor-with-designmode-and-contenteditable-7ed1c465d39b


  ui.TextBox = function (config) {
    var self = this; // DOM

    var input;

    if (config.multiline) {
      input = document.createElement("textarea");
    } else {
      input = document.createElement("input");
      input.type = "text";
    }

    if (config.placeholder) {
      input.placeholder = config.placeholder;
    }

    input.spellcheck = false;
    input.className = "joy-textbox";
    self.dom = input;
    var dom = self.dom; // Config options

    if (config.readonly) {
      input.setAttribute("readonly", 1);
      input.addEventListener("click", function () {
        self.select();
      });
    } else {
      input.oninput = function (event) {
        config.onchange(input.value);
      };
    }

    if (config.width) {
      input.style.width = typeof config.width === "number" ? config.width + "px" : config.width;
    } // Get & Set Value


    self.getValue = function () {
      return input.value;
    };

    self.setValue = function (value) {
      input.value = value;
    }; // Select


    self.select = function () {
      input.select();
    }; // Styles


    self.styles = config.styles || [];

    for (var i = 0; i < self.styles.length; i++) dom.classList.add(self.styles[i]); // Start


    if (config.value) self.setValue(config.value); // If it's multiline, auto-resize!
    // Thanks to this: https://stackoverflow.com/a/25621277

    if (config.multiline) {
      var _onInput = function () {
        this.style.height = "auto";
        this.style.height = this.scrollHeight + "px";
      };

      dom.addEventListener("input", _onInput, false);
      setTimeout(function () {
        dom.setAttribute("style", "height:" + dom.scrollHeight + "px; overflow-y:hidden;");
      }, 1); // some threading thing?
    }
  };
})();
/********************
MODAL:
Places a big ol' modal dialogue bubble over the editor!
********************/


(function () {
  // SINGLETON
  var modal = {};
  Joy.modal = modal;

  modal.init = function (master) {
    //remove existing model dialog
    var elements = document.querySelectorAll("#joy-modal");

    for (var i = 0; i < elements.length; i++) {
      elements[i].parentNode.removeChild(elements[i]);
    } // The main modal container


    modal.dom = document.createElement("div");
    modal.dom.id = "joy-modal";
    document.body.appendChild(modal.dom); // Transparent background you click to kill!

    modal.bg = document.createElement("div");
    modal.bg.id = "joy-bg";

    modal.bg.onclick = function () {
      modal.currentUI.kill();
    };

    modal.dom.appendChild(modal.bg); // The actual bubble box

    modal.box = document.createElement("div");
    modal.box.id = "joy-box";
    modal.box.className = "arrow_box";
    modal.dom.appendChild(modal.box); // NO SCROLL

    modal.dom.addEventListener("wheel", function (event) {
      if (modal.box.style.overflow != "auto") {
        event.preventDefault();
        return false;
      } else {
        return true;
      }
    });
  };

  modal.show = function (ui) {
    modal.dom.style.display = "block"; // hi
    // Remember & add UI

    modal.currentUI = ui;
    modal.box.appendChild(ui.dom); // Position the Box

    var position = ui.config.position || "below";
    var boxBounds = modal.box.getBoundingClientRect();
    var sourceBounds = ui.config.source.getBoundingClientRect();
    var bgBounds = modal.bg.getBoundingClientRect();
    var x,
        y,
        margin = 20;
    var overflow = false; // HACK: IF BELOW & NO SPACE, do LEFT

    if (position == "below") {
      var y = sourceBounds.top + sourceBounds.height + margin; // y: bottom

      if (y + boxBounds.height > document.body.clientHeight) {
        // below page!
        position = "left";
      }
    }

    modal.box.setAttribute("position", position);

    switch (position // TODO: smarter positioning
    ) {
      case "below":
        var x = sourceBounds.left + sourceBounds.width / 2; // x: middle

        var y = sourceBounds.top + sourceBounds.height + margin; // y: bottom

        x -= boxBounds.width / 2;
        break;

      case "left":
        var x = sourceBounds.left - margin; // x: left

        var y = sourceBounds.top + sourceBounds.height / 2; // y: middle

        x -= boxBounds.width;
        y -= boxBounds.height / 2;
        break;
    }

    if (x < 0) x = 1;
    if (y + boxBounds.height > bgBounds.height) y = bgBounds.height - boxBounds.height - 1;
    modal.box.style.left = x + "px";
    modal.box.style.top = y + "px"; // On Open

    if (modal.currentUI.config.onopen) modal.currentUI.config.onopen();
  };

  modal.hide = function () {
    _emptyDOM(modal.box);

    modal.dom.style.display = "none"; // bye
    // On Close

    if (modal.currentUI.config.onclose) modal.currentUI.config.onclose();
  };
  /********************
  Chooser's config:
  {
  source: [who this modal dialog should be "coming from"]
  value: [currently selected value, if any]
  options: [label-value pairs],
  onchange: function(value){}, // callback
  position: "below" // default is "below"
  };
  ********************/


  modal.Chooser = function (config) {
    var self = {}; // just an obj to scope this stuff
    // Config

    self.config = config; // Create DOM

    var dom = document.createElement("div");
    dom.className = "joy-modal-chooser";
    self.dom = dom; // Create List DOM

    var list = document.createElement("div");
    dom.appendChild(list); // Populate with list of options

    self.options = [];
    self.categories = {};
    var _placeholder_ = "_placeholder_";

    var _makeCategory = function (category) {
      // dom
      var categoryDOM = document.createElement("div");
      list.appendChild(categoryDOM); // remember

      self.categories[category] = categoryDOM;
    };

    self.populate = function () {
      // Create categories, if any!
      for (var i = 0; i < config.options.length; i++) {
        var option = config.options[i];
        var category = option.category;

        if (category) {
          // Category doesn't exist yet... make it!
          if (!self.categories[category]) _makeCategory(category);
        } else {
          // Make a placholder if not alredy!
          if (!self.categories[_placeholder_]) _makeCategory(_placeholder_);
        }
      } // Create options


      for (var i = 0; i < config.options.length; i++) {
        // Create option
        var option = config.options[i];
        var optionDOM = document.createElement("div");
        optionDOM.innerHTML = option.label;

        if (option.color) {
          optionDOM.style.color = option.color;
        } // Put it in its category!


        var category = option.category || _placeholder_;
        self.categories[category].appendChild(optionDOM); // On Click!

        (function (option) {
          // TODO: Hover & preview mode?
          optionDOM.onclick = function (event) {
            self.onchange(option.value);
            event.stopPropagation(); // no, don't double-fire
          };
        })(option);
      }
    };

    self.populate(); // On Select

    self.onchange = function (value) {
      self.kill();
      config.onchange(value); // on select AFTER kill, since can create ANOTHER modal
    }; // Kill & Remove


    self.kill = function () {
      modal.hide(); // hide modal
    }; // Show me!


    modal.show(self);
  };
  /********************
  Color's config:
  {
  source: [who this modal dialog should be "coming from"]
  value: [currently selected value, if any]
  onchange: function(value){}, // callback
  onclose: function(){}
  };
  ********************/


  modal.Color = function (config) {
    var self = {}; // just an obj to scope this stuff
    // Config

    self.config = config; // Create DOM

    var dom = document.createElement("div");
    dom.className = "joy-modal-color";
    self.dom = dom; // COLOR is HSV.

    config.value = config.value || [0, 1, 1];
    self.h = config.value[0];
    self.s = config.value[1];
    self.v = config.value[2]; // THREE ELEMENTS:
    // 1. Color Wheel
    // 2. Color Value
    // 3. Color Pickers

    var WHEEL_SIZE = 150;
    var SPECTRUM_WIDTH = 15;
    var MARGIN_1 = 10;
    var MARGIN_2 = 10;
    var MARGIN_3 = 10;
    var FULL_WIDTH = MARGIN_1 + WHEEL_SIZE + MARGIN_2 + SPECTRUM_WIDTH + MARGIN_3;
    var FULL_HEIGHT = MARGIN_1 + WHEEL_SIZE + MARGIN_3;
    self.dom.style.width = FULL_WIDTH + "px";
    self.dom.style.height = FULL_HEIGHT + "px"; /////////////////////////////
    // 1) The Color Wheel ///////
    /////////////////////////////

    var wheelCanvas = document.createElement("canvas");
    wheelCanvas.id = "joy-color-wheel";
    var wheelContext = wheelCanvas.getContext("2d");
    wheelCanvas.width = WHEEL_SIZE * 2;
    wheelCanvas.height = WHEEL_SIZE * 2;
    wheelCanvas.style.width = wheelCanvas.width / 2 + "px";
    wheelCanvas.style.height = wheelCanvas.height / 2 + "px";
    dom.appendChild(wheelCanvas);
    wheelCanvas.style.top = MARGIN_1 + "px";
    wheelCanvas.style.left = MARGIN_1 + "px";

    var _updateWheel = function () {
      // Image Data!
      var ctx = wheelContext;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      var w = wheelCanvas.width;
      var h = wheelCanvas.height;
      var image = ctx.createImageData(w, h);
      var imageData = image.data; // Create a circle of colors
      // Thanks to: https://medium.com/@bantic/hand-coding-a-color-wheel-with-canvas-78256c9d7d43

      var cx = w / 2;
      var cy = h / 2;
      var radius = w / 2; // buffer for the crosshair

      var radiusBuffered = radius + 2; // small buffer for clipping

      for (var x = 0; x < w; x++) {
        for (var y = 0; y < h; y++) {
          var dx = x - cx;
          var dy = y - cy;
          var distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < radiusBuffered) {
            // buffer for clipping
            if (distance >= radius) distance = radius; // Angle & Distance, re-mapped to [0,1]

            var angle = Math.atan2(dy, dx); // from [-tau/2, tau/2]

            angle = (angle / Math.TAU + 0.5) * 360; // to [0,360]

            distance = distance / radius; // to [0,1]
            // HSV! (capitals, coz already using 'h')

            var H = angle;
            var S = distance;
            var V = self.v; // TO RGB

            var rgb = _HSVtoRGB(H, S, V);

            var i = (x + y * w) * 4;
            imageData[i] = rgb[0];
            imageData[i + 1] = rgb[1];
            imageData[i + 2] = rgb[2];
            imageData[i + 3] = 255;
          }
        }
      }

      ctx.putImageData(image, 0, 0); // Clip it, for aliasing

      ctx.save();
      ctx.globalCompositeOperation = "destination-in";
      ctx.beginPath();
      ctx.fillStyle = "#fff";
      ctx.arc(cx, cy, radius, 0, Math.TAU);
      ctx.fill();
      ctx.restore();
    };

    _updateWheel(); /////////////////////////////
    // 2) The Value Spectrum ////
    /////////////////////////////


    var spectrumCanvas = document.createElement("canvas");
    spectrumCanvas.id = "joy-color-value";
    var spectrumContext = spectrumCanvas.getContext("2d");
    spectrumCanvas.width = SPECTRUM_WIDTH * 2;
    spectrumCanvas.height = WHEEL_SIZE * 2;
    spectrumCanvas.style.width = spectrumCanvas.width / 2 + "px";
    spectrumCanvas.style.height = spectrumCanvas.height / 2 + "px";
    dom.appendChild(spectrumCanvas);
    spectrumCanvas.style.top = MARGIN_1 + "px";
    spectrumCanvas.style.right = MARGIN_3 + "px";

    var _updateSpectrum = function () {
      // Image data
      var ctx = spectrumContext;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      var w = spectrumCanvas.width;
      var h = spectrumCanvas.height;
      var image = ctx.createImageData(w, h);
      var imageData = image.data; // Just a good ol' spectrum of values

      for (var x = 0; x < w; x++) {
        for (var y = 0; y < h; y++) {
          // HSV! (capitals, coz already using 'h')
          var H = self.h;
          var S = self.s;
          var V = 1 - y / h; // TO RGB

          var rgb = _HSVtoRGB(H, S, V);

          var i = (x + y * w) * 4;
          imageData[i] = rgb[0];
          imageData[i + 1] = rgb[1];
          imageData[i + 2] = rgb[2];
          imageData[i + 3] = 255;
        }
      }

      ctx.putImageData(image, 0, 0);
    };

    _updateSpectrum(); /////////////////////////////
    // 3) The Color Pickers /////
    /////////////////////////////


    var pickerCanvas = document.createElement("canvas");
    pickerCanvas.id = "joy-color-picker";
    var pickerContext = pickerCanvas.getContext("2d");
    pickerCanvas.width = FULL_WIDTH * 2;
    pickerCanvas.height = FULL_HEIGHT * 2;
    pickerCanvas.style.width = pickerCanvas.width / 2 + "px";
    pickerCanvas.style.height = pickerCanvas.height / 2 + "px";
    dom.appendChild(pickerCanvas);

    var _updatePickers = function () {
      // What's the color?
      var x, y;
      var ctx = pickerContext;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = _HSVToRGBString(self.h, self.s, self.v);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2; // Draw it on the circle

      var cx = MARGIN_1 * 2 + wheelCanvas.width / 2;
      var cy = MARGIN_1 * 2 + wheelCanvas.height / 2;
      var angle = self.h * (Math.TAU / 360);
      var radius = self.s * (wheelCanvas.width / 2);
      x = cx - Math.cos(angle) * radius;
      y = cy - Math.sin(angle) * radius;
      ctx.beginPath();
      ctx.arc(x, y, SPECTRUM_WIDTH, 0, Math.TAU);
      ctx.fill();
      ctx.stroke(); // Draw it on the spectrum

      var sx = MARGIN_1 * 2 + wheelCanvas.width + MARGIN_2 * 2 + spectrumCanvas.width / 2;
      var sy = MARGIN_1 * 2;
      x = sx;
      y = sy + spectrumCanvas.height * (1 - self.v);
      ctx.beginPath();
      ctx.arc(x, y, SPECTRUM_WIDTH, 0, Math.TAU);
      ctx.fill();
      ctx.stroke();
    };

    _updatePickers(); // THE MOUSE EVENTS FOR THE PICKERS


    var editMode;
    var isDragging = false;

    var _update = function (event) {
      if (event.target != pickerCanvas) return; // if outta bounds forget it

      var x = event.offsetX * 2;
      var y = event.offsetY * 2;

      if (editMode == "hs") {
        x -= MARGIN_1 * 2;
        y -= MARGIN_1 * 2;

        _updateHS(x, y);
      } else {
        x -= MARGIN_1 * 2 + wheelCanvas.width + MARGIN_2 * 2;
        y -= MARGIN_1 * 2;

        _updateV(x, y);
      } // HEY TELL THE SOURCE


      _updateSource();
    };

    var _updateHS = function (x, y) {
      // get polar
      var radius = wheelCanvas.width / 2;
      var dx = x - radius;
      var dy = y - radius;
      var angle = Math.atan2(dy, dx);
      var distance = Math.sqrt(dx * dx + dy * dy); // Re-map

      angle = (angle / Math.TAU + 0.5) * 360; // to [0,360]

      if (angle < 0) angle = 0;
      if (angle > 360) angle = 360;
      distance = distance / radius; // to [0,1]

      if (distance < 0) distance = 0;
      if (distance > 1) distance = 1; // update

      self.h = angle;
      self.s = distance;

      _updateSpectrum();

      _updatePickers();
    };

    var _updateV = function (x, y) {
      self.v = 1 - y / spectrumCanvas.height;
      if (self.v < 0) self.v = 0;
      if (self.v > 1) self.v = 1;

      _updateWheel();

      _updatePickers();
    };

    var _onmousedown = function (event) {
      isDragging = true;

      if (event.offsetX * 2 < MARGIN_1 * 2 + wheelCanvas.width + MARGIN_2) {
        editMode = "hs";
      } else {
        editMode = "v";
      }

      _update(event);
    };

    var _onmousemove = function (event) {
      if (isDragging) _update(event);
    };

    var _onmouseup = function () {
      isDragging = false;
    }; // MOUSE EVENTS


    pickerCanvas.addEventListener("mousedown", _onmousedown);
    window.addEventListener("mousemove", _onmousemove);
    window.addEventListener("mouseup", _onmouseup); // UPDATE SOURCE

    var _updateSource = function () {
      var newValue = [self.h, self.s, self.v];
      newValue[0] = parseFloat(newValue[0].toFixed(0));
      newValue[1] = parseFloat(newValue[1].toFixed(2));
      newValue[2] = parseFloat(newValue[2].toFixed(2));
      config.onchange(newValue);
    }; // Kill


    self.kill = function () {
      // KILL LISTENERS
      dom.removeEventListener("mousedown", _onmousedown);
      window.removeEventListener("mousemove", _onmousemove);
      window.removeEventListener("mouseup", _onmouseup); // Hide Modal

      modal.hide();
    }; // Show me!


    modal.show(self);
  };
})(); /////////////////////////////////////////
// FUNDAMENTAL USER INTERACE ACTORS /////
/////////////////////////////////////////
// TODO: Angle widget

/****************

Raw number widget: JUST the scrubber, no chooser

Widget Options:
{id:'steps', type:'number', placeholder:10, min:0, max:180, step:1}

****************/


Joy.add({
  type: "number",
  tags: ["ui"],
  initWidget: function (self) {
    // Scrubber IS the DOM
    var o = self.options;
    var scrubber = new Joy.ui.Scrubber({
      min: o.min,
      max: o.max,
      step: o.step,
      value: self.getData("value"),
      onstart: function () {
        self.top.activePreview = self;
      },
      onstop: function () {
        self.top.activePreview = null;
      },
      onchange: function (value) {
        self.setData("value", value);
      }
    });
    self.dom = scrubber.dom; // PREVIEW ON HOVER. WIGGLE IT JUST ONCE.

    var _ticker = null;
    var _fps = 30;

    self.dom.onmouseenter = function () {
      if (!self.top.canPreview("numbers")) return; // Create Preview Data

      self.previewData = _clone(self.data); // Wiggle by 5%... as long as that's not less than 0.5, not more than 2.

      var _amplitude = Math.abs(self.data.value * 0.05); //if(_amplitude<0.5) _amplitude=0.5; // TODO: WITH SIGFIG
      //if(_amplitude>3) _amplitude=3;


      if (_amplitude == 0) _amplitude = 1; // If it's EXACTLY zero, wiggle with 1, whatever.

      var _timer = 0;
      _ticker = setInterval(function () {
        if (!self.top.canPreview("numbers")) return _stopPreview(); // don't even

        _timer += Math.TAU / _fps / 0.25; // 0.25 seconds

        self.previewData.value = self.data.value + Math.sin(_timer) * _amplitude;
        self.update();
        if (_timer > Math.TAU) _stopPreview(); // yer done, son.
      }, 1000 / _fps);
    };

    var _stopPreview = function () {
      if (_ticker) clearInterval(_ticker);
      self.previewData = null; // self.update();
    };

    self.dom.onmouseleave = _stopPreview;
  },
  onget: function (my) {
    return my.data.value;
  },
  placeholder: {
    value: 3
  }
});
/****************

A button widget

Widget Options:
{id:'direction', type:'button', label:'OK'}

When it's clicked, it will call the corresponding onupdate function

****************/

Joy.add({
  type: "button",
  tags: ["ui"],
  initWidget: function (self) {
    // DOM
    var dom = document.createElement("div");
    dom.className = "joy-save";
    self.dom = dom; // Save Button

    self.saveButton = new Joy.ui.Button({
      label: self.options.label || "--",
      onclick: function () {
        self.update();
      }
    });
    dom.appendChild(self.saveButton.dom);
  }
});
/****************

A color widget! (for now, same as choose except paints DOM, too)

Widget Options:
{id:'direction', type:'choose', options:['left','right'], placeholder:'left'}

****************/

Joy.add({
  type: "color",
  tags: ["ui"],
  initWidget: function (self) {
    // Color Button IS the DOM
    var colorButton = new Joy.ui.Button({
      label: "&nbsp;",
      onclick: function () {
        Joy.modal.Color({
          // TODO: precision for those floats, y'know
          source: self.dom,
          value: self.getData("value"),
          onchange: function (value) {
            self.setData("value", value);

            _changeLabelColor();
          },
          onopen: function () {
            self.top.activePreview = self;
          },
          onclose: function () {
            self.top.activePreview = null;
          }
        });
      },
      styles: ["joy-color"]
    });
    self.dom = colorButton.dom; // Change button color!

    var _changeLabelColor = function () {
      var hsl = self.getData("value");
      colorButton.dom.style.background = _HSVToRGBString(hsl);
    };

    _changeLabelColor(); // PREVIEW ON HOVER
    // BOUNCE the HSL Value up & down!


    var _ticker = null;
    var _fps = 30;

    var _initialV, _vel, _timer;

    self.dom.onmouseenter = function () {
      if (!self.top.canPreview("numbers")) return; // yeah let's pretend it's a number
      // Create Preview Data

      _initialV = self.data.value[2];
      self.previewData = _clone(self.data); // Bounce up & down for HALF a second

      _timer = 0;
      _vel = 2 * (2 / _fps);
      _ticker = setInterval(function () {
        if (!self.top.canPreview("numbers")) return _stopPreview(); // don't
        // Bounce up & down

        var hsl = self.previewData.value;
        hsl[2] += _vel;

        if (hsl[2] > 1) {
          hsl[2] = 1;
          _vel *= -1;
        }

        if (hsl[2] < 0) {
          hsl[2] = 0;
          _vel *= -1;
        }

        self.update(); // Done!

        _timer += 2 / _fps;
        if (_timer >= 1) _stopPreview();
      }, 1000 / _fps);
    };

    var _stopPreview = function () {
      if (_ticker) clearInterval(_ticker);
      self.previewData = null;
      self.update();
    };

    self.dom.onmouseleave = _stopPreview;
  },
  onget: function (my) {
    return _HSVToRGBString(my.data.value);
  },
  placeholder: function () {
    var hue = Math.floor(Math.random() * 360); // Random color!

    return [hue, 0.8, 1.0];
  }
});
/****************

A choose-y thing

Widget Options:
{name:'direction', type:'choose', options:['left','right'], placeholder:'left'}
// TODO... "options" gets overrided soooo UHHHHH.

****************/

Joy.add({
  type: "choose",
  tags: ["ui"],
  initWidget: function (self) {
    var data = self.data; // Options

    var options = self.options;

    for (var i = 0; i < options.length; i++) {
      // convert to label/value if not already
      var o = options[i];

      if (!(o.label !== undefined && o.value !== undefined)) {
        options[i] = {
          label: o.toString(),
          value: o
        };
      }
    } // ChooserButton *IS* DOM


    var chooserButton = new Joy.ui.ChooserButton({
      value: data.value,
      options: options,
      onchange: function (value) {
        data.value = value;
        self.update(); // you oughta know!
      },
      styles: self.styles
    });
    self.dom = chooserButton.dom;
  },
  onget: function (my) {
    return my.data.value;
  }
});
/****************

A widget to type in strings!

Widget Options:
{name:'name', type:'string', prefix:'&ldquo;', suffix:'&rdquo;', color:"whatever"}

****************/

Joy.add({
  type: "string",
  tags: ["ui"],
  initWidget: function (self) {
    // String *IS* DOM
    var o = self.options;
    self.stringUI = new Joy.ui.String({
      prefix: o.prefix,
      suffix: o.suffix,
      color: o.color,
      value: self.getData("value"),
      onchange: function (value) {
        self.setData("value", value);
      }
    });
    self.dom = self.stringUI.dom; // When data's changed, externally

    self.onDataChange = function () {
      var value = self.getData("value");
      self.stringUI.setString(value);
    };
  },
  onget: function (my) {
    return my.data.value;
  },
  placeholder: "???"
});
/****************

A widget to save data as hash!

Widget Options:
{type:'save'} // NO "id"! It just saves the top-most data.

****************/

Joy.add({
  type: "save",
  tags: ["ui"],
  initWidget: function (self) {
    // DOM
    var dom = document.createElement("div");
    dom.className = "joy-save";
    self.dom = dom; // Save Button

    self.saveButton = new Joy.ui.Button({
      label: "save",
      onclick: function () {
        var url = Joy.saveToURL(self.top.data);
        self.url.setValue(url);
        self.url.select(); // info

        var chars = url.length;
        self.info.innerHTML = "P.S: you can shorten your link with <a href='http://tinyurl.com/' target='_blank'>TinyURL</a>!";
      }
    });
    dom.appendChild(self.saveButton.dom); // URL TextBox

    self.url = new Joy.ui.TextBox({
      readonly: true
    });
    dom.appendChild(self.url.dom); // Details: chars & tinyurl link

    self.info = document.createElement("div");
    self.info.id = "joy-save-info";
    dom.appendChild(self.info);
  }
}); ////////////////////////////////////////////////////////
// THE BIG ACTOR: A "PROGRAMMABLE" LIST OF OPS <3 //
////////////////////////////////////////////////////////

/****************

A nice list of ops.

WidgetConfig:
{type:'ops', name:'ops', resetVariables:false}

****************/

Joy.add({
  type: "ops",
  tags: ["ui"],
  init: function (self) {
    if (self.resetVariables !== undefined) self.data.resetVariables = self.resetVariables; // TODO: ACTUALLY REFACTOR
    // TODO: Separate out Op code from Widget code
    // so that this can run EVEN WITHOUT WIDGETS.
    // Using messages, probably.
  },
  initWidget: function (self) {
    var data = self.data;
    var ops = data.ops; // DOM

    var dom = document.createElement("div");
    dom.className = "joy-ops";
    self.dom = dom; // List

    var list = document.createElement("list");
    list.id = "joy-list";
    dom.appendChild(list); // Preview Variables?

    /*var varPreview;
    if(self.top.canPreview("variables")){
    varPreview = document.createElement("div");
    varPreview.id = "joy-variables-preview";
    varPreview.innerHTML = "AHHHH";
    dom.appendChild(varPreview);
    }*/
    //////////////////////////////////////////
    // Create Bullet /////////////////////////
    //////////////////////////////////////////

    var bulletOptions = [{
      label: "Add op above",
      value: "op_above"
    }, {
      label: "Add op below",
      value: "op_below"
    }, {
      label: "Delete",
      value: "delete"
    }];

    var _onBulletChoice = function (entry, choice) {
      // ACTION ABOVE or BELOW
      var newOpWhere = 0;
      if (choice == "op_above") newOpWhere = -1; // above

      if (choice == "op_below") newOpWhere = 1; // below

      if (newOpWhere != 0) {
        // not NOT new op
        var newEntryIndex = self.entries.indexOf(entry);
        if (newOpWhere > 0) newEntryIndex += 1; // Chooser Modal!

        Joy.modal.Chooser({
          position: "below",
          source: entry.bullet.dom,
          options: opOptions,
          onchange: function (value) {
            _addOp(value, newEntryIndex);

            self.update(); // You oughta know!

            _updateBullets(); // update the UI, re-number it.

          }
        });
      } // DELETE


      if (choice == "delete") {
        _removeFromArray(self.entries, entry); // Delete entry from Entries[]


        _removeFromArray(ops, entry.opData); // Delete op from Data's Ops[]


        self.removeChild(entry.op); // Delete op from Children[]

        list.removeChild(entry.dom); // Delete entry from DOM

        self.update(); // You oughta know!

        _updateBullets(); // update the UI, re-number it.

      }
    };

    var _createBullet = function (entry) {
      var bullet = new Joy.ui.ChooserButton({
        position: "below",
        staticLabel: _getBulletLabel(entry),
        options: bulletOptions,
        onchange: function (choice) {
          _onBulletChoice(entry, choice);
        },
        styles: ["joy-bullet"]
      });
      bullet.dom.id = "joy-bullet";
      return bullet;
    }; // Get the digit (or letter, or roman) for this bullet...


    var _getBulletLabel = function (entry) {
      // What index am I?
      var index = self.entries.indexOf(entry) + 1; // How many levels deep in "ops" am I?

      var levelsDeep = 0;
      var parent = self.parent;

      while (parent) {
        if (parent.type == "ops") levelsDeep++;
        parent = parent.parent;
      } // Digit, Letter, or Roman? (Cycle around)


      var label;

      switch (levelsDeep % 3) {
        case 0:
          label = index;
          break;
        // digits

        case 1:
          label = _numberToAlphabet(index);
          break;
        // letter

        case 2:
          label = _numberToRoman(index);
          break;
        // roman
      }

      return label;
    }; // Re-number ALL these bad boys


    var _updateBullets = function () {
      for (var i = 0; i < self.entries.length; i++) {
        var entry = self.entries[i];
        var bullet = entry.bullet;

        var label = _getBulletLabel(entry);

        bullet.setLabel(label);
      }
    }; ////////////////////////////////////////////////////////////////////
    // Add Entry: Entries have a Bullet (the number) & actual widget! //
    ////////////////////////////////////////////////////////////////////


    self.entries = [];

    var _addEntry = function (opData, atIndex) {
      // New entry
      var entry = {};
      var entryDOM = document.createElement("div");
      if (atIndex === undefined) atIndex = self.entries.length;
      self.entries.splice(atIndex, 0, entry);
      list.insertBefore(entryDOM, list.children[atIndex]); // The Bullet is a Chooser!

      var bullet = _createBullet(entry);

      var bulletContainer = document.createElement("div");
      bulletContainer.id = "joy-bullet-container";
      entryDOM.appendChild(bulletContainer);
      bulletContainer.appendChild(bullet.dom); // New Op!

      var newOp = self.addChild({
        type: opData.type
      }, opData); // The Widget

      var newWidget = newOp.createWidget();
      newWidget.id = "joy-widget";
      entryDOM.appendChild(newWidget); // (Remember all this)

      entry.dom = entryDOM;
      entry.bullet = bullet;
      entry.op = newOp;
      entry.widget = newWidget;
      entry.opData = opData; // PREVIEW ON HOVER
      // Also tell the op "_PREVIEW": how far in the op to go?

      var _calculatePreviewParam = function (event) {
        var param = event.offsetY / bullet.dom.getBoundingClientRect().height;
        if (param < 0) param = 0;
        if (param > 1) param = 1;
        _previewOp._PREVIEW = param;
        self.update();
      };

      var _previewOp;

      var _previewStyle;

      bulletContainer.onmouseenter = function (event) {
        if (!self.top.canPreview("ops")) return;
        self.top.activePreview = self; // Create Preview Data

        self.previewData = _clone(self.data);
        var opIndex = self.entries.indexOf(entry);
        _previewOp = self.previewData.ops[opIndex]; // STOP after that op!

        self.previewData.ops.splice(opIndex + 1, 0, {
          STOP: true
        }); // How far to go along op?

        _calculatePreviewParam(event); // Add in a style


        _previewStyle = document.createElement("style");
        document.head.appendChild(_previewStyle);

        _previewStyle.sheet.insertRule(".joy-ops.joy-previewing > #joy-list > div:nth-child(n+" + (opIndex + 2) + ") { opacity:0.1; }");

        _previewStyle.sheet.insertRule(".joy-ops.joy-previewing > div.joy-bullet { opacity:0.1; }");

        dom.classList.add("joy-previewing");
      };

      bulletContainer.onmousemove = function (event) {
        if (self.previewData) _calculatePreviewParam(event);
      };

      bulletContainer.onmouseleave = function () {
        if (self.previewData) {
          self.previewData = null;
          self.top.activePreview = null;
          self.update();
          document.head.removeChild(_previewStyle);
          dom.classList.remove("joy-previewing");
        }
      };

      return entry;
    }; // add all INITIAL ops as widgets


    for (var i = 0; i < ops.length; i++) _addEntry(ops[i]); ///////////////////////////////////////
    // Add Op /////////////////////////
    ///////////////////////////////////////
    // Manually add New Op To Ops + Widgets + DOM


    var _addOp = function (opType, atIndex) {
      // Create that new entry & everything
      var newOp = {
        type: opType
      };

      if (atIndex === undefined) {
        ops.push(newOp);
      } else {
        ops.splice(atIndex, 0, newOp);
      }

      var entry = _addEntry(newOp, atIndex); // Focus on that entry's widget!
      // entry.widget.focus();

    }; // Ops you can add:
    // TODO: INCLUDE ALIASED OPS


    var opOptions = [];

    if (self.onlyOps) {
      for (var i = 0; i < self.onlyOps.length; i++) {
        var opType = self.onlyOps[i];
        var opTemplate = Joy.getTemplateByType(opType);
        var notOpTag = opTemplate.tags.filter(function (tag) {
          return tag != "op"; // first tag that's NOT "op"
        })[0];
        opOptions.push({
          label: opTemplate.name,
          value: opType,
          category: notOpTag
        });
      }
    } else {
      var opOps = Joy.getTemplatesByTag("op");

      for (var i = 0; i < opOps.length; i++) {
        var opOp = opOps[i];
        var notOpTag = opOp.tags.filter(function (tag) {
          return tag != "op";
        })[0];
        opOptions.push({
          label: opOp.name,
          value: opOp.type,
          category: notOpTag
        });
      }
    } // "+" Button: When clicked, prompt what ops to add!


    var addButton = new Joy.ui.ChooserButton({
      staticLabel: "+",
      options: opOptions,
      onchange: function (value) {
        _addOp(value);

        self.update(); // You oughta know!
      },
      styles: ["joy-bullet"]
    });
    dom.appendChild(addButton.dom);
  },
  onexecute: async function (my) {
    // Create _vars, if not already there
    if (!my.target._variables) my.target._variables = {}; // Reset all of target's variables?

    if (my.data.resetVariables) my.target._variables = {}; // Do those ops, baby!!!

    for (var i = 0; i < my.data.ops.length; i++) {
      // Stop?
      var opData = my.data.ops[i];
      if (opData.STOP) return "STOP"; // Run

      var op = my.op.entries[i].op; // TODO: THIS IS A HACK AND SHOULD NOT RELY ON THAT

      var result = await op.execute(my.target, opData); // use ol' op, but GIVEN data.

      if (result && result.target) {
        my.target = result.target;
      } else if (result && result.error) {
        console.error("ops stopped with error: ", result);
        return result;
      } else if (result && result.stop) {
        console.log("ops interrupted at step ", i, result);
        return result;
      } else if (result == "STOP") return result;
    }

    return my;
  },
  placeholder: {
    ops: [],
    resetVariables: true
  }
}); /////////////////////////////////////////
// LOGIC ACTORS /////////////////////////
/////////////////////////////////////////

Joy.module("instructions", function () {
  Joy.add({
    name: "Repeat the following...",
    type: "instructions/repeat",
    tags: ["instructions", "op"],
    init: "Repeat the following {id:'count', type:'number', min:1, placeholder:3} times: " + "{id:'ops', type:'ops', resetVariables:false}",
    onexecute: async function (my) {
      // Previewing? How much to preview?
      var param = 1;
      if (my.data._PREVIEW !== undefined) param = my.data._PREVIEW; // Loop through it... (as far as preview shows, anyway)

      var loops = Math.floor(my.data.count * param);

      for (var i = 0; i < loops; i++) {
        var result = await my.op.ops.execute(my.target);

        if (result && result.target) {
          my.target = result.target;
        } else if (result.error) {
          console.error("op stopped with error: ", result);
          return result;
        } else if (result.stop) {
          console.log("op interrupted at step ", i, result);
          return result;
        } else if (result == "STOP") return result; // STOP

      }

      return my;
    }
  });
  /*Joy.add({
  name: "If... then...",
  type: "instructions/if",
  tags: ["instructions", "op"],
  init: "If AHHH, then: "+
  	  "{id:'ops', type:'ops', resetVariables:false}",
  onexecute: function(my){
  	var message = my.op.ops.execute(my.target);
  	if(message=="STOP") return message; // STOP
  }
  });*/

  Joy.add({
    name: "// Write a note",
    type: "instructions/comment",
    tags: ["instructions", "op"],
    initWidget: function (self) {
      // DOM
      self.dom = document.createElement("div"); // Comment Box

      self.box = new Joy.ui.TextBox({
        multiline: true,
        placeholder: "// your notes here",
        value: self.getData("value"),
        onchange: function (value) {
          self.setData("value", value);
        },
        styles: ["box"]
      });
      self.dom.appendChild(self.box.dom);
    }
  });
}); // VARIABLE NAME: you're just a synchronized string, yo.

Joy.add({
  type: "variableName",
  tags: ["ui"],
  init: function (self) {
    var variableType = self.variableType; // Unique Variable Name

    var _uniqueVariableName = function () {
      var varnames = Joy.getReferencesByTag(self, variableType).map(function (ref) {
        return ref.data.value;
      });
      var highestCount = 0;
      varnames.forEach(function (varname) {
        var num;
        if (varname == "variable") num = 1; // at least 1

        var match = varname.match(/variable\\s(\\d+)/);
        if (match) num = parseInt(match[1]); // or more

        if (highestCount < num) highestCount = num;
      });
      if (highestCount == 0) return "variable";else return "variable " + (highestCount + 1);
    }; // Create Reference method


    self._createNewReference = function () {
      var refData = {
        value: _uniqueVariableName(),
        color: _randomHSV()
      };
      var ref = Joy.createReference(self, variableType, refData);
      self.setData("refID", ref.id, true); // Remember Ref ID. And DON'T update.

      Joy.connectReference(self, ref.id); // connect new ref
    }; // Do I already have a reference? Create one if no.


    var refID = self.getData("refID");

    if (refID) {
      Joy.connectReference(self, refID); // connect this ref
    } else {
      // Well, first try seeing if there are any vars.
      // If so, connect to most recently created one
      var varReferences = Joy.getReferencesByTag(self, variableType); // CONFIG: self.startWithExisting!

      if (self.startWithExisting && varReferences.length > 0) {
        var latestReference = varReferences[varReferences.length - 1];
        refID = latestReference.id;
        self.setData("refID", refID, true); // set data

        Joy.connectReference(self, refID); // connect this ref
      } else {
        // Otherwise, make a new one!
        self._createNewReference();
      }
    } // Switch reference


    self._switchReference = function (newRefID) {
      var refID = self.getData("refID");
      Joy.disconnectReference(self, refID); // disconnect old ref

      self.setData("refID", newRefID); // DO update this!

      Joy.connectReference(self, newRefID); // connect new ref
    };
  },
  initWidget: function (self) {
    self.dom = document.createElement("span"); // The String edits my REFERENCE'S data.

    var refID = self.getData("refID");
    var refData = Joy.getReferenceById(self, refID).data;
    var stringOp = self.addChild({
      type: "string",
      prefix: "[",
      suffix: "]",
      color: refData.color
    }, refData);
    var stringWidget = stringOp.createWidget();
    self.dom.appendChild(stringWidget); // This String Op also updates its color

    var _old_stringOp_onDataChange = stringOp.onDataChange;

    stringOp.onDataChange = function () {
      _old_stringOp_onDataChange();

      var color = stringOp.getData("color");
      stringOp.stringUI.setColor(color);
    }; // Chooser? Can choose to switch to other variables (or make new one)


    var variableType = self.variableType;

    var _showChooser = function () {
      var options = []; // Get all references that are of this type

      var refs = Joy.getReferencesByTag(self, variableType);
      var myRefID = self.getData("refID");
      refs.forEach(function (ref) {
        if (ref.id == myRefID) return; // don't show SELF

        var color = ref.data.color;
        color = _HSVToRGBString(color[0], color[1], color[2]);
        options.push({
          label: "[" + ref.data.value + "]",
          value: ref.id,
          color: color
        });
      }); // Meta Options:

      options.push({
        category: "meta",
        label: "(+new)",
        value: "NEW"
      });
      options.push({
        category: "meta",
        label: "(change color)",
        value: "CHANGE_COLOR"
      }); // Show all possible variables!

      Joy.modal.Chooser({
        source: self.dom,
        options: options,
        onchange: function (newRefID) {
          if (newRefID == "CHANGE_COLOR") {
            // Just change color, ha.
            Joy.modal.Color({
              source: self.dom,
              value: stringOp.getData("color"),
              onchange: function (newColor) {
                stringOp.setData("color", newColor);
                stringOp.stringUI.setColor(newColor); // do this again coz edit lock
              }
            });
          } else {
            // Make a new reference? Either way, set refID
            if (newRefID == "NEW") {
              var oldRefID = self.getData("refID");
              Joy.disconnectReference(self, oldRefID); // disconnect old ref

              self._createNewReference();

              self.update(); // update, yo
            } else {
              self._switchReference(newRefID);
            } // Make String Widget edit that instead


            var refID = self.getData("refID");
            var ref = Joy.getReferenceById(self, refID);
            stringOp.switchData(ref.data);
          }
        }
      });
    }; // Show ON CLICK!


    if (!self.noChooser) {
      self.dom.onclick = _showChooser;
    }
  },
  onget: function (my) {
    var refID = my.data.refID;
    var ref = Joy.getReferenceById(my.op, refID);
    return ref.data.value; // returns the variable name
  },
  onkill: function (self) {
    // Disconnect any references I may have
    var refID = self.getData("refID");
    Joy.disconnectReference(self, refID); // disconnect old ref
  }
}); /////////////////////////////////////////
// MATH ACTORS //////////////////////////
/////////////////////////////////////////

Joy.module("math", function () {
  /*********************
  Alright. This is gonna be a big one.
  It needs to be able to chain math elements,
  and each element needs to be able to switch between
  scrubbers, variables, and other number-getter ops.
  Data:
  {
  type: "number",
  chain:[
  	{type:"number_raw", value:3},
  	{type:"choose", value:"*"},
  	{type:"variableName", refID:whatever},
  	{type:"choose", value:"+"},
  	{type:"turtle/getAngle"}
  ]
  }
  *********************/
  Joy.modify("number", "number_raw", function (_old) {
    return {
      init: function (self) {
        // no variables?
        if (self.noVariables) return; // Force data to a chain...

        var originalValue = self.getData("value");

        if (typeof originalValue === "number") {
          self.setData("value", undefined, true); // delete "value", no update

          self.setData("chain", [{
            type: "number_raw",
            min: self.min,
            max: self.max,
            step: self.step,
            value: originalValue
          }], true); // create "chain", no update
        } // MAKE A NEW CHAIN ACTOR *AND DATA(?)*


        self._makeNewChainOp = function (chainItem, atIndex) {
          // Make it
          var chainOp;
          var type = chainItem.type;

          switch (type) {
            // Elements
            case "number_raw":
              chainOp = self.addChild({
                type: type,
                min: chainItem.min,
                max: chainItem.max,
                step: chainItem.step
              }, chainItem);
              break;

            case "variableName":
              chainOp = self.addChild({
                type: type,
                variableType: "number",
                noChooser: true
              }, chainItem);
              break;
            // Operand

            case "choose":
              chainOp = self.addChild({
                type: type,
                options: [{
                  label: "+",
                  value: "+"
                }, {
                  label: "-",
                  value: "-"
                }, {
                  label: "&times;",
                  value: "*"
                }, {
                  label: "&divide;",
                  value: "/"
                }],
                styles: ["joy-math"]
              }, chainItem);
              break;
          } // Add or splice to Chain Ops array! *AND THE DATA*


          var chain = self.getData("chain");

          if (atIndex !== undefined) {
            self.chainOps.splice(atIndex, 0, chainOp);
            chain.splice(atIndex, 0, chainItem);
          } else {
            self.chainOps.push(chainOp);
            chain.push(chainItem);
          } // Return


          return chainOp;
        }; // Create an op for each element in the chain


        self.chainOps = []; // keep a chain parallel to children. this one's in ORDER.

        var realChain = self.getData("chain");

        var chain = _clone(realChain);

        realChain.splice(0, realChain.length); // empty out realChain

        for (var i = 0; i < chain.length; i++) {
          self._makeNewChainOp(chain[i]);
        } // REPLACE A CHAIN ACTOR *AND DATA*


        self._replaceChainOp = function (oldChainOp, newItem) {
          // Delete old op, and add new op where it was
          var oldIndex = self._deleteChainOp(oldChainOp);

          var newChainOp = self._makeNewChainOp(newItem, oldIndex); // update manually!


          self.update(); // Return

          return newChainOp;
        }; // DELETE A CHAIN ACTOR *AND DATA*


        self._deleteChainOp = function (chainOp) {
          // Delete op
          var oldIndex = self.chainOps.indexOf(chainOp);

          _removeFromArray(self.chainOps, chainOp);

          self.removeChild(chainOp); // and data!

          var chain = self.getData("chain");
          chain.splice(oldIndex, 1); // so can re-use index

          return oldIndex;
        };
      },
      initWidget: function (self) {
        // no variables?
        if (self.noVariables) {
          _old.initWidget(self);

          return;
        } // Container!


        self.dom = document.createElement("span");
        self.dom.className = "joy-number"; // Show Chooser!

        var _showChooser = function (chainOp) {
          var options = []; // Show placeholder number (unless i'm a number_raw, or there isn't one)

          if (chainOp.type != "number_raw") {
            var placeholderNumber = self.placeholder.value;

            if (typeof placeholderNumber === "number") {
              options.push({
                label: placeholderNumber,
                value: {
                  type: "number_raw",
                  value: placeholderNumber
                }
              });
            }
          } // Show possible variables (except the current variable)


          var refs = Joy.getReferencesByTag(self, "number");
          var myRefID;
          if (chainOp.type == "variableName") myRefID = chainOp.getData("refID");
          refs.forEach(function (ref) {
            if (ref.id == myRefID) return; // don't show SELF

            var color = ref.data.color;
            color = _HSVToRGBString(color[0], color[1], color[2]);
            options.push({
              label: "[" + ref.data.value + "]",
              value: {
                type: "variableName",
                refID: ref.id
              },
              color: color
            });
          }); // Show all these dang options!

          if (options.length > 0) {
            Joy.modal.Chooser({
              source: chainOp.dom,
              options: options,
              onchange: function (newItem) {
                // REPLACE CHAIN ACTOR & ENTRY
                var newChainOp = self._replaceChainOp(chainOp, newItem);

                self._replaceChainEntry(chainOp, newChainOp);
              }
            });
          }
        }; // THE WAY TO ORGANIZE THIS: ENTRIES that have DOM *and* ACTOR


        self._chainEntries = []; // MAKE CHAIN ENTRY

        self._makeChainEntry = function (chainOp, atIndex) {
          // Widget
          var widget = document.createElement("span");
          chainOp.createWidget();
          widget.appendChild(chainOp.dom); // Widget chooser, if NOT an operand

          if (chainOp.type != "choose") {
            var entry;
            var moreButton = new Joy.ui.Button({
              onclick: function () {
                _showChainOptions(entry);
              },
              styles: ["joy-more"]
            });
            widget.appendChild(moreButton.dom);
          } // Place in widget


          if (atIndex !== undefined) {
            if (atIndex < self.dom.childNodes.length) {
              // replacing NOT at last child...
              var beforeThisWidget = self.dom.childNodes[atIndex];
              self.dom.insertBefore(widget, beforeThisWidget);
            } else {
              // Otherwise just append
              self.dom.appendChild(widget);
            }
          } else {
            self.dom.appendChild(widget);
          } // If it's NOT an operand, clicking it reveals options


          if (chainOp.type != "choose") {
            (function (ca) {
              // HACK: click, NOT scrub. detect w/ time frame
              var _mouseDownTime;

              ca.dom.addEventListener("mousedown", function () {
                _mouseDownTime = +new Date();
              });
              ca.dom.addEventListener("mouseup", function () {
                var _time = +new Date();

                if (_time - _mouseDownTime < 500) {
                  _showChooser(ca); // if clicked in less than a half second

                }
              });
            })(chainOp);
          } // Entry


          entry = {
            widget: widget,
            op: chainOp
          };

          if (atIndex !== undefined) {
            self._chainEntries.splice(atIndex, 0, entry);
          } else {
            self._chainEntries.push(entry);
          }
        }; // DELETE CHAIN ENTRY


        self._deleteChainEntry = function (chainOp) {
          // Get index (so can return later)
          var entry = self._chainEntries.find(function (entry) {
            return entry.op == chainOp;
          });

          var index = self._chainEntries.indexOf(entry); // Delete widget & entry (op's already been deleted)


          var widget = entry.widget;
          self.dom.removeChild(widget);

          _removeFromArray(self._chainEntries, entry); // Index?


          return index;
        }; // REPLACE CHAIN ENTRY


        self._replaceChainEntry = function (oldChainOp, newChainOp) {
          var oldIndex = self._deleteChainEntry(oldChainOp);

          self._makeChainEntry(newChainOp, oldIndex);
        }; // SHOW CHAIN OPTIONS


        var _showChainOptions = function (entry) {
          // Possible operands
          var currentLabel = entry.widget.innerText;
          var options = [{
            label: currentLabel + " + 2",
            value: "+"
          }, {
            label: currentLabel + " - 2",
            value: "-"
          }, {
            label: currentLabel + " &times; 2",
            value: "*"
          }, {
            label: currentLabel + " &divide; 2",
            value: "/"
          }]; // To delete... which operand?

          var elementIndex = self._chainEntries.indexOf(entry);

          if (self._chainEntries.length > 1) {
            // can't delete if just one
            // The operand...
            var operandIndex;
            if (elementIndex == 0) operandIndex = elementIndex + 1; // first
            else operandIndex = elementIndex - 1; // not
            // Label

            var label;
            var operandLabel = self._chainEntries[operandIndex].widget.innerText;
            if (elementIndex == 0) label = currentLabel + " " + operandLabel; // first
            else label = operandLabel + " " + currentLabel; // not
            // Indices to delete

            var indicesToDelete = [elementIndex, operandIndex].sort(); // increasing order
            // Push option!

            options.push({
              category: "meta",
              label: "(delete " + label + ")",
              value: indicesToDelete
            });
          } // Choose options!


          Joy.modal.Chooser({
            source: entry.widget,
            options: options,
            onchange: function (operand) {
              // It's an operand...
              if (typeof operand === "string") {
                // Get index of the op...
                var index = self._chainEntries.indexOf(entry); // Make the OPERAND op(+data) & entry


                index++;

                var operandOp = self._makeNewChainOp({
                  type: "choose",
                  value: operand
                }, index);

                self._makeChainEntry(operandOp, index); // Make the NUMBER op(+data) & entry (just the number 2, why hot)


                index++;

                var numberOp = self._makeNewChainOp({
                  type: "number_raw",
                  value: 2
                }, index);

                self._makeChainEntry(numberOp, index);
              } else {
                // Otherwise, DELETE ACTOR & ENTRY!
                var indices = operand;

                for (var i = indices.length - 1; i >= 0; i--) {
                  // flip around coz DELETING
                  var indexToDelete = indices[i];
                  var opToDelete = self._chainEntries[indexToDelete].op;

                  self._deleteChainOp(opToDelete);

                  self._deleteChainEntry(opToDelete);
                }
              } // Update!


              self.update();
            }
          });
        }; // For each chain op, put in that entry


        for (var i = 0; i < self.chainOps.length; i++) {
          var chainOp = self.chainOps[i];

          self._makeChainEntry(chainOp);
        }
      },
      onget: function (my) {
        // no variables?
        if (my.op.noVariables) {
          return _old.onget(my);
        } ////////////////


        var nums_and_ops = []; // just gets chain of nums & ops
        // EVALUATE EACH ELEMENT FIRST

        for (var i = 0; i < my.data.chain.length; i += 2) {
          // Synched indices!
          var chainOp = my.op.chainOps[i]; // Evaluate element

          var num;

          switch (chainOp.type) {
            case "number_raw":
              num = chainOp.get(my.target);
              break;

            case "variableName":
              var _variables = my.target._variables;
              var varname = chainOp.get(my.target); // it's just a synchronized string

              num = _variables[varname];
              break;
          } // Any operator before it?


          if (i > 0) {
            var operandOp = my.op.chainOps[i - 1];
            var op = operandOp.get();
            nums_and_ops.push(op);
          } // Push num


          nums_and_ops.push(num);
        } // MULTIPLICATION AND DIVISION FIRST. LEFT-ASSOCIATIVE


        for (var i = 1; i < nums_and_ops.length; i += 2) {
          var op = nums_and_ops[i];

          if (op == "*" || op == "/") {
            // Do math to the two numbers
            var num1 = nums_and_ops[i - 1];
            var num2 = nums_and_ops[i + 1];
            var res;
            if (op == "*") res = num1 * num2;else res = num1 / num2; // Modify array, and set index back
            // remove 3 items: num1, op, num2
            // replace with 1 item: result

            nums_and_ops.splice(i - 1, 3, res);
            i -= 2;
          } else {
            continue;
          }
        } // NOW DO ADDITION AND SUBTRACTION


        for (var i = 1; i < nums_and_ops.length; i += 2) {
          var op = nums_and_ops[i];

          if (op == "+" || op == "-") {
            // Do math to the two numbers
            var num1 = nums_and_ops[i - 1];
            var num2 = nums_and_ops[i + 1];
            var res;
            if (op == "+") res = num1 + num2;else res = num1 - num2; // Modify array, and set index back
            // remove 3 items: num1, op, num2
            // replace with 1 item: result

            nums_and_ops.splice(i - 1, 3, res);
            i -= 2;
          } else {
            continue;
          }
        }

        return nums_and_ops[0];
      }
    };
  });
  /****************
  Set a variable to some number.
  ****************/

  Joy.add({
    name: "Set [number]",
    type: "math/set",
    tags: ["math", "op"],
    init: "Set {id:'varname', type:'variableName', variableType:'number'} to {id:'value', type:'number'}",
    onexecute: function (my) {
      var _variables = my.target._variables;
      var varname = my.data.varname; // it's just a synchronized string

      _variables[varname] = my.data.value; // Set the variable
    }
  });
  /****************
  Do math on some variable
  ****************/

  Joy.add({
    name: "Do math to [number]",
    type: "math/operation",
    tags: ["math", "op"],
    init: JSON.stringify({
      id: "operation",
      type: "choose",
      placeholder: "+",
      options: [{
        label: "+ Increase",
        value: "+"
      }, {
        label: "- Decrease",
        value: "-"
      }, {
        label: "&times; Multiply",
        value: "*"
      }, {
        label: "&divide; Divide",
        value: "/"
      }]
    }) + " {id:'varname', type:'variableName', variableType:'number', startWithExisting:true}" + " by {id:'value', type:'number'}",
    onexecute: function (my) {
      var vars = my.target._variables;
      var varname = my.data.varname;
      if (vars[varname] === undefined) vars[varname] = 0; // Set to 0, if nothing's there.

      switch (my.data.operation) {
        case "+":
          vars[varname] += my.data.value;
          break;

        case "-":
          vars[varname] -= my.data.value;
          break;

        case "*":
          vars[varname] *= my.data.value;
          break;

        case "/":
          vars[varname] /= my.data.value;
          break;
      }
    }
  });
  /****************
  If then... for math
  ****************/

  Joy.add({
    name: "If [math] then...",
    type: "math/if",
    tags: ["math", "op"],
    init: "If {id:'value1', type:'number'} " + "{id:'test', type:'choose', options:['<','','=','','>'], placeholder:'='} " + "{id:'value2', type:'number'}, then: " + "{id:'ops', type:'ops', resetVariables:false}",
    onexecute: function (my) {
      var value1 = my.data.value1;
      var value2 = my.data.value2;
      var result;

      switch (my.data.test) {
        case "<":
          result = value1 < value2;
          break;

        case "":
          result = value1 <= value2;
          break;

        case "=":
          result = value1 == value2;
          break;

        case "":
          result = value1 >= value2;
          break;

        case ">":
          result = value1 > value2;
          break;
      }

      if (result) {
        var message = my.op.ops.execute(my.target);
        if (message == "STOP") return message; // STOP
      }
    }
  });
});
Joy.module("random", function () {
  Joy.add({
    name: "With a X% chance...",
    type: "random/if",
    tags: ["random", "op"],
    init: "With a {id:'chance', type:'number', min:0, max:100, placeholder:50}% chance, do:" + "{id:'ops', type:'ops', resetVariables:false}",
    onexecute: function (my) {
      var probability = my.data.chance / 100;

      if (Math.random() < probability) {
        var message = my.op.ops.execute(my.target);
        if (message == "STOP") return message; // STOP
      }
    }
  });
  /****************
  Set a variable to some number.
  ****************/

  Joy.add({
    name: "Set random [number]",
    type: "random/set",
    tags: ["random", "op"],
    init: "Set {id:'varname', type:'variableName', variableType:'number'} to a random " + "{id:'numtype', type:'choose', options:['number','integer'], placeholder:'number'} between " + "{id:'min', type:'number', placeholder:1} and {id:'max', type:'number', placeholder:100}",
    onexecute: function (my) {
      var _variables = my.target._variables;
      var varname = my.data.varname; // it's just a synchronized string

      var _min = my.data.min;
      var _max = my.data.max;
      var min = Math.min(_min, _max); // just in case

      var max = Math.max(_min, _max); // just in case

      var randomValue;

      if (my.data.numtype == "integer") {
        randomValue = min + Math.floor(Math.random() * (max - min + 1));
      } else {
        randomValue = min + Math.random() * (max - min);
      }

      _variables[varname] = randomValue; // Set the variable
    }
  });
});


//# sourceURL=webpack://%5Bname%5D/./src/joy.js?`)},"./src/pluginManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PluginManager", function() { return PluginManager; });
/* harmony import */ var lodash_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/trim */ "./node_modules/lodash/trim.js");
/* harmony import */ var lodash_trim__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_trim__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/assign */ "./node_modules/lodash/assign.js");
/* harmony import */ var lodash_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_assign__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pouchdb-browser */ "./node_modules/pouchdb-browser/lib/index.es.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! spark-md5 */ "./node_modules/spark-md5/spark-md5.js");
/* harmony import */ var spark_md5__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(spark_md5__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! js-yaml */ "./node_modules/js-yaml/index.js");
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(js_yaml__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _joy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./joy.js */ "./src/joy.js");
/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! file-saver */ "./node_modules/file-saver/FileSaver.js");
/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! imjoy-rpc */ "./node_modules/imjoy-rpc/index.js");
/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(imjoy_rpc__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./jailedPlugin.js */ "./src/jailedPlugin.js");
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./api.js */ "./src/api.js");
/* harmony import */ var _serviceSpec_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./serviceSpec.js */ "./src/serviceSpec.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _internalPlugins_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./internalPlugins.json */ "./src/internalPlugins.json");
var _internalPlugins_json__WEBPACK_IMPORTED_MODULE_13___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./internalPlugins.json */ "./src/internalPlugins.json", 1);
/* harmony import */ var _pluginParser_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pluginParser.js */ "./src/pluginParser.js");



/*eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_plugin$" }]*/















const compiledServiceSpec = {};

for (let k of Object.keys(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_11__["serviceSpec"])) {
  try {
    const key = k.startsWith("@") ? k : "@" + k;
    compiledServiceSpec[key] = _api_js__WEBPACK_IMPORTED_MODULE_10__["ajv"].compile(_serviceSpec_js__WEBPACK_IMPORTED_MODULE_11__["serviceSpec"][k]);
  } catch (e) {
    console.error(e);
    throw new Error(\`Failed to compile service spec for \${k}, error: \${e}\`);
  }
}

class PluginManager {
  constructor({
    event_bus = null,
    config_db = null,
    engine_manager = null,
    window_manager = null,
    file_manager = null,
    imjoy_api = {},
    default_base_frame = null,
    default_rpc_base_url = null,
    debug = false,
    flags = []
  }) {
    this.event_bus = event_bus;
    this.em = engine_manager;
    this.em.setPluginManager(this);
    this.wm = window_manager;
    this.fm = file_manager;
    this.fm.setPluginManager(this);
    this.config_db = config_db;
    this.flags = flags;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.event_bus, "event bus is not available");
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.em, "engine manager is not available");
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.wm, "window manager is not available");
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(this.config_db, "config database is not available");
    this.default_base_frame = default_base_frame;
    this.default_rpc_base_url = default_rpc_base_url;
    this.debug = debug;
    this._allowed_evil_plugin = {};
    this.internal_plugins = _internalPlugins_json__WEBPACK_IMPORTED_MODULE_13__;
    this.default_repository_list = [{
      name: "ImJoy Repository",
      url: "imjoy-team/imjoy-plugins",
      description: "The official plugin repository provided by ImJoy.io."
    }, {
      name: "ImJoy Demos",
      url: "imjoy-team/imjoy-demo-plugins",
      description: "A set of demo plugins provided by ImJoy.io"
    }];
    this.repository_list = [];
    this.repository_names = [];
    this.available_plugins = [];
    this.installed_plugins = [];
    this.workspace_list = [];
    this.selected_workspace = null;
    this.selected_repository = null;
    this.workflow_list = [];
    this.service_registry = {};
    this.db = null;
    imjoy_api.utils = imjoy_api.utils || {};
    const api_utils_ = imjoy_api.utils;
    this.imjoy_api = {
      alert: (plugin, msg) => {
        return window.alert(Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["html2string"])(msg.content) || msg);
      },
      prompt: (plugin, msg, default_value) => {
        return window.prompt(Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["html2string"])(msg.content) || msg, msg.placeholder || default_value);
      },
      confirm: (plugin, msg) => {
        return window.confirm(Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["html2string"])(msg.content) || msg);
      },
      requestUploadUrl: this.requestUploadUrl,
      getFileUrl: this.getFileUrl,
      getFilePath: this.getFilePath,
      log: (plugin, ...args) => {
        plugin.log(...args);
        this.event_bus.emit("update_ui");
      },
      error: (plugin, ...args) => {
        plugin.error(...args);
        this.event_bus.emit("update_ui");
      },
      progress: (plugin, value) => {
        plugin.progress(value);
        this.event_bus.emit("update_ui");
      },

      exportFile(_plugin, file, name) {
        if (typeof file === "string") {
          file = new Blob([file], {
            type: "text/plain;charset=utf-8"
          });
        }

        Object(file_saver__WEBPACK_IMPORTED_MODULE_7__["saveAs"])(file, name || file._name || "file_export");
      },

      showDialog() {
        throw "\`api.showDialog\` is not implemented.";
      },

      showFileDialog() {
        throw "\`api.showFileDialog\` is not implemented.";
      },

      showProgress(_plugin, p) {
        console.log("api.showProgress: ", p);
      },

      showStatus(_plugin, s) {
        console.log("api.showStatus: ", s);
      },

      showSnackbar(_plugin, msg, duration) {
        console.log("api.showSnackbar: ", msg, duration);
      },

      showMessage: (plugin, info, duration) => {
        console.log("api.showMessage: ", info, duration);
      },
      register: this.register,
      // deprecated
      unregister: this.unregister,
      // deprecated
      registerService: this.registerService,
      unregisterService: this.unregisterService,
      createWindow: this.createWindow,
      loadPlugin: this.getPlugin,
      getPlugin: this.getPlugin,
      getWindow: this.getWindow,
      run: this.runPlugin,
      call: this.callPlugin,

      connectToServer(_plugin, config) {
        console.warn("api.connectToServer is deprecated.");
        return imjoy_rpc__WEBPACK_IMPORTED_MODULE_8__["imjoyRPCSocketIO"].connectToServer(config);
      },

      installPlugin: (_plugin, config) => {
        const tag = config.tag;
        const do_not_load = config.do_not_load;
        delete config.tag;
        delete config.do_not_load;
        return this.installPlugin(config, tag, do_not_load);
      },
      uninstallPlugin: (_plugin, config) => {
        return this.removePlugin(config);
      },
      getServices: this.getServices,
      getFileManager: this.getFileManager,
      getEngineFactory: this.getEngineFactory,
      getEngine: this.getEngine,
      setConfig: this.setPluginConfig,
      getConfig: this.getPluginConfig,
      getAttachment: this.getAttachment,
      onClose: (plugin, cb) => {
        console.warn('\`api.onClose\` is deprecated, please use \`api.on("close", ...)\` instead.');
        plugin.on("close", cb);
      },
      echo: (plugin, msg) => {
        return msg;
      },
      utils: {}
    }; // bind this to api functions

    for (let k in this.imjoy_api) {
      if (typeof this.imjoy_api[k] === "function") {
        this.imjoy_api[k] = this.imjoy_api[k].bind(this);
      } else if (typeof this.imjoy_api[k] === "object") {
        for (let u in this.imjoy_api[k]) {
          this.imjoy_api[k][u] = this.imjoy_api[k][u].bind(this);
        }
      }
    }

    imjoy_api.utils.showOpenFilePicker = async (plugin, ...args) => {
      if (window.showOpenFilePicker) {
        return await window.showOpenFilePicker(...args);
      } else {
        throw new Error("showOpenFilePicker is not available, please make sure you have Google Chrome 86+");
      }
    };

    imjoy_api.utils.showSaveFilePicker = async (plugin, ...args) => {
      if (window.showSaveFilePicker) {
        return await window.showSaveFilePicker(...args);
      } else {
        throw new Error("showSaveFilePicker is not available, please make sure you have Google Chrome 86+");
      }
    };

    imjoy_api.utils.showDirectoryPicker = async (plugin, ...args) => {
      if (window.showDirectoryPicker) {
        return await window.showDirectoryPicker(...args);
      } else {
        throw new Error("showDirectoryPicker is not available, please make sure you have Google Chrome 86+");
      }
    }; // merge imjoy api


    this.imjoy_api = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, this.imjoy_api, imjoy_api); // copy api utils make sure it was not overwritten

    if (api_utils_) {
      for (let k in api_utils_) {
        this.imjoy_api.utils[k] = api_utils_[k];
      }
    }

    this.imjoy_api.utils = this.imjoy_api.utils || {};

    this.imjoy_api.utils.openUrl = this.imjoy_api.utils.openUrl || ((_plugin, url) => {
      Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(url);
      Object.assign(document.createElement("a"), {
        target: "_blank",
        href: url
      }).click();
    });

    this.imjoy_api.utils.sleep = this.imjoy_api.utils.sleep || ((_plugin, seconds) => {
      Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(seconds);
      return new Promise(resolve => setTimeout(resolve, Math.round(seconds * 1000)));
    });

    this.imjoy_api.utils.$forceUpdate = this.imjoy_api.utils.$forceUpdate || function () {};

    this.event_bus.on("engine_connected", async engine => {
      for (let k in this.plugins) {
        const plugin = this.plugins[k]; // skip connection based plugins

        if (plugin._initialized_from_connection) continue;

        try {
          if (plugin.engine === engine) {
            await this.reloadPlugin(plugin);
          }

          if (plugin.config.engine_mode === "auto" && (plugin._disconnected || plugin.terminating)) {
            await this.reloadPlugin(plugin);
          }

          if (plugin.config.engine_mode === engine.name) {
            await this.reloadPlugin(plugin);
          }
        } catch (e) {
          this.showMessage(e);
        }
      }
    });
    this.event_bus.on("engine_disconnected", async engine => {
      for (let k in this.plugins) {
        const plugin = this.plugins[k];

        if (plugin.engine === engine) {
          this.unloadPlugin(plugin);
        }
      }
    });
  }

  getFileUrl(_plugin, config) {
    console.warn("\`api.getFileUrl\` is deprecated, please use \`api.getFileManager\` (https://imjoy.io/docs/#/api?id=apigetfilemanager) and access \`getFileUrl\` from the file manager.");

    if (typeof config !== "object" || !config.path) {
      throw "You must pass an object contains keys named \`path\` and \`engine\`";
    }

    _plugin = _plugin || this.root_plugin;

    if (config.engine) {
      console.warn("The \`engine\` option for \`api.getFileUrl\` is deprecated, please use \`file_manager\` instead of \`engine\`.");
      config.file_manager = config.engine;
      delete config.engine;
    }

    if (!config.file_manager) {
      throw "Please specify a file manager via the \`file_manager\` option.";
    }

    const manager = this.fm.getFileManagerByUrl(config.file_manager);

    if (!manager) {
      throw \`File manager \${config.file_manager} not found\`;
    }

    if (!manager.connected) {
      this.showMessage(\`File manager (\${manager.url}) is not connected.\`);
      throw \`File manager (\${manager.url}) is not connected.\`;
    }

    return manager.getFileUrl(config);
  }

  requestUploadUrl(_plugin, config) {
    console.warn("\`api.requestUploadUrl\` is deprecated, please use \`api.getFileManager\` (https://imjoy.io/docs/#/api?id=apigetfilemanager) and access \`requestUploadUrl\` from the file manager.");

    if (typeof config !== "object") {
      throw "You must pass an object contains keys named \`engine\` and \`path\` (or \`dir\`, optionally \`overwrite\`)";
    }

    _plugin = _plugin || this.root_plugin;

    if (config.engine) {
      console.warn("The \`engine\` option for \`api.requestUploadUrl\` is deprecated, please use \`file_manager\` instead of \`engine\`.");
      config.file_manager = config.engine;
      delete config.engine;
    }

    if (!config.file_manager) {
      throw "Please specify a file manager via the \`file_manager\` option.";
    }

    const manager = this.fm.getFileManagerByUrl(config.file_manager);

    if (!manager) {
      throw \`File manager \${config.file_manager} not found\`;
    }

    if (!manager.connected) {
      this.showMessage(\`File manager (\${manager.url}) is not connected.\`);
      throw \`File manager (\${manager.url}) is not connected.\`;
    }

    return manager.requestUploadUrl({
      path: config.path,
      overwrite: config.overwrite,
      dir: config.dir
    });
  }

  showMessage(msg) {
    this.event_bus.emit("show_message", msg);
  }

  async init() {
    const config = {};

    if (this.default_base_frame) {
      config.default_base_frame = this.default_base_frame;
    }

    if (this.default_rpc_base_url) {
      config.default_rpc_base_url = this.default_rpc_base_url;
    }

    config.debug = this.debug;

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.ready.then(() => {
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          console.log("Service worker is active and the controller is available, caching internal plugins...");

          for (let pn in this.internal_plugins) {
            this.normalizePluginUrl(this.internal_plugins[pn].uri).then(obj => {
              if (obj.uri) {
                Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["cacheUrlInServiceWorker"])(obj.uri).then(() => {
                  console.log("Internal plugin cached in the service worker", obj.uri);
                }).catch(e => {
                  console.error(e);
                });
              }
            });
          }
        });
      });
    } else {
      console.log("Service workers are not supported.");
    }

    Object(_jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["initializeJailed"])(config);
    this.root_plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"]({
      id: "imjoy-root",
      name: "ImJoy Root Plugin",
      type: "iframe"
    }, this.imjoy_api, null, true);
    this.plugins = {};
    this.plugin_names = {};
    this.registered = {
      ops: {},
      windows: {},
      extensions: {},
      internal_inputs: {},
      inputs: {},
      outputs: {},
      loaders: {},
      engines: {}
    };
  }

  loadRepositoryList() {
    return new Promise((resolve, reject) => {
      this.config_db.get("repository_list").then(doc => {
        this.repository_list = doc.list;

        for (let drep of this.default_repository_list) {
          let found = false;

          for (let repo of this.repository_list) {
            if (repo.url === drep.url && repo.name === drep.name) {
              found = repo;
              break;
            }
          }

          if (!found) {
            this.addRepository(drep);
          }
        }

        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        resolve(this.repository_list);
      }).catch(err => {
        if (err.name != "not_found") {
          console.error("Database Error", err);
        } else {
          console.log("Failed to load repository list", err);
        }

        this.repository_list = this.default_repository_list;
        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        this.config_db.put({
          _id: "repository_list",
          list: this.repository_list
        }, {
          force: true
        }).then(() => {
          resolve(this.repository_list);
        }).catch(() => {
          reject("Failed to load the repository list or save the default repositories.");
        });
        this.saveRepositoryList().then(() => {
          resolve(this.repository_list);
        }).catch(reject);
      });
    });
  }

  saveRepositoryList() {
    return new Promise((resolve, reject) => {
      let _rev = null;
      this.config_db.get("repository_list").then(doc => {
        _rev = doc._rev;
      }).finally(() => {
        this.config_db.put({
          _id: "repository_list",
          _rev: _rev || undefined,
          list: this.repository_list
        }, {
          force: true
        }).then(() => {
          resolve(this.repository_list);
        }).catch(err => {
          this.showMessage("Failed to save repository, database Error:" + err.toString());
          reject("Failed to save repository, database Error:" + err.toString());
        });
      });
    });
  }

  addRepository(repo) {
    return new Promise((resolve, reject) => {
      if (typeof repo === "string") {
        repo = {
          name: repo,
          url: repo,
          description: repo
        };
      }

      if (!(repo.name && repo.url)) {
        reject("You need to provide name and url");
        return;
      }

      this.reloadRepository(repo).then(manifest => {
        repo.name = manifest.name || repo.name;
        repo.description = manifest.description || repo.description;
        const normalizedUrl = repo.url && repo.url.replace("https://github.com/", "").replace("http://github.com/", ""); //remove existing repo if same url already exists

        for (let r of this.repository_list) {
          if (r.url && r.url.replace("https://github.com/", "").replace("http://github.com/", "") === normalizedUrl) {
            // remove it if already exists
            this.repository_list.splice(this.repository_list.indexOf(r), 1);
            this.showMessage("Repository with the same url already exists.");
          }
        } // use repo url if name exists


        for (let r of this.repository_list) {
          if (r.name === repo.name) {
            repo.name = normalizedUrl;
            break;
          }
        }

        if (!(repo.name && repo.url)) {
          reject("You need to provide name and url");
          return;
        }

        this.repository_list.push(repo);
        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        this.saveRepositoryList().then(() => {
          resolve(repo);
        }).catch(reject);
      }).catch(() => {
        if (this.repository_names.indexOf(repo.name) >= 0) this.repository_names.splice(this.repository_names.indexOf(repo.name), 1);
        this.showMessage("Failed to load repository from: " + repo.url);
        reject("Failed to load repository from: " + repo.url);
      });
    });
  }

  removeRepository(repo) {
    return new Promise((resolve, reject) => {
      if (!repo || !(repo.name && repo.url)) {
        reject("You need to provide name and url");
        return;
      }

      let found = false;

      for (let r of this.repository_list) {
        if (r.url === repo.url || r.name === repo.name) {
          found = r;
        }
      }

      if (found) {
        const index = this.repository_list.indexOf(found);
        this.repository_list.splice(index, 1);
        this.repository_names = [];

        for (let r of this.repository_list) {
          this.repository_names.push(r.name);
        }

        this.saveRepositoryList().then(() => {
          this.showMessage(\`Repository has been deleted.\`);
          resolve();
        }).catch(() => {
          this.showMessage(\`Error occured when removing repository.\`);
          reject(\`Error occured when removing repository.\`);
        });
      } else {
        reject("Repository not found: " + repo.name);
      }
    });
  }

  reloadRepository(repo) {
    repo = repo || this.selected_repository;
    return new Promise((resolve, reject) => {
      this.getRepoManifest(repo.url).then(manifest => {
        this.available_plugins = manifest.plugins;

        for (let i = 0; i < this.available_plugins.length; i++) {
          const ap = this.available_plugins[i];
          const ps = this.installed_plugins.filter(p => {
            return ap.name === p.name;
          }); // mark as installed

          if (ps.length > 0) {
            ap.installed = true;
            ap.tag = ps[0].tag;
          }
        }

        this.selected_repository = repo;
        resolve(manifest);
      }).catch(reject);
    });
  }

  loadWorkspaceList() {
    return new Promise((resolve, reject) => {
      this.config_db.get("workspace_list").then(doc => {
        this.workspace_list = doc.list;
        this.selected_workspace = this.workspace_list[0];
        resolve(this.workspace_list);
      }).catch(err => {
        if (err.name != "not_found") {
          console.error("Database Error", err);
        }

        this.workspace_list = ["default"];
        this.config_db.put({
          _id: "workspace_list",
          list: this.workspace_list
        }).then(() => {
          this.selected_workspace = this.workspace_list[0];
          resolve(this.workspace_list);
        }).catch(() => {
          reject("Failed to load Plugin Engine list, database Error:" + err.toString());
        });
      });
    });
  }

  loadWorkspace(selected_workspace) {
    return new Promise((resolve, reject) => {
      selected_workspace = selected_workspace || this.selected_workspace;

      const load_ = () => {
        try {
          this.event_bus.emit("workspace_list_updated", this.workspace_list);
          this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](selected_workspace + "_workspace", {
            revs_limit: 2,
            auto_compaction: true
          });
          this.selected_workspace = selected_workspace;
          resolve();
        } catch (e) {
          reject(e);
        }
      };

      if (!this.workspace_list.includes(selected_workspace)) {
        if (!this.workspace_list.includes(selected_workspace)) {
          this.workspace_list.push(selected_workspace);
        }

        this.saveWorkspaceList().then(() => {
          load_();
        }).catch(reject);
      } else {
        load_();
      }
    });
  }

  saveWorkspaceList() {
    return new Promise((resolve, reject) => {
      this.config_db.get("workspace_list").then(doc => {
        this.config_db.put({
          _id: doc._id,
          _rev: doc._rev,
          list: this.workspace_list,
          default: "default"
        }).then(resolve).catch(e => {
          reject(\`Failed to save workspace, database Error: \${e.toString()}\`);
        });
      }).catch(err => {
        reject(\`Failed to save workspaces, database Error: \${err.toString()}\`);
      });
    });
  }

  removeWorkspace(w) {
    return new Promise((resolve, reject) => {
      if (this.workspace_list.includes(w)) {
        const index = this.workspace_list.indexOf(w);
        this.workspace_list.splice(index, 1);
        this.saveWorkspaceList().then(() => {
          resolve();

          if (this.selected_workspace === w.name) {
            this.selected_workspace = null;
          }
        }).catch(reject);
      }
    });
  }

  saveWorkflow(joy) {
    // remove if exists
    const name = prompt("Please enter a name for the workflow", "default");

    if (!name) {
      return;
    }

    const data = {};
    data.name = name;
    data._id = name + "_workflow"; // delete data._references

    data.workflow = JSON.stringify(joy.top.data);
    this.db.get(data._id).then(doc => {
      data._rev = doc._rev;
    }).finally(() => {
      this.db.put(data).then(() => {
        this.workflow_list.push(data);
        this.showMessage(\`Workflow "\${name}" has been successfully saved.\`);
      }).catch(err => {
        this.showMessage("Failed to save the workflow.");
        console.error(err);
      });
    });
  }

  async removeWorkflow(w) {
    try {
      const doc = await this.db.get(w._id);
      await this.db.remove(doc);
      var index = this.workflow_list.indexOf(w);

      if (index > -1) {
        this.workflow_list.splice(index, 1);
      }

      this.showMessage(\`Workflow "\${w.name}" has been successfully removed.\`);
    } catch (err) {
      this.showMessage("Failed to remove the workflow.");
      console.error(err);
      throw err;
    }
  }

  reloadDB() {
    return new Promise((resolve, reject) => {
      try {
        if (this.db) {
          try {
            this.db.close().finally(() => {
              this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
                revs_limit: 2,
                auto_compaction: true
              });

              if (this.db) {
                if (this.selected_workspace === "sandbox") {
                  console.warn("All data in the sandbox stored workspace is going to be destroyed.");
                  if (!this.flags.includes("quiet")) debugger;
                  this.db.destroy().then(() => {
                    this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
                      revs_limit: 2,
                      auto_compaction: true
                    });
                    resolve();
                  }).catch(e => {
                    console.error(e);
                    reject(e);
                  });
                } else {
                  resolve();
                }
              } else {
                reject("Failed to reload database.");
              }
            });
          } catch (e) {
            console.error("Failed to reload database: ", e);
            this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
              revs_limit: 2,
              auto_compaction: true
            });

            if (this.db) {
              if (this.selected_workspace === "sandbox") {
                console.warn("All data in the sandbox stored workspace is going to be destroyed.");
                if (!this.flags.includes("quiet")) debugger;
                this.db.destroy().then(() => {
                  this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
                    revs_limit: 2,
                    auto_compaction: true
                  });
                  resolve();
                }).catch(e => {
                  console.error(e);
                  reject(e);
                });
              } else {
                resolve();
              }
            } else {
              reject("Failed to reload database.");
            }
          }
        } else {
          this.db = new pouchdb_browser__WEBPACK_IMPORTED_MODULE_2__["default"](this.selected_workspace + "_workspace", {
            revs_limit: 2,
            auto_compaction: true
          });

          if (this.db) {
            resolve();
          } else {
            reject("Failed to reload database.");
          }
        }
      } catch (e) {
        console.error("Failed to reload database.");
        reject("Failed to reload database.");
      }
    });
  }

  setInputLoaders(input_loaders) {
    for (let inputs of input_loaders) {
      this.wm.registerInputLoader(inputs.loader_key, inputs, inputs.loader);
    }
  }

  reloadPlugins() {
    return new Promise((resolve, reject) => {
      if (this.plugins) {
        for (let k in this.plugins) {
          const plugin = this.plugins[k];

          if (typeof plugin.terminate === "function") {
            try {
              plugin.terminate().then(() => {
                this.event_bus.emit("update_ui");
              });
            } catch (e) {
              console.error(e);
            }
          }

          this.plugins[k] = null;
          this.plugin_names[plugin.name] = null;
        }
      }

      this.init().then(() => {
        this.reloadDB().then(() => {
          this.db.allDocs({
            include_docs: true,
            attachments: true,
            sort: "name"
          }).then(result => {
            this.workflow_list = [];
            this.installed_plugins = [];

            for (let i = 0; i < result.total_rows; i++) {
              const config = result.rows[i].doc;

              if (config.workflow) {
                this.workflow_list.push(config);
              } else {
                //verify hash
                if (config.hash) {
                  if (spark_md5__WEBPACK_IMPORTED_MODULE_3___default.a.hash(config.code) !== config.hash) {
                    console.error("Plugin source code signature mismatch, skip loading plugin", config);
                    continue;
                  }
                }

                config.installed = true;
                this.installed_plugins.push(config);

                try {
                  this.reloadPlugin(config);
                } catch (e) {
                  console.error(config, e);
                  this.showMessage(\`<\${config.name}>: \${e}\`);
                }
              }
            }

            this.reloadInternalPlugins(true).then(resolve).catch(reject);
          }).catch(err => {
            console.error(err);
            reject();
          });
        });
      }).catch(reject);
    });
  }

  async reloadInternalPlugins(skip_exist) {
    for (let pn in this.internal_plugins) {
      const config = this.internal_plugins[pn];

      if (config.startup) {
        if (skip_exist && this.plugin_names[pn]) {
          continue;
        }

        console.log(\`Loading internal plugin "\${pn}"...\`);

        try {
          await this.reloadPluginRecursively({
            uri: config.src
          }, null, "eval is evil");
          console.log(\`\${pn} plugin loaded.\`);
        } catch (e) {
          console.error(e);
        }
      }
    }
  }

  async normalizePluginUrl(uri, scoped_plugins) {
    let external = false;
    let selected_tag;
    scoped_plugins = scoped_plugins || this.available_plugins;
    const _uri = uri.split("?")[0];

    if (_uri.includes("github.com") && _uri.includes("/blob/") || _uri.includes("gist.github.com")) {
      uri = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubUrlRaw"])(uri);
    } // if the uri format is REPO_NAME:PLUGIN_NAME


    if (!/(http(s?)):\\/\\//i.test(uri) && uri.includes("/") && uri.includes(":")) {
      let [repo_name, plugin_name] = uri.split(":");
      selected_tag = plugin_name.split("@")[1];
      plugin_name = plugin_name.split("@")[0];
      plugin_name = plugin_name.trim();
      const repo_hashtag = repo_name.split("@")[1];
      repo_name = repo_name.split("@")[0];
      repo_name = repo_name.trim();
      Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["assert"])(repo_name && plugin_name, 'Wrong URI format, it must be "REPO_NAME:PLUGIN_NAME"');
      const manifest = await this.getRepoManifest(repo_name, repo_hashtag);
      let found = null;

      for (let p of manifest.plugins) {
        if (p.name === plugin_name) {
          found = p;
          break;
        }
      }

      if (!found) {
        throw \`plugin not found \${repo_name}:\${plugin_name}\`;
      }

      uri = found.uri;
      scoped_plugins = manifest.plugins;
    } else if (!uri.match(_utils_js__WEBPACK_IMPORTED_MODULE_12__["url_regex"])) {
      let dep = uri.split("@");
      selected_tag = dep[1];
      const ps = scoped_plugins.filter(p => {
        return dep[0] && p.name === dep[0].trim();
      });

      if (ps.length <= 0) {
        throw \`Plugin "\${dep[0]}" cannot be found in the repository.\`;
      } else {
        uri = ps[0].uri;
      }
    } else {
      if (!_uri.endsWith(".imjoy.html")) {
        external = true;
      }

      selected_tag = uri.split(".imjoy.html@")[1];

      if (selected_tag) {
        uri = uri.split("@" + selected_tag)[0];
      }
    }

    return {
      uri,
      scoped_plugins,
      selected_tag,
      external
    };
  }

  async getPluginFromUrl(uri, scoped_plugins) {
    const obj = await this.normalizePluginUrl(uri, scoped_plugins);

    if (obj.external) {
      const pluginConfig = await Object(_jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["getExternalPluginConfig"])(uri);
      pluginConfig.badges = this.getBadges(pluginConfig);
      return pluginConfig;
    }

    uri = obj.uri;
    scoped_plugins = obj.scoped_plugins;
    const selected_tag = obj.selected_tag; // If the url has no query parameter, then add random query string to avoid browser caching

    if (uri.indexOf("?") === -1) {
      uri = uri + "?" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
    }

    const response = await axios__WEBPACK_IMPORTED_MODULE_4___default.a.get(uri);

    if (!response || !response.data || response.data === "") {
      alert("failed to get plugin code from " + uri);
      throw "failed to get code.";
    }

    const code = response.data;
    let config = this.parsePluginCode(code, {
      tag: selected_tag,
      origin: uri,
      uri: uri
    });
    config.scoped_plugins = scoped_plugins;
    return config;
  }

  reloadPluginRecursively(pconfig, tag, allow_evil) {
    return new Promise((resolve, reject) => {
      let uri = typeof pconfig === "string" ? pconfig : pconfig.uri;
      let scoped_plugins = this.available_plugins;

      if (pconfig.scoped_plugins) {
        scoped_plugins = pconfig.scoped_plugins;
        delete pconfig.scoped_plugins;
      } //use the has tag in the uri if no hash tag is defined.


      if (!uri) {
        reject("No url found for plugin " + pconfig.name);
        return;
      } // tag = tag || uri.split('@')[1]
      // uri = uri.split('@')[0]


      this.getPluginFromUrl(uri, scoped_plugins).then(async config => {
        if (pconfig.engine_mode) {
          config.engine_mode = pconfig.engine_mode;
        } else if (config.engine_mode) {
          const old_plugin = this.plugin_names[config.name];

          if (old_plugin) {
            config.engine_mode = old_plugin.config.engine_mode;
          }
        }

        config.origin = pconfig.origin || uri;
        config.namespace = pconfig.namespace;
        config.workspace = pconfig.workspace;

        if (!config) {
          console.error(\`Failed to fetch the plugin from "\${uri}".\`);
          reject(\`Failed to fetch the plugin from "\${uri}".\`);
          return;
        }

        if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(config.type)) {
          console.warn(\`Installed plugin \${config.name} with unsupported plugin type: \${config.type}\`);
        }

        config.tag = tag || this.plugin_names[config.name] && this.plugin_names[config.name].config.tag || config.tag;

        if (config.tag) {
          // remove existing tag
          const sp = config.origin.split(":");

          if (sp[1]) {
            if (sp[1].split("@")[1]) config.origin = sp[0] + ":" + sp[1].split("@")[0];
          } // add a new tag
          // config.origin = config.origin + "@" + config.tag;

        }

        config._id = config.name && config.name.replace(/ /g, "_") || Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        config.dependencies = config.dependencies || [];

        try {
          for (let i = 0; i < config.dependencies.length; i++) {
            await this.reloadPluginRecursively({
              uri: config.dependencies[i],
              scoped_plugins: config.scoped_plugins || scoped_plugins,
              namespace: pconfig.namespace,
              hot_reloading: pconfig.hot_reloading
            }, null, allow_evil);
          }

          this.reloadPlugin(config, allow_evil).then(plugin => {
            resolve(plugin);
          }).catch(reject);
        } catch (error) {
          //alert(\`Failed to load dependencies for \${config.name}: \${error}\`);
          reject(\`Failed to load dependencies for \${config.name}: \${error}\`);
        }
      }).catch(e => {
        console.error(e);
        reject(e);
      });
    });
  }

  installPlugin(pconfig, tag, do_not_load) {
    return new Promise((resolve, reject) => {
      let scoped_plugins = this.available_plugins;

      if (pconfig.scoped_plugins) {
        scoped_plugins = pconfig.scoped_plugins;
        delete pconfig.scoped_plugins;
      }

      if (!pconfig.src && !pconfig.uri) {
        reject("Please provide the source via the \`src\` key.");
        return;
      }

      pconfig.src = pconfig.src || pconfig.uri;
      tag = tag || pconfig.tag;

      if (pconfig.src.includes("\\n")) {
        const config = this.parsePluginCode(pconfig.src);
        const ps = [];
        config.dependencies = config.dependencies || [];

        for (let i = 0; i < config.dependencies.length; i++) {
          ps.push(this.installPlugin({
            src: config.dependencies[i],
            namespace: config.namespace,
            scoped_plugins: config.scoped_plugins || scoped_plugins
          }, null, do_not_load));
        }

        pconfig.code = pconfig.src;
        Promise.all(ps).then(() => {
          this.savePlugin(pconfig).then(async template => {
            this.showMessage(\`Plugin "\${template.name}" has been successfully installed.\`);
            this.event_bus.emit("plugin_installed", template);
            resolve(template);
            if (!do_not_load) this.reloadPlugin(template);
          }).catch(reject);
        }).catch(reject);
        return;
      }

      if ( // plugin URI
      !/(http(s?)):\\/\\//i.test(pconfig.src) && pconfig.src.includes("/") && pconfig.src.includes(":") || // plugin source url or rpc window
      /(http(s?)):\\/\\//i.test(pconfig.src)) {
        let uri = pconfig.src;
        this.getPluginFromUrl(uri, scoped_plugins).then(async config => {
          if (config.engine_mode) {
            const old_plugin = this.plugin_names[config.name];

            if (old_plugin) {
              config.engine_mode = old_plugin.config.engine_mode;
            }
          }

          config.origin = pconfig.origin || uri;

          if (!config) {
            console.error(\`Failed to fetch the plugin from "\${uri}".\`);
            reject(\`Failed to fetch the plugin from "\${uri}".\`);
            return;
          }

          if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(config.type)) {
            console.warn(\`Installed plugin \${config.name} with unsupported plugin type: \${config.type}\`);
          }

          config.tag = tag || this.plugin_names[config.name] && this.plugin_names[config.name].config.tag || config.tag;

          if (config.tag) {
            // remove existing tag
            const sp = config.origin.split(":");

            if (sp[1]) {
              if (sp[1].split("@")[1]) config.origin = sp[0] + ":" + sp[1].split("@")[0];
            } // add a new tag
            // config.origin = config.origin + "@" + config.tag;

          }

          config._id = config.name && config.name.replace(/ /g, "_") || Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
          config.dependencies = config.dependencies || [];

          try {
            for (let i = 0; i < config.dependencies.length; i++) {
              await this.installPlugin({
                src: config.dependencies[i],
                namespace: config.namespace,
                scoped_plugins: config.scoped_plugins || scoped_plugins
              }, null, do_not_load);
            }

            const template = await this.savePlugin(config);

            for (let p of this.available_plugins) {
              if (p.name === template.name && !p.installed) {
                p.installed = true;
                p.tag = tag;
              }
            }

            this.showMessage(\`Plugin "\${template.name}" has been successfully installed.\`);
            this.event_bus.emit("plugin_installed", template);
            resolve(template);
            if (!do_not_load) this.reloadPlugin(template);
          } catch (error) {
            reject(\`Failed to install dependencies for \${config.name}: \${error}\`);
          }
        }).catch(e => {
          console.error(e);
          reject(e);
        });
      }
    });
  }

  removePlugin(plugin_config) {
    // TODO: support removing by namespace
    return new Promise((resolve, reject) => {
      plugin_config._id = plugin_config._id || plugin_config.name.replace(/ /g, "_"); // remove if exists

      this.db.get(plugin_config._id).then(doc => {
        this.db.remove(doc).then(() => {
          for (let i = 0; i < this.installed_plugins.length; i++) {
            if (this.installed_plugins[i].name === plugin_config.name) {
              this.installed_plugins.splice(i, 1);
            }
          }

          for (let p of this.available_plugins) {
            if (p.name === plugin_config.name) {
              p.installed = false;
              p.tag = null;
            }
          }

          resolve();
          this.showMessage(\`"\${plugin_config.name}" has been removed.\`);
          this.unloadPlugin(plugin_config, true);
        }).catch(err => {
          this.showMessage(err.toString());
          console.error("Failed to remove plugin: ", plugin_config, err);
          reject(err);
        });
      }).catch(err => {
        this.unloadPlugin(plugin_config, true);
        this.showMessage(\`"\${plugin_config.name}" has been unloaded.\`);
        console.log("Plugin does not exist in the database", plugin_config, err);
        resolve(err);
      });
    });
  }

  getPluginDocs(plugin_id) {
    return new Promise((resolve, reject) => {
      this.db.get(plugin_id).then(doc => {
        const config = this.parsePluginCode(doc.code);
        const docs = config.docs;
        resolve(docs);
      }).catch(err => {
        reject(err);
      });
    });
  }

  getPluginSource(plugin_id) {
    return new Promise((resolve, reject) => {
      this.db.get(plugin_id).then(doc => {
        resolve(doc.code);
      }).catch(err => {
        reject(err);
      });
    });
  }

  unloadPlugin(_plugin, temp_remove) {
    const name = _plugin.name;

    for (let k in this.plugins) {
      const plugin = this.plugins[k];

      if (plugin.name === name) {
        try {
          if (temp_remove) {
            delete this.plugins[k];
            delete this.plugin_names[name];
          }

          plugin._unloaded = true;

          this._unregister(plugin);

          if (typeof plugin.terminate === "function") {
            plugin.terminate().then(() => {
              this.event_bus.emit("update_ui");
            });
          }

          this.event_bus.emit("update_ui");
        } catch (e) {
          console.error(e);
        }
      }
    }

    this._unregister(_plugin);

    if (typeof _plugin.terminate === "function") {
      _plugin.terminate().finally(() => {
        this.event_bus.emit("update_ui");
      });
    }

    this.event_bus.emit("update_ui");
    this.event_bus.emit("plugin_unloaded", _plugin);
  }

  connectPlugin(connection) {
    return new Promise((resolve, reject) => {
      Object(_jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["getExternalPluginConfig"])(connection).then(config => {
        config.runnable = config.runnable === false ? false : true;
        config.badges = this.getBadges(config);
        this.unloadPlugin(config, true);
        this.loadPlugin(config, {
          id: config.id
        }, false, connection).then(p => {
          resolve(p);
        }).catch(reject);
      }).catch(reject);
    });
  }

  async reloadPlugin(pconfig, allow_evil) {
    try {
      if (pconfig.hot_reloading) {
        let plugin;

        if (pconfig.id) {
          for (let pid of Object.keys(this.plugins)) {
            if (pid === pconfig.id) {
              plugin = this.plugins[pid];
              break;
            }
          }
        }

        const template = this.parsePluginCode(pconfig.code, {
          tag: pconfig.tag,
          _id: pconfig._id,
          origin: pconfig.origin,
          namespace: pconfig.namespace,
          hot_reloading: pconfig.hot_reloading,
          engine_mode: pconfig.engine_mode
        });
        pconfig.name = pconfig.name || template.name;

        if (!plugin && pconfig.name) {
          for (let pid of Object.keys(this.plugins)) {
            if (this.plugins[pid].name === pconfig.name) {
              plugin = this.plugins[pid];
              break;
            }
          }
        }

        if (plugin && plugin.type !== "window") {
          if (plugin.config.tag === template.tag && plugin.config.engine_mode === template.engine_mode && plugin.config.namespace === template.namespace) {
            plugin.config.requirements = template.requirements;
            plugin.config.scripts = template.scripts;
            plugin.config.styles = template.styles;
            plugin.config.links = template.links;
            plugin.config.windows = template.windows;

            try {
              await plugin.hotReload();

              if (template.type) {
                this._register(plugin, template);
              }

              if (plugin.api && plugin.api.setup) await plugin.api.setup();
              return plugin;
            } catch (e) {
              console.error("Failed to hot reload: ", e);
              this.showMessage(\`Failed to perform hot reloading, error: \${e}\`);
            }
          }
        }
      }

      if (pconfig instanceof _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"]) {
        pconfig = pconfig.config;
      }

      this.unloadPlugin(pconfig, true);
      const template = this.parsePluginCode(pconfig.code, {
        tag: pconfig.tag,
        _id: pconfig._id,
        origin: pconfig.origin,
        namespace: pconfig.namespace,
        hot_reloading: pconfig.hot_reloading,
        engine_mode: pconfig.engine_mode
      });
      template.engine = null;
      this.unloadPlugin(template, true); // if it's a collection, we only load the dependencies

      if (pconfig.load_dependencies || template.type === "collection") {
        template.dependencies = template.dependencies || [];

        for (let i = 0; i < template.dependencies.length; i++) {
          await this.reloadPluginRecursively({
            uri: template.dependencies[i],
            namespace: pconfig.namespace,
            hot_reloading: pconfig.hot_reloading
          }, null, allow_evil);
        }
      }

      if (template.type === "collection") {
        return;
      }

      let p;

      if (template.type === "rpc-window" || template.type === "window") {
        p = this.loadProxyPlugin(template);
      } else {
        if (allow_evil === "eval is evil") {
          this._allowed_evil_plugin[template.name] = template.code;
        } else {
          if (this._allowed_evil_plugin[template.name] === template.code) {
            allow_evil = "eval is evil";
          }
        }

        p = this.loadPlugin(template, null, allow_evil);
      }

      try {
        const plugin = await p;
        plugin._id = pconfig._id;
        pconfig.name = plugin.name;
        pconfig.type = plugin.type;
        pconfig.plugin = plugin;
        this.event_bus.emit("update_ui");
        return plugin;
      } catch (e) {
        pconfig.plugin = null;
        throw e;
      }
    } catch (e) {
      this.showMessage(e || "Error.", 15);
      console.error(e);
      throw e;
    }
  }

  savePlugin(pconfig) {
    return new Promise((resolve, reject) => {
      const code = pconfig.code;

      try {
        const template = this.parsePluginCode(code, {
          tag: pconfig.tag,
          origin: pconfig.origin,
          engine_mode: pconfig.engine_mode,
          namespace: pconfig.namespace
        });
        template.code = code;
        template._id = template.name.replace(/ /g, "_");
        template.hash = spark_md5__WEBPACK_IMPORTED_MODULE_3___default.a.hash(template.code);

        const addPlugin = template => {
          this.db.put(template).then(() => {
            for (let i = 0; i < this.installed_plugins.length; i++) {
              if (this.installed_plugins[i].name === template.name) {
                this.installed_plugins.splice(i, 1);
              }
            }

            template.installed = true;
            this.installed_plugins.push(template);
            resolve(template);
            this.showMessage(\`\${template.name} has been successfully saved.\`);
          }).catch(err => {
            this.showMessage("Failed to save the plugin.");
            console.error(err);
            reject("failed to save");
          });
        }; // remove if exists


        this.db.get(template._id).then(doc => {
          template._rev = doc._rev;
          addPlugin(template);
        }).catch(() => {
          addPlugin(template);
        });
      } catch (e) {
        this.showMessage(e || "Error.");
        reject(e);
      }
    });
  }

  getBadges(p) {
    const backend = Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(p.type);

    if (backend) {
      return backend.icon || "";
    } else {
      return "";
    }
  }

  parsePluginCode(code, overwrite_config) {
    overwrite_config = overwrite_config || {};

    try {
      const pluginComp = Object(_pluginParser_js__WEBPACK_IMPORTED_MODULE_14__["parseComponent"])(code);
      let config;

      if (pluginComp.config[0].attrs.lang === "yaml") {
        config = js_yaml__WEBPACK_IMPORTED_MODULE_5___default.a.load(pluginComp.config[0].content);
      } else if (pluginComp.config[0].attrs.lang === "json") {
        config = JSON.parse(pluginComp.config[0].content);
      } else {
        config = JSON.parse(pluginComp.config[0].content);

        if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["compareVersions"])(config.api_version, ">", "0.1.5")) {
          throw \`Unsupported config language \${pluginComp.config[0].attrs.lang}, please set lang="json" or lang="yaml"\`;
        }
      }

      config.tag = overwrite_config.tag || config.tags && config.tags[0];
      config.hot_reloading = overwrite_config.hot_reloading, config.scripts = []; // try to match the script with current tag

      for (let i = 0; i < pluginComp.script.length; i++) {
        if (pluginComp.script[i].attrs.tag === config.tag) {
          config.script = pluginComp.script[i].content;
        } // exclude script with mismatched tag


        if (!pluginComp.script[i].attrs.tag || pluginComp.script[i].attrs.tag === config.tag) {
          config.scripts.push(pluginComp.script[i]);
        }
      }

      if (!config.script && pluginComp.script.length > 0) {
        config.script = pluginComp.script[0].content;
        config.lang = pluginComp.script[0].attrs.lang;
      }

      config.links = pluginComp.link || null;
      config.windows = pluginComp.window || null;
      config.styles = pluginComp.style || null;
      config.docs = pluginComp.docs && pluginComp.docs[0] || config.docs;
      config.attachments = pluginComp.attachment || null;
      config._id = overwrite_config._id || config.name.replace(/ /g, "_");
      config.uri = overwrite_config.uri;
      config.origin = overwrite_config.origin;
      config.namespace = overwrite_config.namespace;
      config.code = code;
      config.id = config.name.trim().replace(/ /g, "_") + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
      config.runnable = config.runnable === false ? false : true;
      config.requirements = config.requirements || [];

      for (let i = 0; i < _api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"].length; i++) {
        const obj = config[_api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"][i]];

        if (obj && typeof obj === "object" && !(obj instanceof Array)) {
          if (config.tag) {
            config[_api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"][i]] = obj[config.tag];

            if (!Object.prototype.hasOwnProperty.call(obj, config.tag)) {
              console.log("WARNING: " + _api_js__WEBPACK_IMPORTED_MODULE_10__["CONFIGURABLE_FIELDS"][i] + " do not contain a tag named: " + config.tag);
            }
          } else {
            throw "You must use 'tags' with configurable fields.";
          }
        }
      }

      config.lang = config.lang || "javascript";
      config = Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["upgradePluginAPI"])(config);

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["PLUGIN_SCHEMA"])(config)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["PLUGIN_SCHEMA"].errors;
        console.error("Invalid plugin config: " + config.name, error);
        throw error;
      }

      const backend = Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(config.type);
      config.badges = this.getBadges(config);

      if (backend) {
        config.engine_mode = null;
      } else {
        config.engine_mode = overwrite_config.engine_mode || "auto";
      }

      if (config.flags && (config.flags.indexOf("engine") >= 0 || config.flags.indexOf("engine-factory") >= 0)) {
        config.badges = config.badges + "";
      }

      if (config.flags && config.flags.indexOf("file-manager") >= 0) {
        config.badges = config.badges + "";
      }

      return config;
    } catch (e) {
      console.error(e);
      throw \`Failed to parse the plugin file, error: \${e}\`;
    }
  }

  validatePluginConfig(config) {
    if (config.name.indexOf("/") < 0) {
      return true;
    } else {
      throw "Plugin name should not contain '/'.";
    }
  }

  loadProxyPlugin(template, rplugin) {
    const config = {
      _id: template._id,
      name: template.name,
      type: template.type,
      ui: template.ui,
      tag: template.tag,
      inputs: template.inputs,
      outputs: template.outputs,
      docs: template.docs,
      attachments: template.attachments
    };
    this.validatePluginConfig(config); //generate a random id for the plugin

    return new Promise((resolve, reject) => {
      if (!rplugin) {
        config.id = template.name.trim().replace(/ /g, "_") + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        config.initialized = false;
      } else {
        config.id = rplugin.id;
        config.initialized = true;
      }

      const tconfig = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, template, config);

      tconfig.workspace = this.selected_workspace; // TODO: deprecate TAG and WORKSPACE, use \`config.tag\` and \`config.workspace\` instead

      const _interface = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({
        TAG: tconfig.tag,
        WORKSPACE: this.selected_workspace,
        config: {
          tag: tconfig.tag,
          workspace: this.selected_workspace
        }
      }, this.imjoy_api);

      try {
        // create a proxy plugin
        const plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"](tconfig, _interface, null, true);
        plugin.api = {
          _rintf: true,
          setup: async function () {},
          run: async my => {
            const c = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["_clone"])(template.defaults) || {};
            c.type = template.name;
            c.name = template.name;
            c.tag = template.tag; // c.op = my.op

            c.data = my && my.data || {};
            c.config = my && my.config || {};
            c.id = my && my.id;
            c.window_id = my && my.window_id;

            if (c.as_dialog && this.imjoy_api.showDialog) {
              // make sure there is a header and convert it to fullscreen dialog
              if (c.standalone) {
                c.fullscreen = true;
                c.standalone = false;
              }

              return await this.imjoy_api.showDialog(null, c);
            } else {
              return await this.imjoy_api.createWindow(null, c);
            }
          }
        };

        this._register(plugin, config);

        this.plugins[plugin.id] = plugin;
        this.plugin_names[plugin.name] = plugin;
        this.event_bus.emit("plugin_loaded", plugin);
        resolve(plugin);
      } catch (e) {
        reject(e);
      }
    });
  }

  loadPlugin(template, rplugin, allow_evil, connection) {
    template = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["_clone"])(template);
    this.validatePluginConfig(template); // Generate a random id for the plugin
    // eslint-disable-next-line no-async-promise-executor

    return new Promise(async (resolve, reject) => {
      const config = {};

      if (!rplugin) {
        config.id = template.name.trim().replace(/ /g, "_") + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        config.initialized = false;
      } else {
        config.id = rplugin.id;
        config.initialized = true;
      }

      config._id = template._id;
      let engine = null;

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["getBackendByType"])(template.type)) {
        engine = await this.em.findEngine(template);

        if (!engine) {
          console.error(\`Plugin engine not found for plugin type=\${template.type}.\`);
        } else {
          this.showMessage(\`Running plugin with plugin engine: \${engine.name}\`);
        }
      }

      const tconfig = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, template, config);

      tconfig.workspace = this.selected_workspace;

      const _interface = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({
        TAG: tconfig.tag,
        WORKSPACE: this.selected_workspace,
        ENGINE_URL: engine && engine.url || undefined,
        config: {
          tag: tconfig.tag,
          workspace: this.selected_workspace,
          engine: engine && engine.url || undefined
        }
      }, this.imjoy_api);

      try {
        const plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"](tconfig, _interface, engine, false, allow_evil, connection);

        plugin._log_history.push(\`Loading plugin \${plugin.id} (config=\${_interface.config})\`);

        if (_interface.ENGINE_URL) plugin._log_history.push(\`ENGINE_URL=\${_interface.ENGINE_URL}\`);
        const plugin_loading_timer = setTimeout(() => {
          // plugin.terminate();
          plugin.initializing = false;
          console.warn(\`Plugin \${plugin.name} failed to load in 180s.\`);
        }, 180000);
        plugin.onConnected(async () => {
          clearTimeout(plugin_loading_timer);

          if (!plugin.api) {
            console.error("Error occured when loading plugin.");
            this.showMessage("Error occured when loading plugin.");
            reject("Error occured when loading plugin.");
            throw "Error occured when loading plugin.";
          }

          plugin._log_history.push(\`Plugin connected.\`);

          if (plugin._unloaded) {
            console.log("WARNING: this plugin is ready but unloaded: " + plugin.id);
            plugin.terminate().then(() => {
              this.event_bus.emit("update_ui");
            });
            return;
          }

          if (template.type) {
            this._register(plugin, template);
          } // if (template.extensions && template.extensions.length > 0) {
          //   this.registerExtension(template.extensions, plugin);
          // }


          if (plugin.config.flags && plugin.config.flags.includes("browserfs")) {
            const bfs = await this.getPlugin(null, {
              name: "BrowserFS"
            });
            bfs.attachWebWorker(plugin.webworker);
          }

          if (plugin.config.resumed && plugin.api.resume) {
            plugin._log_history.push(\`Resuming plugin.\`);

            plugin.api.resume().then(() => {
              this.event_bus.emit("plugin_loaded", plugin);
              resolve(plugin);
            }).catch(e => {
              console.error("error occured when loading plugin " + template.name + ": ", e);
              this.showMessage(\`<\${template.name}>: \${e}\`, 15);
              reject(e);
              plugin.terminate().then(() => {
                this.event_bus.emit("update_ui");
              });
            });
          } else if (plugin.api.setup) {
            plugin._log_history.push(\`Setting up plugin.\`);

            plugin.api.setup().then(() => {
              this.event_bus.emit("plugin_loaded", plugin);
              resolve(plugin);
            }).catch(e => {
              console.error("error occured when loading plugin " + template.name + ": ", e);
              this.showMessage(\`<\${template.name}>: \${e}\`, 15);
              reject(e);
              plugin.terminate().then(() => {
                this.event_bus.emit("update_ui");
              });
            });
          } else {
            console.warn(\`No "setup()" function is defined in plugin "\${plugin.name}".\`);
            resolve(plugin);
          }
        });
        plugin.onFailed(e => {
          clearTimeout(plugin_loading_timer);
          plugin.error(e);

          if (e) {
            this.showMessage(\`<\${template.name}>: \${e}\`);
          } else {
            this.showMessage(\`Error occured when loading \${template.name}.\`);
          }

          console.error("error occured when loading " + template.name + ": ", e);
          plugin.terminate().then(() => {
            this.event_bus.emit("update_ui");
          });
          reject(e);
        });
        plugin.docs = template.docs;
        plugin.attachments = template.attachments;
        this.plugins[plugin.id] = plugin;
        this.plugin_names[plugin.name] = plugin;
      } catch (e) {
        reject(e);
      }
    });
  }

  renderWindow(pconfig) {
    return new Promise((resolve, reject) => {
      const tconfig = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, pconfig.plugin, pconfig);

      tconfig.workspace = this.selected_workspace;

      const imjoy_api = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, this.imjoy_api); // copy window api functions to the plugin instance


      for (let k in pconfig.api) {
        if (Object.prototype.hasOwnProperty.call(pconfig.api, k)) {
          imjoy_api[k] = function () {
            var args = Array.prototype.slice.call(arguments, 1);
            pconfig.api[k].apply(pconfig, args);
          };
        }
      }

      const _interface = lodash_assign__WEBPACK_IMPORTED_MODULE_1___default()({
        TAG: tconfig.tag,
        WORKSPACE: this.selected_workspace,
        config: {
          tag: tconfig.tag,
          workspace: this.selected_workspace
        }
      }, imjoy_api);

      try {
        const plugin = new _jailedPlugin_js__WEBPACK_IMPORTED_MODULE_9__["DynamicPlugin"](tconfig, _interface);
        plugin.onConnected(() => {
          if (!pconfig.standalone && pconfig.api.focus) pconfig.api.focus(); // copy window api to the plugin

          plugin.api = plugin.api || {};

          for (let k in pconfig.api) {
            if (Object.prototype.hasOwnProperty.call(pconfig.api, k)) {
              plugin.api[k] = pconfig.api[k];
            }
          }

          (plugin.api.setup || async function () {})().then(() => {
            this.event_bus.emit("plugin_loaded", plugin); //asuming the data._op is passed from last op

            pconfig.data = pconfig.data || {};
            pconfig.data._source_op = pconfig.data && pconfig.data._op;
            pconfig.data._op = plugin.name;
            pconfig.data._workflow_id = pconfig.data && pconfig.data._workflow_id;
            pconfig.plugin = plugin;
            pconfig.update = plugin.api.run;

            if (plugin.config.runnable && !plugin.api.run) {
              const warn_text = "You should define a \`run\` function for " + plugin.name + " or set its \`runnable\` field to false.";
              console.warn(warn_text);
            }

            if (plugin.api.run) {
              plugin.api.run(this.filter4plugin(pconfig)).then(result => {
                if (result) {
                  for (let k in result) {
                    pconfig[k] = result[k];
                  }
                }

                resolve(plugin);
              }).catch(e => {
                plugin.error(\`<\${plugin.name}>: (\${e && e.toString()} || "Error.")\`);
                reject(e);
              });
            } else {
              resolve(plugin);
            }
          }).catch(e => {
            plugin.error(\`Error occured when loading the window plugin \${pconfig.name}: \${e && e.toString()}\`);
            plugin.terminate().then(() => {
              this.event_bus.emit("update_ui");
            });
            reject(e);
          });
        });
        plugin.onFailed(e => {
          if (!pconfig.standalone && pconfig.focus) pconfig.focus();
          plugin.error(\`Error occured when loading \${pconfig.name}: \${e}.\`);
          plugin.terminate().then(() => {
            this.event_bus.emit("update_ui");
          });
          reject(e);
        });
      } catch (e) {
        reject(e);
      }
    });
  }

  plugin2joy(my) {
    if (!my) return null; //conver config--> data  data-->target

    const res = {};
    res._rintf = my._rintf;

    if (my.type && my.data) {
      res.data = my.config;
      res.target = my.data;
      res.target.name = my.name || "";
      res.target.type = my.type || "";
    } else {
      res.data = null;
      res.target = my;
    }

    res.target = res.target || {};

    if (Array.isArray(res.target) && res.target.length > 0) {
      if (my.select !== undefined && res.target[my.select]) {
        res.target = res.target[my.select];
      }
    }

    if (typeof res.target === "object") {
      res.target._variables = my._variables || {};
      res.target._workflow_id = my._workflow_id || null;
      res.target._op = my._op || null;
      res.target._source_op = my._source_op || null;
      res.target._transfer = my._transfer || false;

      if (Object.keys(res.target).length > 4) {
        return res;
      } else {
        return null;
      }
    } else {
      return res;
    }
  }

  filter4plugin(my) {
    return my && {
      _variables: my._variables || null,
      _op: my._op,
      _source_op: my._source_op,
      _transfer: my._transfer,
      _workflow_id: my._workflow_id,
      config: my.config,
      data: my.data
    };
  }

  joy2plugin(my) {
    //conver data-->config target--> data
    if (!my) return null;
    my.target = my.target || {};
    const ret = {
      _rintf: my._rintf,
      _variables: my.target._variables || null,
      _op: my.target._op,
      _source_op: my.target._source_op,
      _transfer: my.target._transfer,
      _workflow_id: my.target._workflow_id,
      config: my.data,
      data: my.target,
      name: my.target.name || "",
      type: my.target.type || ""
    };
    delete my.target._op;
    delete my.target._workflow_id;
    delete my.target._variables;
    delete my.target._source_op;
    delete my.target._transfer;
    return ret;
  }

  getRepoManifest(url, hashtag) {
    return new Promise((resolve, reject) => {
      const re = new RegExp("^[^/.]+/[^/.]+$");
      let repository_url;
      let repo_origin;

      if (url.match(re)) {
        repo_origin = url;

        if (hashtag) {
          url = url + "/tree/" + hashtag;
          repo_origin = repo_origin + "@" + hashtag;
        }

        repository_url = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubImJoyManifest"])("https://github.com/" + url);
      } else if (url.includes("github.com")) {
        repository_url = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubImJoyManifest"])(url);
        repo_origin = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["githubRepo"])(url);
      } else {
        repository_url = url;
        repo_origin = repository_url;
      }

      axios__WEBPACK_IMPORTED_MODULE_4___default.a.get(repository_url).then(response => {
        if (response && response.data && response.data.plugins) {
          const manifest = response.data;
          manifest.plugins = manifest.plugins.filter(p => {
            return !p.disabled;
          });

          if (!/(http(s?)):\\/\\//i.test(manifest.uri_root)) {
            manifest.uri_root = repository_url.replace(new RegExp("manifest.imjoy.json$"), lodash_trim__WEBPACK_IMPORTED_MODULE_0___default()(manifest.uri_root, "/"));
          }

          for (let i = 0; i < manifest.plugins.length; i++) {
            const p = manifest.plugins[i];
            p.uri = p.uri || p.name + ".imjoy.html";
            p.origin = repo_origin + ":" + p.name;

            if (!p.uri.startsWith(manifest.uri_root) && !/(http(s?)):\\/\\//i.test(p.uri)) {
              p.uri = manifest.uri_root + "/" + p.uri;
            }

            p._id = p._id || p.name.replace(/ /g, "_");
            p.badges = this.getBadges(p);
          }

          resolve(manifest);
        } else {
          reject("failed to load url: " + repository_url);
        }
      }).catch(reject);
    });
  }

  destroy() {
    for (let k in this.plugins) {
      const plugin = this.plugins[k];

      try {
        if (typeof plugin.terminate === "function") plugin.terminate();
      } catch (e) {}
    }
  }

  registerOp(plugin, config) {
    try {
      if (!plugin) throw "Plugin not found.";
      config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["_clone"])(config);
      config.name = config.name || plugin.name;
      config.show_panel = config.show_panel || false;

      if (plugin.name === config.name) {
        config.ui = config.ui || plugin.config.description;
      }

      config.inputs = config.inputs || null;
      config.outputs = config.outputs || null;
      config.run = config.run || null;
      config.run = config.run || plugin && plugin.api && plugin.api.run;

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["OP_SCHEMA"])(config)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["OP_SCHEMA"].errors;
        console.error("Error occured during registering " + config.name, error);
        throw error;
      }

      const plugin_name = plugin.name;
      const op_name = config.name;
      const op_key = op_name === plugin_name ? plugin_name : plugin_name + "/" + op_name;
      const joy_template = {
        name: config.name,
        tags: ["op", "plugin"],
        type: op_key,
        init: _joy_js__WEBPACK_IMPORTED_MODULE_6__["Joy"].normalizeUI(config.ui)
      }; // save type to tags

      if (config.type === "window") {
        joy_template.tags.push("window");
      } else if (config.type === "rpc-window") {
        joy_template.tags.push("rpc-window");
      } else if (config.type === "rpc-worker") {
        joy_template.tags.push("rpc-worker");
      } else if (config.type === "native-python") {
        joy_template.tags.push("python");
      } else if (config.type === "web-worker") {
        joy_template.tags.push("web-worker");
      } else if (config.type === "web-python") {
        joy_template.tags.push("web-python");
      } else if (config.type === "iframe") {
        joy_template.tags.push("iframe");
      }

      let run = config.run;

      if (!plugin || !run) {
        joy_template.onexecute = () => {
          plugin.log("WARNING: no run function defined.");
        };
      } else {
        const onexecute = async my => {
          // my.target._workflow_id = null;
          try {
            const result = await run(this.joy2plugin(my));
            return this.plugin2joy(result);
          } catch (e) {
            plugin.error(e && e.toString());
            throw e;
          }
        };

        joy_template.onexecute = onexecute;
      }

      if (config.update && typeof config.update === "function") {
        const onupdate = async my => {
          // my.target._workflow_id = null;
          const result = await config.update(this.joy2plugin(my));
          return this.plugin2joy(result);
        };

        joy_template.onupdate = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["debounce"])(onupdate, 300);
      } else if (plugin && plugin.api && plugin.api.update) {
        const onupdate = async my => {
          // my.target._workflow_id = null;
          const result = await plugin.api.update(this.joy2plugin(my));
          return this.plugin2joy(result);
        };

        joy_template.onupdate = Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["debounce"])(onupdate, 300);
      }

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["JOY_SCHEMA"])(joy_template)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["JOY_SCHEMA"].errors;
        console.error("Error occured during registering op to joy " + joy_template.name, error);
        throw error;
      }

      _joy_js__WEBPACK_IMPORTED_MODULE_6__["Joy"].add(joy_template);
      const op_config = {
        plugin_id: plugin.id,
        name: joy_template.name,
        ui: "{id: '__op__', type: '" + joy_template.type + "'}",
        onexecute: joy_template.onexecute
      };
      plugin.ops = plugin.ops || {};
      plugin.ops[config.name] = op_config;

      if (config.inputs) {
        try {
          if ((config.inputs.type != "object" || !config.inputs.properties) && (config.inputs.type != "array" || !config.inputs.items)) {
            if (typeof config.inputs === "object") {
              config.inputs = {
                properties: config.inputs,
                type: "object"
              };
            } else {
              throw "inputs schema must be an object.";
            }
          } // set all the properties as required by default


          if (config.inputs.type === "object" && config.inputs.properties && !config.inputs.required) {
            config.inputs.required = Object.keys(config.inputs.properties);
          }

          const sch = _api_js__WEBPACK_IMPORTED_MODULE_10__["ajv"].compile(config.inputs);
          op_config.inputs_schema = sch;
          this.registered.inputs[op_key] = {
            loader_key: op_key,
            op_name: op_name,
            plugin_name: plugin_name,
            schema: sch
          };

          this.registered.loaders[op_key] = async target => {
            let config = {};

            if (plugin.config && plugin.config.ui) {
              config = await this.imjoy_api.showDialog(plugin, {
                type: "imjoy/joy",
                ui: plugin.config.ui,
                name: plugin.config.name
              });
            }

            target.transfer = target.transfer || false;
            target._source_op = target._op;
            target._op = op_name;
            target._workflow_id = target._workflow_id || "data_loader_" + op_name.trim().replace(/ /g, "_") + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
            const my = {
              op: {
                name: op_name
              },
              target: target,
              data: config
            };
            const result = await plugin.api.run(this.joy2plugin(my));

            if (result) {
              const res = this.plugin2joy(result); // if it's not a window

              if (res && !res._rintf) {
                const w = {};
                w.name = res.name || "result";
                w.type = res.type || "imjoy/generic";
                w.config = res.data || {};
                w.data = res.target || {};
                await this.imjoy_api.createWindow(plugin, w);
              }
            }
          };

          this.wm.registerInputLoader(op_key, this.registered.inputs[op_key], this.registered.loaders[op_key]);
        } catch (e) {
          console.error(\`error occured when parsing the inputs schema of "\${config.name}"\`, e);
        }
      }

      if (config.outputs) {
        try {
          if (config.outputs.type != "object" || !config.outputs.properties) {
            if (typeof config.outputs === "object") {
              config.outputs = {
                properties: config.outputs,
                type: "object"
              };
            } else {
              throw "inputs schema must be an object.";
            }
          } // set all the properties as required by default


          if (config.outputs.type === "object" && config.outputs.properties && !config.outputs.required) {
            config.outputs.required = Object.keys(config.outputs.properties);
          }

          const sch = _api_js__WEBPACK_IMPORTED_MODULE_10__["ajv"].compile(config.outputs);
          op_config.outputs_schema = sch;
          this.registered.outputs[op_key] = {
            op_name: config.name,
            plugin_name: plugin.name,
            schema: sch
          };
        } catch (e) {
          console.error(\`error occured when parsing the outputs schema of "\${config.name}"\`, e);
        }
      }

      this.registered.ops[op_key] = op_config;
      this.registered.windows[config.name] = plugin.config;
      this.event_bus.emit("op_registered", op_config);
      return true;
    } catch (e) {
      console.error(e);
      throw e;
    }
  }

  unregisterOp(plugin, config) {
    if (!plugin) throw "Plugin not found.";
    const plugin_name = plugin.name;

    if (!config) {
      if (plugin.ops && Object.keys(plugin.ops).length > 0) {
        for (let k in plugin.ops) {
          const op = plugin.ops[k];
          if (op.name) this.unregisterOp(plugin, op.name);
        }
      }

      if (plugin.name) this.unregisterOp(plugin, plugin.name);
      return;
    } else {
      const op_name = typeof config === "string" ? config : config.name;
      const op_key = op_name === plugin_name ? plugin_name : plugin_name + "/" + op_name;
      if (this.registered.inputs[op_key]) delete this.registered.inputs[op_key];
      if (this.registered.loaders[op_key]) delete this.registered.loaders[op_key];
      if (op_name === plugin_name && this.registered.windows[plugin_name]) delete this.registered.windows[plugin_name];
      if (this.registered.ops[op_key]) delete this.registered.ops[op_key];
      if (plugin.ops && plugin.ops[op_name]) delete plugin.ops[op_name];
      this.wm.unregisterInputLoader(op_key);
      _joy_js__WEBPACK_IMPORTED_MODULE_6__["Joy"].remove(op_key);
    }
  }

  async _register(plugin, config) {
    // config._id means this is a plugin config
    if (!config.type || config._id || config.type === "@operator" || config.type === "operator") {
      this.registerOp(plugin, config);
      this.service_registry[config.name] = {
        id: config.name,
        type: "@operator",
        name: config.name,
        ui: config.ui,
        inputs: config.inputs,
        outputs: config.outputs,
        run: config.run,
        provider: plugin.name,
        providerId: plugin.id
      };
      this.event_bus.emit("register", {
        config,
        plugin
      });
      return config.name;
    }

    config.id = config.id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
    config.provider = plugin.name;
    config.providerId = plugin.id;
    this.service_registry[config.id] = config;
    this.event_bus.emit("register", {
      config,
      plugin
    });
    return config.id;
  }

  _unregister(plugin, config) {
    if (!config || typeof config === "string" || config.type === "@operator" || config.type === "operator") {
      if (!config) {
        const services = this.getServices(plugin, {
          providerId: plugin.id
        });

        for (let s of services) {
          this._unregister(plugin, s);
        }
      }

      config = config || plugin;
      this.unregisterOp(plugin, config);
      delete this.service_registry[config.name];
    } else delete this.service_registry[config.id];

    this.event_bus.emit("unregister", {
      config,
      plugin
    });
    return true;
  } //#################ImJoy API functions##################


  async register(plugin, config) {
    console.warn("api.register is deprecated, please use \`api.registerService\` instead.");
    return await this.registerService(plugin, config);
  }

  async unregister(plugin, config) {
    console.warn("api.unregister is deprecated, please use \`api.registerService\` instead.");
    return await this.unregisterService(plugin, config);
  }

  async registerService(plugin, config) {
    plugin = plugin || {};

    if (!config.type || !config.name) {
      throw new Error("you must specify the service \`type\` and \`name\`.");
    } else if (config.type.startsWith("@")) {
      // registered service types
      if (compiledServiceSpec[config.type]) {
        const schema = compiledServiceSpec[config.type];

        if (!schema(config)) {
          const error = schema.errors;
          console.error("Failed to register service " + config.name || false, error);
          throw error;
        }
      } else {
        throw new Error(\`Registered service type "\${config.type}" not found, please consider submit your type definition to the imjoy-core repo, see https://imjoy.io/docs/#/api?id=apiregisterservice for more details\`);
      }
    }

    return this._register(plugin, config);
  }

  async unregisterService(plugin, config) {
    return this._unregister(plugin, config);
  }

  getServices(_plugin, sconfig) {
    sconfig = sconfig || {};
    return Object.values(this.service_registry).filter(s => {
      let match = true;

      for (let k of Object.keys(sconfig)) {
        if (sconfig[k] !== s[k]) {
          match = false;
          break;
        }
      }

      return match;
    });
  }

  createWindow(_plugin, cfg, extra_cfg) {
    let wconfig = {};

    if (typeof cfg === "string") {
      if (cfg.includes("\\n") || /(http(s?)):\\/\\//i.test(cfg) || cfg.includes("/") && cfg.includes(":")) {
        wconfig = {
          src: cfg
        };
      } else wconfig = {
        type: cfg
      };
    } else {
      wconfig = cfg;
    }

    if (extra_cfg) {
      wconfig = Object.assign(wconfig, extra_cfg);
    } // eslint-disable-next-line no-async-promise-executor


    return new Promise(async (resolve, reject) => {
      if (!wconfig.type) {
        if (wconfig.ui) {
          wconfig.type = "imjoy/joy";
        }
      }

      wconfig.data = wconfig.data || null;
      wconfig.panel = wconfig.panel || null;

      if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"])(wconfig)) {
        const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"].errors;
        console.error("Error occured during creating window ", wconfig, error);
        throw error;
      }

      wconfig.name = wconfig.name || wconfig.type; // this is a unique id for the iframe to attach

      wconfig.window_id = wconfig.window_id || "plugin_window_" + wconfig.id + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])(); // window_type will be used for detaching the window

      wconfig.window_type = wconfig.type;

      if (wconfig.type && wconfig.type.startsWith("imjoy/")) {
        wconfig.id = "imjoy_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
        this.wm.addWindow(wconfig).then(() => {
          wconfig.api.on("ready", () => {
            wconfig.refresh();
            wconfig.api = wconfig.api || {};
            wconfig.api = Object.assign(wconfig.api, {
              _rintf: true,
              run: new_config => {
                for (let k in new_config) {
                  wconfig[k] = new_config[k];
                }
              }
            });
            resolve(wconfig.api);
          }, true);
        }).catch(reject);
      } else {
        let window_config;

        if (wconfig.src) {
          // load window plugin from source code
          if (wconfig.src.includes("\\n")) {
            const wplugin = await this.reloadPlugin({
              code: wconfig.src,
              load_dependencies: true,
              namespace: wconfig.namespace,
              tag: wconfig.tag,
              hot_reloading: wconfig.hot_reloading
            });
            window_config = wplugin.config;
            wconfig.type = wplugin.config.type;
            wconfig.name = wconfig.name || wplugin.name || wconfig.type;
          } // load window plugin from source code url
          else if ( // plugin uri
            !/(http(s?)):\\/\\//i.test(wconfig.src) && wconfig.src.includes("/") && wconfig.src.includes(":") || // plugin source url
            /(http(s?)):\\/\\//i.test(wconfig.src) && (wconfig.src.endsWith(".imjoy.html") || wconfig.src.includes("github.com") && wconfig.src.includes("/blob/") || wconfig.src.includes("gist.github.com"))) {
              const wplugin = await this.reloadPluginRecursively({
                uri: wconfig.src,
                tag: wconfig.tag,
                namespace: wconfig.namespace,
                hot_reloading: wconfig.hot_reloading
              });
              window_config = wplugin.config;
              wconfig.type = wplugin.config.type;
              wconfig.name = wconfig.name || wplugin.name || wconfig.type;
            } // load as rpc-window
            else if (/(http(s?)):\\/\\//i.test(wconfig.src)) {
                wconfig.type = wconfig.type || wconfig.src.split("?")[0];
                wconfig.name = wconfig.name || wconfig.type;
                window_config = Object.assign({}, wconfig);
                delete window_config.data;
                delete window_config.config; // copy valid config options as external window plugin <config> block

                if (typeof wconfig.config === "object") {
                  for (let k of _api_js__WEBPACK_IMPORTED_MODULE_10__["PLUGIN_CONFIG_FIELDS"]) {
                    if (wconfig.config[k]) {
                      window_config[k] = wconfig.config[k];
                    }
                  }
                }

                window_config.type = "rpc-window";
                window_config.base_frame = wconfig.src;
                window_config.id = "rpc_window_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])();
              } else {
                reject(\`Unsupported window spec \${wconfig}\`);
                return;
              }
        } else {
          window_config = this.registered.windows[wconfig.type];
        }

        if (!window_config) {
          console.error("No plugin registered for window type: " + wconfig.type, this.registered.windows);
          reject("No plugin registered for window type: " + wconfig.type);
          throw "No plugin registered for window type: " + wconfig.type;
        }

        const pconfig = wconfig; //generate a new window id

        pconfig.id = pconfig.id || window_config.id + "_" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["randId"])(); // assign plugin type ('window')

        pconfig.type = window_config.type;

        if (pconfig.type !== "rpc-window" && pconfig.type !== "window") {
          throw 'Window plugin must be with type "window"';
        }

        pconfig.plugin = window_config;

        if (!Object(_api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"])(pconfig)) {
          const error = _api_js__WEBPACK_IMPORTED_MODULE_10__["WINDOW_SCHEMA"].errors;
          console.error("Error occured during creating window ", pconfig, error);
          throw error;
        }

        pconfig.loading = true;
        const loadingTimer = setTimeout(() => {
          pconfig.loading = false;
          console.warn(\`Failed to load window "\${pconfig.name}" in 10s.\`);
        }, 10000);
        this.wm.addWindow(pconfig).then(() => {
          setTimeout(() => {
            pconfig.refresh();
            const p = this.renderWindow(pconfig);

            if (pconfig.type === "rpc-window") {
              clearTimeout(loadingTimer);
              pconfig.loading = false;
            }

            if (pconfig.passive || window_config.passive) {
              resolve({
                passive: true,
                _rintf: true,
                setup: async function () {},
                on: async function () {},
                off: async function () {},
                emit: async function () {}
              });
              return;
            }

            p.then(wplugin => {
              pconfig.api.on("close", async () => {
                this.event_bus.emit("closing_window_plugin", wplugin);
                await wplugin.terminate();
              });
              pconfig.refresh();
              resolve(wplugin.api);
            }).catch(e => {
              pconfig.refresh();
              reject(e);
            }).finally(() => {
              clearTimeout(loadingTimer);
              pconfig.loading = false;
            });
          }, 0);
        });
      }
    });
  }

  async callPlugin(_plugin, plugin_name, function_name) {
    const target_plugin = this.plugin_names[plugin_name];

    if (target_plugin) {
      if (!target_plugin.api[function_name]) {
        throw \`function "\${function_name}" of \${plugin_name} is not available.\`;
      }

      return await target_plugin.api[function_name].apply(null, Array.prototype.slice.call(arguments, 3, arguments.length));
    } else {
      throw \`plugin with type \${plugin_name} not found.\`;
    }
  }

  async getPlugins(_plugin) {
    const ps = [];

    for (let k in this.plugins) {
      // if (this.plugins[k] === _plugin) continue;
      ps.push({
        name: this.plugins[k].name,
        config: this.plugins[k].config,
        api: this.plugins[k].api
      });
    }

    return ps;
  }

  async getPlugin(_plugin, cfg, extra_cfg) {
    let config = {};

    if (typeof cfg === "string") {
      if (/(http(s?)):\\/\\//i.test(cfg) || cfg.includes("\\n")) {
        config.src = cfg;
      } else {
        config.name = cfg;
      }
    } else {
      config = cfg;
    }

    if (extra_cfg) {
      config = Object.assign(config, extra_cfg);
    }

    if (config.src && config.src.includes("\\n")) {
      const p = await this.reloadPlugin({
        code: config.src,
        load_dependencies: true,
        namespace: config.namespace,
        tag: config.tag,
        hot_reloading: config.hot_reloading,
        engine_mode: config.engine_mode
      });
      console.log(\`\${p.name} loaded from source code\`);
      return p.api;
    } else if (config.src && (/(http(s?)):\\/\\//i.test(config.src) || config.src.includes("/") && config.src.includes(":"))) {
      // try to load from plugin uri
      const p = await this.reloadPluginRecursively({
        uri: config.src,
        tag: config.tag,
        namespace: config.namespace,
        hot_reloading: config.hot_reloading,
        engine_mode: config.engine_mode
      }, config.tag);
      console.log(\`\${p.name} loaded from \${config.src}\`);
      return p.api;
    } else if (config.id && this.plugins[config.id]) {
      return this.plugins[config.id].api;
    } else if (config.name) {
      if (this.plugin_names[config.name]) {
        return this.plugin_names[config.name].api;
      } else if (this.internal_plugins[config.name]) {
        const p = await this.reloadPluginRecursively({
          uri: this.internal_plugins[config.name].src,
          tag: config.tag,
          namespace: config.namespace,
          hot_reloading: config.hot_reloading,
          engine_mode: config.engine_mode
        }, null, "eval is evil");
        console.log(\`\${p.name} loaded.\`);
        return p.api;
      } else {
        throw \`Plugin not found: \${config.name}\`;
      }
    } else {
      throw \`Unsupported plugin spec: \${config}\`;
    }
  }

  async getWindow(_plugin, config) {
    if (typeof config === "string") {
      config = {
        name: config
      };
    }

    if (config.plugin_id) {
      for (let w of this.wm.windows) {
        if (w.plugin.id === config.plugin_id) {
          return w.plugin && w.plugin.api;
        }
      }
    }

    if (config.window_id) {
      for (let w of this.wm.windows) {
        if (w.window_id === config.window_id) {
          return w.plugin && w.plugin.api;
        }
      }
    }

    if (!config.name && !config.type) {
      return null;
    }

    for (let w of this.wm.windows) {
      if (config.name) {
        if (w.name !== config.name) {
          continue;
        }
      }

      if (config.type) {
        if (w.window_type !== config.type) {
          continue;
        }
      }

      return w.plugin && w.plugin.api;
    }

    return null;
  }

  async getFileManager(_plugin, file_manager_url) {
    const manager = this.fm.getFileManagerByUrl(file_manager_url);

    if (manager) {
      return manager.api;
    } else {
      throw \`file manager with url \${file_manager_url} not found.\`;
    }
  }

  async getEngine(_plugin, engine_url) {
    const engine = this.em.getEngineByUrl(engine_url);

    if (engine) {
      return engine.api;
    } else {
      throw \`engine with url \${engine_url} not found.\`;
    }
  }

  async getEngineFactory(_plugin, factory_name) {
    const factory = this.em.getFactory(factory_name);

    if (factory) {
      return factory.api;
    } else {
      throw \`engine factory with name \${factory_name} not found.\`;
    }
  }

  async runPlugin(_plugin, plugin_name, my) {
    if (!_plugin || !_plugin.id) {
      throw "source plugin is not available.";
    }

    const target_plugin = this.plugin_names[plugin_name];

    if (target_plugin) {
      return await target_plugin.api.run(my || {});
    } else {
      throw "plugin with type " + plugin_name + " not found.";
    }
  }

  setPluginConfig(plugin, name, value) {
    if (!plugin) throw "setConfig Error: Plugin not found.";

    if (name.startsWith("_") && plugin.config[name.slice(1)]) {
      throw \`'\${name.slice(1)}' is a readonly field defined in <config> block, please avoid using it\`;
    }

    if (value) {
      return localStorage.setItem("config_" + plugin.name + "_" + name, value);
    } else {
      return localStorage.removeItem("config_" + plugin.name + "_" + name);
    }
  }

  getPluginConfig(plugin, name) {
    if (!plugin) throw "getConfig Error: Plugin not found.";

    if (name.startsWith("_") && plugin.config[name.slice(1)]) {
      return plugin.config[name.slice(1)];
    } else {
      return localStorage.getItem("config_" + plugin.name + "_" + name);
    }
  }

  getAttachment(plugin, name) {
    if (plugin.config.attachments) {
      for (let i = 0; i < plugin.config.attachments.length; i++) {
        if (plugin.config.attachments[i].attrs.name === name) {
          return plugin.config.attachments[i].content;
        }
      }
    } else {
      return null;
    }
  }

  async checkPluginUpdate(plugin) {
    const pconfig = plugin.config;
    const config = await this.getPluginFromUrl(pconfig.origin, this.available_plugins);

    if (pconfig.hash) {
      if (pconfig.hash !== spark_md5__WEBPACK_IMPORTED_MODULE_3___default.a.hash(config.code)) {
        if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["compareVersions"])(pconfig.version, "<=", config.version)) {
          plugin.update_available = true;
        } else {
          plugin.update_available = false;
        }
      } else {
        plugin.update_available = false;
      }
    } else {
      if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_12__["compareVersions"])(pconfig.version, "<", config.version)) {
        plugin.update_available = true;
      } else {
        plugin.update_available = false;
      }
    }

    this.event_bus.emit("update_ui");
  }

  checkUpdates() {
    for (let k in this.plugins) {
      const plugin = this.plugins[k];

      if (plugin.config.origin) {
        this.checkPluginUpdate(plugin);
      } else {
        const pc = this.available_plugins.find(p => {
          return plugin.name === p.name;
        });

        if (pc) {
          plugin.config.origin = pc.uri;
          this.checkPluginUpdate(plugin);
        }
      }
    }
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/pluginManager.js?`)},"./src/pluginParser.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseComponent", function() { return parseComponent; });
/* eslint-disable */
// Taken from https://github.com/vuejs/vue/blob/dev/packages/vue-template-compiler/browser.js
var splitRE = /\\r?\\n/g;
var emptyRE = /^\\s*$/;
var needFixRE = /^(\\r?\\n)*[\\t\\s]/;

var deIndent = function deindent(str) {
  if (!needFixRE.test(str)) {
    return str;
  }

  var lines = str.split(splitRE);
  var min = Infinity;
  var type, cur, c;

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];

    if (!emptyRE.test(line)) {
      if (!type) {
        c = line.charAt(0);

        if (c === " " || c === "\\t") {
          type = c;
          cur = count(line, type);

          if (cur < min) {
            min = cur;
          }
        } else {
          return str;
        }
      } else {
        cur = count(line, type);

        if (cur < min) {
          min = cur;
        }
      }
    }
  }

  return lines.map(function (line) {
    return line.slice(min);
  }).join("\\n");
};

function count(line, type) {
  var i = 0;

  while (line.charAt(i) === type) {
    i++;
  }

  return i;
}
/*  */


var emptyObject = Object.freeze({}); // these helpers produces better vm code in JS engines due to their
// explicitness and function inlining

function isUndef(v) {
  return v === undefined || v === null;
}
/**
 * Check if value is primitive
 */


function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || // $flow-disable-line
  typeof value === "symbol" || typeof value === "boolean";
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
/**
 * Get the raw type string of a value e.g. [object Object]
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === "[object Object]";
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}
/**
 * Convert a value to a string that is actually rendered.
 */

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(",");

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap("slot,component", true);
/**
 * Check if a attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
/**
 * Remove an item from an array
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether the object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});
/**
 * Capitalize a string.
 */

/**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

/**
 * Mix properties into target object.
 */

function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/**
 * Return same value
 */


var identity = function (_) {
  return _;
};
/**
 * Generate a static keys string from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(",");
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */

/**
 * Ensure a function is called only once.
 */

/*  */


var isUnaryTag = makeMap("area,base,br,col,embed,frame,hr,img,input,isindex,keygen," + "link,meta,param,source,track,wbr"); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap("address,article,aside,base,blockquote,body,caption,col,colgroup,dd," + "details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form," + "h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta," + "optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead," + "title,tr,track");
/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\\s*([^\\s"'<>\\/=]+)(?:\\s*(=)\\s*(?:"([^"]*)"+|'([^']*)'+|([^\\s"'=<>\`]+)))?/; // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset

var ncname = "[a-zA-Z_][\\\\w\\\\-\\\\.]*";
var qnameCapture = "((?:" + ncname + "\\\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\\s*(\\/?)>/;
var endTag = new RegExp("^<\\\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\\--/;
var conditionalComment = /^<!\\[/;
var IS_REGEX_CAPTURING_BROKEN = false;
"x".replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === "";
}); // Special Elements (can contain anything)

var isPlainTextElement = makeMap("script,style,textarea", true);
var reCache = {};
var decodingMap = {
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&amp;": "&",
  "&#10;": "\\n",
  "&#9;": "\\t"
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap("pre,textarea", true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === "\\n";
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf("<");

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf("-->");

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf("]>");

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf("<", 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = "";
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp("([\\\\s\\\\S]*?)(</" + stackedTag + "[^>]*>)", "i"));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== "noscript") {
          text = text.replace(/<!\\--([\\s\\S]*?)-->/g, "$1") // #7298
          .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, "$1");
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return "";
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if ( true && !stack.length && options.warn) {
        options.warn('Mal-formatted tag at end of template: "' + html + '"');
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === "p" && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i]; // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778

      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === "") {
          delete args[3];
        }

        if (args[4] === "") {
          delete args[4];
        }

        if (args[5] === "") {
          delete args[5];
        }
      }

      var value = args[3] || args[4] || args[5] || "";
      var shouldDecodeNewlines = tagName === "a" && args[1] === "href" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    } // Find the closest opened tag of the same type


    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === "br") {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === "p") {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var splitRE$1 = /\\r?\\n/g;
var replaceRE = /./g;
var isSpecialTag = makeMap("script,style,template", true);
/**
 * Parse a single-file component (*.vue) file into an SFC Descriptor Object.
 */

function parseComponent(content, options) {
  if (options === void 0) options = {};
  var sfc = {
    script: [],
    style: [],
    config: [],
    window: [],
    docs: [],
    attachment: [],
    link: [],
    others: []
  };
  var depth = 0;
  var currentBlock = null;

  function start(tag, attrs, unary, start, end) {
    if (depth === 0) {
      currentBlock = {
        type: tag,
        content: "",
        start: end,
        attrs: attrs.reduce(function (cumulated, ref) {
          var name = ref.name;
          var value = ref.value;
          cumulated[name] = value || true;
          return cumulated;
        }, {})
      };

      if (sfc[tag]) {
        checkAttrs(currentBlock, attrs);
        sfc[tag].push(currentBlock);
      } else {
        // custom blocks
        sfc.others.push(currentBlock);
      }
    }

    if (!unary) {
      depth++;
    }
  }

  function checkAttrs(block, attrs) {
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];

      if (attr.name === "lang") {
        block.lang = attr.value;
      }

      if (attr.name === "scoped") {
        block.scoped = true;
      }

      if (attr.name === "module") {
        block.module = attr.value || true;
      }

      if (attr.name === "src") {
        block.src = attr.value;
      }
    }
  }

  function end(tag, start, end) {
    if (depth === 1 && currentBlock) {
      currentBlock.end = start;
      var text = deIndent(content.slice(currentBlock.start, currentBlock.end)); // pad content so that linters and pre-processors can output correct
      // line numbers in errors and warnings

      if (currentBlock.type !== "template" && options.pad) {
        text = padContent(currentBlock, options.pad) + text;
      }

      currentBlock.content = text;
      currentBlock = null;
    }

    depth--;
  }

  function padContent(block, pad) {
    if (pad === "space") {
      return content.slice(0, block.start).replace(replaceRE, " ");
    } else {
      var offset = content.slice(0, block.start).split(splitRE$1).length;
      var padChar = block.type === "script" && !block.lang ? "//\\n" : "\\n";
      return Array(offset).join(padChar);
    }
  }

  parseHTML(content, {
    start: start,
    end: end
  });
  return sfc;
}

//# sourceURL=webpack://%5Bname%5D/./src/pluginParser.js?`)},"./src/serviceSpec.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serviceSpec", function() { return serviceSpec; });
const serviceSpec = {
  // add your service type schema here
  // you can use json-schema and additional keywords such as \`instanceof\`
  operator: {
    properties: {
      name: {
        type: "string"
      },
      ui: {
        type: ["null", "string", "array", "object"]
      },
      run: {
        instanceof: Function
      },
      inputs: {
        type: ["null", "object"]
      },
      outputs: {
        type: ["null", "object"]
      }
    }
  },
  "engine-factory": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["engine-factory"]
      },
      icon: {
        type: "string"
      },
      url: {
        type: "string"
      },
      config: {
        type: "object"
      },
      addEngine: {
        instanceof: Function
      },
      removeEngine: {
        instanceof: Function
      }
    }
  },
  engine: {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["engine"]
      },
      pluginType: {
        type: "string"
      },
      factory: {
        type: "string"
      },
      icon: {
        type: "string"
      },
      url: {
        type: "string"
      },
      config: {
        type: "object"
      },
      enable: {
        instanceof: Function
      },
      disable: {
        instanceof: Function
      },
      connect: {
        instanceof: Function
      },
      disconnect: {
        instanceof: Function
      },
      listPlugins: {
        instanceof: Function
      },
      startPlugin: {
        instanceof: Function
      },
      getPlugin: {
        instanceof: Function
      },
      getEngineStatus: {
        instanceof: Function
      },
      getEngineConfig: {
        instanceof: [Function, null]
      },
      heartbeat: {
        instanceof: [Function, null]
      },
      killPlugin: {
        instanceof: [Function, null]
      },
      killPluginProcess: {
        instanceof: [Function, null]
      },
      restartPlugin: {
        instanceof: [Function, null]
      },
      about: {
        instanceof: [Function, null]
      }
    }
  },
  "file-manager": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["file-manager"]
      },
      url: {
        type: "string"
      },
      shwoFileDialog: {
        instanceof: Function
      },
      listFiles: {
        instanceof: Function
      },
      getFile: {
        instanceof: Function
      },
      putFile: {
        instanceof: Function
      },
      requestUploadUrl: {
        instanceof: Function
      },
      getFileUrl: {
        instanceof: Function
      },
      removeFile: {
        instanceof: Function
      },
      heartbeat: {
        instanceof: [Function, null]
      }
    }
  },
  "@transformation": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["transformation"]
      },
      transform: {
        instanceof: Function
      },
      fit: {
        instanceof: Function
      },
      fit_transform: {
        instanceof: Function
      }
    },
    required: ["name", "type", "transform"]
  },
  "@model": {
    properties: {
      name: {
        type: "string"
      },
      type: {
        enum: ["model"]
      },
      predict: {
        instanceof: Function
      },
      fit: {
        instanceof: Function
      }
    },
    required: ["name", "type", "predict"]
  }
};

//# sourceURL=webpack://%5Bname%5D/./src/serviceSpec.js?`)},"./src/utils.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cacheUrlInServiceWorker", function() { return cacheUrlInServiceWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "html2string", function() { return html2string; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchDevice", function() { return isTouchDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Whenable", function() { return Whenable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersions", function() { return compareVersions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathJoin", function() { return pathJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirName", function() { return dirName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "url_regex", function() { return url_regex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animalGenerator", function() { return animalGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colourGenerator", function() { return colourGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randId", function() { return randId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_clone", function() { return _clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageEmitter", function() { return MessageEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Filters", function() { return Filters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUrl", function() { return isUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubUrlToObject", function() { return githubUrlToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubUrlRaw", function() { return githubUrlRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubImJoyManifest", function() { return githubImJoyManifest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "githubRepo", function() { return githubRepo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hot_lut", function() { return hot_lut; });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pluginParser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pluginParser.js */ "./src/pluginParser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseComponent", function() { return _pluginParser_js__WEBPACK_IMPORTED_MODULE_1__["parseComponent"]; });

/*eslint no-useless-escape: "off"*/


function cacheUrlInServiceWorker(url) {
  return new Promise(function (resolve, reject) {
    const message = {
      command: "add",
      url: url
    };

    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {
      reject("Service worker is not supported.");
      return;
    }

    const messageChannel = new MessageChannel();

    messageChannel.port1.onmessage = function (event) {
      if (event.data && event.data.error) {
        reject(event.data.error);
      } else {
        resolve(event.data && event.data.result);
      }
    };

    if (navigator.serviceWorker && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
    } else {
      reject("Service worker controller is not available");
    }
  });
}
function html2string(input) {
  return input && input.replace(/\\n/gm, "").replace(/<br>/gm, "\\n").replace(/<[^>]*>?/gm, "");
}
function assert(condition, message) {
  if (!condition) {
    message = message || "Assertion failed";

    if (typeof Error !== "undefined") {
      throw new Error(message);
    }

    throw message; // Fallback
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
/**
 * A special kind of event:
 *  - which can only be emitted once;
 *  - executes a set of subscribed handlers upon emission;
 *  - if a handler is subscribed after the event was emitted, it
 *    will be invoked immideately.
 *
 * Used for the events which only happen once (or do not happen at
 * all) during a single plugin lifecycle - connect, disconnect and
 * connection failure
 */

const Whenable = function (multi_emit) {
  this._multi_emit = multi_emit;
  this._emitted = false;
  this._handlers = [];
};
/**
 * Emits the Whenable event, calls all the handlers already
 * subscribed, switches the object to the 'emitted' state (when
 * all future subscibed listeners will be immideately issued
 * instead of being stored)
 */

Whenable.prototype.emit = function (e) {
  if (this._multi_emit) {
    this._emitted = true;
    this._e = e;

    for (let handler of this._handlers) {
      setTimeout(handler.bind(null, e), 0);
    }
  } else if (!this._emitted) {
    this._emitted = true;
    this._e = e;
    var handler;

    while (handler = this._handlers.pop()) {
      setTimeout(handler.bind(null, e), 0);
    }
  }
};
/**
 * Saves the provided function as a handler for the Whenable
 * event. This handler will then be called upon the event emission
 * (if it has not been emitted yet), or will be scheduled for
 * immediate issue (if the event has already been emmitted before)
 *
 * @param {Function} handler to subscribe for the event
 */


Whenable.prototype.whenEmitted = function (handler) {
  handler = this._checkHandler(handler);

  if (this._emitted) {
    setTimeout(handler.bind(null, this._e), 0);
  } else {
    this._handlers.push(handler);
  }
};
/**
 * Checks if the provided object is suitable for being subscribed
 * to the event (= is a function), throws an exception if not
 *
 * @param {Object} obj to check for being subscribable
 *
 * @throws {Exception} if object is not suitable for subscription
 *
 * @returns {Object} the provided object if yes
 */


Whenable.prototype._checkHandler = function (handler) {
  var type = typeof handler;

  if (type !== "function") {
    var msg = "A function may only be subsribed to the event, " + type + " was provided instead";
    throw new Error(msg);
  }

  return handler;
};

function compareVersions(v1, comparator, v2) {
  comparator = comparator == "=" ? "==" : comparator;

  if (["==", "===", "<", "<=", ">", ">=", "!=", "!=="].indexOf(comparator) == -1) {
    throw new Error("Invalid comparator. " + comparator);
  }

  var v1parts = v1.split("."),
      v2parts = v2.split(".");
  var maxLen = Math.max(v1parts.length, v2parts.length);
  var part1, part2;
  var cmp = 0;

  for (var i = 0; i < maxLen && !cmp; i++) {
    part1 = parseInt(v1parts[i], 10) || 0;
    part2 = parseInt(v2parts[i], 10) || 0;
    if (part1 < part2) cmp = 1;
    if (part1 > part2) cmp = -1;
  }

  return eval("0" + comparator + cmp);
}
function pathJoin()
/* path segments */
{
  // Split the inputs into a list of path commands.
  var parts = [];

  for (var i = 0, l = arguments.length; i < l; i++) {
    parts = parts.concat(arguments[i].split("/"));
  } // Interpret the path commands to get the new resolved path.


  var newParts = [];

  for (i = 0, l = parts.length; i < l; i++) {
    var part = parts[i]; // Remove leading and trailing slashes
    // Also remove "." segments

    if (!part || part === ".") continue; // Interpret ".." to pop the last segment

    if (part === "..") newParts.pop(); // Push new path segments.
    else newParts.push(part);
  } // Preserve the initial slash if there was one.


  if (parts[0] === "") newParts.unshift(""); // Turn back into a single string path.

  return newParts.join("/") || (newParts.length ? "/" : ".");
} // A simple function to get the dirname of a path
// Trailing slashes are ignored. Leading slash is preserved.

function dirName(path) {
  return pathJoin(path, "..");
} // wordgenjs from https://github.com/gurshabad/wordgenjs

const arrAnimals = ["Aardvark", "Albatross", "Alligator", "Alpaca", "Ant", "Anteater", "Antelope", "Ape", "Armadillo", "Ass_Donkey", "Baboon", "Badger", "Barracuda", "Bat", "Bear", "Beaver", "Bee", "Bison", "Boa", "Buffalo", "Butterfly", "Camel", "Capybara", "Caribou", "Cassowary", "Cat", "Caterpillar", "Cattle", "Chamois", "Cheetah", "Chicken", "Chimpanzee", "Chinchilla", "Chough", "Clam", "Cobra", "Cockroach", "Cod", "Cormorant", "Coyote", "Crab", "Crane", "Crocodile", "Crow", "Curlew", "Deer", "Dinosaur", "Dog", "Dogfish", "Dolphin", "Donkey", "Dotterel", "Dove", "Dragonfly", "Duck", "Dugong", "Dunlin", "Eagle", "Echidna", "Eel", "Eland", "Elephant", "Elephantseal", "Elk", "Emu", "Falcon", "Ferret", "Finch", "Fish", "Flamingo", "Fox", "Frog", "Gaur", "Gazelle", "Gerbil", "GiantPanda", "Giraffe", "Gnat", "Gnu", "Goat", "Goose", "Goldfinch", "Goldfish", "Gorilla", "Goshawk", "Grasshopper", "Grouse", "Guanaco", "Guineafowl", "Guineapig", "Gull", "Hamster", "Hare", "Hawk", "Hedgehog", "Heron", "Herring", "Hippopotamus", "Hornet", "Horse", "Human", "Hummingbird", "Hyena", "Ibex", "Ibis", "Jackal", "Jaguar", "Jay", "Jellyfish", "Kangaroo", "Kingfisher", "Koala", "Komodo", "Kookabura", "Kouprey", "Kudu", "Lapwing", "Lark", "Lemur", "Leopard", "Lion", "Llama", "Lobster", "Locust", "Loris", "Louse", "Lyrebird", "Magpie", "Mallard", "Manatee", "Mandrill", "Mantis", "Marten", "Meerkat", "Mink", "Mole", "Mongoose", "Monkey", "Moose", "Mouse", "Mosquito", "Mule", "Narwhal", "Newt", "Nightingale", "Octopus", "Okapi", "Opossum", "Oryx", "Ostrich", "Otter", "Owl", "Ox", "Oyster", "Panther", "Parrot", "Partridge", "Peafowl", "Pelican", "Penguin", "Pheasant", "Pig", "Pigeon", "PolarBear", "Pony", "Porcupine", "Porpoise", "PrairieDog", "Quail", "Quelea", "Quetzal", "Rabbit", "Raccoon", "Rail", "Ram", "Rat", "Raven", "Reddeer", "Redpanda", "Reindeer", "Rhinoceros", "Rook", "Salamander", "Salmon", "SandDollar", "Sandpiper", "Sardine", "Scorpion", "Sealion", "SeaUrchin", "Seahorse", "Seal", "Shark", "Sheep", "Shrew", "Skunk", "Snail", "Snake", "Sparrow", "Spider", "Spoonbill", "Squid", "Squirrel", "Starling", "Stingray", "Stinkbug", "Stork", "Swallow", "Swan", "Tapir", "Tarsier", "Termite", "Tiger", "Toad", "Trout", "Turkey", "Turtle", "Vicua", "Viper", "Vulture", "Wallaby", "Walrus", "Wasp", "Waterbuffalo", "Weasel", "Whale", "Wolf", "Wolverine", "Wombat", "Woodcock", "Woodpecker", "Worm", "Wren", "Yak", "Zebra"];
const arrColours = ["almond", "amaranthine", "amber", "amethyst", "antique", "apple", "apricot", "aqua", "aquamarine", "argent", "auburn", "avocado", "azure", "babyblue", "banana", "battleshipgray", "bay", "beige", "Bermudagreen", "beryl", "biceblue", "bicegreen", "bice", "biscuit", "bisque", "black", "blanchedalmond", "blazeorange", "blonde", "bloodred", "bluegreen", "blueviolet", "blue", "blueberry", "bone", "bottlegreen", "brass", "brickred", "bronzeyellow", "bronze", "brown", "buckskin", "buff", "burgundy", "burlywood", "burntorange", "burntsienna", "burntumber", "butterscotch", "cadetblue", "Cambridgeblue", "canary", "cardinal", "carmine", "carnation", "carnelian", "carroty", "celadon", "cerise", "cerulean", "chamois", "champagne", "charcoal", "chartreuse", "cherryred", "chestnut", "Chinesered", "chocolate", "cinereous", "cinnabar", "cinnamon", "citrine", "clairdelune", "claret", "coalblack", "cobaltblue", "cocoa", "coffee", "coolgray", "Copenhagenblue", "copper", "coral", "cornflowerblue", "cornflower", "cornsilk", "cream", "crimson", "cupreous", "cyan", "daffodil", "damask", "dandelion", "dovegray", "duckeggblue", "dun", "Dodgerblue", "eaudenil", "ebony", "ecru", "eggshellblue", "eggshell", "electricblue", "emeraldgreen", "emerald", "fawn", "federalyellow", "firebrick", "fireenginered", "flame", "flamingo", "flaxen", "flesh", "floralwhite", "forestgreen", "fuchsia", "fuscous", "gainsboro", "gamboge", "garnet", "gentianblue", "gentianviolet", "geranium", "ginger", "glaucous", "gold", "goldenbrown", "goldenrod", "goldochre", "grape", "grassgreen", "gray", "green", "grizzle", "gules", "gunmetalgray", "hazel", "heather", "heliotrope", "henna", "hepatic", "hoar", "honey", "honeydew", "hotpink", "huntergreen", "iceblue", "incarnadine", "Indianred", "indigo", "internationalorange", "irongray", "ivory", "jadegreen", "jade", "jet", "jonquil", "kellygreen", "Kendalgreen", "khaki", "khakigreen", "lapislazuli", "laurelgreen", "lavender", "lemonchiffon", "lemon", "lilac", "lime", "Lincolngreen", "linen", "liver", "loden", "lovat", "macaroniandcheese", "madder", "magenta", "magicmint", "magnolia", "mahogany", "malachite", "maroon", "mauve", "mazarine", "melon", "midnightblue", "mignonette", "militarygrey", "mint", "mintcream", "mistyrose", "moccasin", "mocha", "mossgreen", "mulberry", "mustard", "natural", "navajowhite", "navy", "Nileblue", "Nilegreen", "oak", "oatmeal", "oceangrey", "ochre", "offwhite", "oldgold", "oldlace", "olivedrab", "olive", "orange", "orchid", "outerspace", "oxblood", "Oxfordblue", "oyster", "pansy", "paprika", "Parisgreen", "patina", "peagreen", "peach", "peacockblue", "pearlgray", "pearly", "periwinkle", "perse", "petrolblue", "petunia", "pewter", "pillarboxred", "pinegreen", "pink", "pistachiogreen", "platinumblond", "platinum", "plum", "Pompeianred", "poppy", "powderblue", "primrose", "Prussianblue", "puce", "puke", "purple", "purpure", "quartz", "quince", "raspberry", "rawsienna", "redviolet", "red", "reseda", "riflegreen", "robin_seggblue", "rose", "rouge", "royalblue", "royalpurple", "ruby", "russet", "rust", "sable", "saddlebrown", "safetyorange", "saffron", "sagegreen", "salmon", "sand", "sandy", "sanguine", "sapphire", "sard", "saxeblue", "scarlet", "schoolbusyellow", "seagreen", "seashell", "sepia", "shockingpink", "sienna", "silver", "silvergray", "skyblue", "slate", "slateblack", "slateblue", "slategray", "smoke", "snow", "sorrel", "springgreen", "stammel", "steelblue", "stone", "straw", "strawberry", "sulfur", "sunflower", "tan", "tangerine", "taupe", "taxiyellow", "teak", "teal", "terracotta", "timberwolf", "titian", "topaz", "towcolored", "Turkeyred", "turquoise", "Tyrianpurple", "ultramarine", "umber", "Vandykebrown", "venetianred", "verdant", "vermilion", "vert", "violetred", "violet", "virid", "viridian", "vividorange", "walnut", "Wedgewoodblue", "wheat", "wheaten", "white", "wine", "xanthic", "yellow", "zaffre"];
const expression = /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9][^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})/gi;
const url_regex = new RegExp(expression);
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function () {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}
function animalGenerator() {
  const randAnimal = arrAnimals[Math.floor(Math.random() * arrAnimals.length)].toLowerCase();
  return randAnimal;
}
function colourGenerator() {
  const randColour = arrColours[Math.floor(Math.random() * arrColours.length)].toLowerCase();
  return randColour;
}
function randId() {
  return Math.random().toString(36).substr(2, 5) + Date.now();
} // Deep clone

function _clone(aObject) {
  if (!aObject) {
    return aObject;
  }

  var bObject, v, k;
  bObject = Array.isArray(aObject) ? [] : {};

  for (k in aObject) {
    v = aObject[k];
    bObject[k] = typeof v === "object" ? _clone(v) : v;
  }

  return bObject;
}
class MessageEmitter {
  constructor(debug) {
    this._event_handlers = {};
    this._once_handlers = {};
    this._debug = debug;
  }

  emit() {
    throw new Error("emit is not implemented");
  }

  on(event, handler) {
    if (!this._event_handlers[event]) {
      this._event_handlers[event] = [];
    }

    this._event_handlers[event].push(handler);
  }

  once(event, handler) {
    handler.___event_run_once = true;
    this.on(event, handler);
  }

  off(event, handler) {
    if (!event && !handler) {
      // remove all events handlers
      this._event_handlers = {};
    } else if (event && !handler) {
      // remove all hanlders for the event
      if (this._event_handlers[event]) this._event_handlers[event] = [];
    } else {
      // remove a specific handler
      if (this._event_handlers[event]) {
        const idx = this._event_handlers[event].indexOf(handler);

        if (idx >= 0) {
          this._event_handlers[event].splice(idx, 1);
        }
      }
    }
  }

  _fire(event, data) {
    if (this._event_handlers[event]) {
      var i = this._event_handlers[event].length;

      while (i--) {
        const handler = this._event_handlers[event][i];

        try {
          handler(data);
        } catch (e) {
          console.error(e);
        } finally {
          if (handler.___event_run_once) {
            this._event_handlers[event].splice(i, 1);
          }
        }
      }
    } else {
      if (this._debug) {
        console.warn("unhandled event", event, data);
      }
    }
  }

}
const Filters = {};

Filters.getPixels = function (canvas) {
  var c = canvas;
  var ctx = c.getContext("2d");
  return ctx.getImageData(0, 0, c.width, c.height);
};

Filters.filterImage = function (pixels, filter) {
  var args = [pixels];

  for (var i = 2; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  return filter.apply(null, args);
};

Filters.grayscale = function (pixels) {
  var d = pixels.data;

  for (var i = 0; i < d.length; i += 4) {
    var r = d[i];
    var g = d[i + 1];
    var b = d[i + 2]; // CIE luminance for the RGB
    // The human eye is bad at seeing red and blue, so we de-emphasize them.

    var v = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    d[i] = d[i + 1] = d[i + 2] = v;
  }

  return pixels;
};

Filters.brightness = function (pixels, offset, ratio) {
  var d = pixels.data;
  var v;

  for (var i = 0; i < d.length; i += 4) {
    v = parseInt((d[i] - offset) * ratio);

    if (v > 255) {
      v = 255;
    } else if (v < 0) {
      v = 0;
    }

    d[i] = v;
    d[i + 1] = v;
    d[i + 2] = v;
    d[i + 3] = 255; // fully opaque
  }

  return pixels;
};

Filters.min_max = function (pixels) {
  var d = pixels.data;
  var min = Number.POSITIVE_INFINITY,
      max = Number.NEGATIVE_INFINITY,
      avg = 0;

  for (var i = 0; i < d.length; i += 4) {
    if (d[i] < min) min = d[i];
    if (d[i] > max) max = d[i];
    avg += d[i] / (d.length / 4);
  }

  return {
    min: min,
    max: max,
    avg: avg
  };
};

Filters.lut = function (pixels, lut) {
  var d = pixels.data;
  var v;

  for (var i = 0; i < d.length; i += 4) {
    v = d[i];
    d[i] = lut[v][0];
    d[i + 1] = lut[v][1];
    d[i + 2] = lut[v][2];
    d[i + 3] = 255; // fully opaque
  }

  return pixels;
}; // from https://github.com/segmentio/is-url

/**
 * RegExps.
 * A URL must match #1 and then at least one of #2/#3.
 * Use two levels of REs to avoid REDOS.
 */


const protocolAndDomainRE = /^(?:\\w+:)?\\/\\/([\\s\\S]+)$/;
const localhostDomainRE = /^localhost[\\:?\\d]*(?:[^\\:?\\d][\\s\\S]*)?$/;
const nonLocalhostDomainRE = /^[^\\s\\.]+\\.[\\s\\S]{2,}$/;
/**
 * Loosely validate a URL \`string\`.
 *
 * @param {String} string
 * @return {Boolean}
 */

function isUrl(string) {
  if (typeof string !== "string") {
    return false;
  }

  var match = string.match(protocolAndDomainRE);

  if (!match) {
    return false;
  }

  var everythingAfterProtocol = match[1];

  if (!everythingAfterProtocol) {
    return false;
  }

  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
    return true;
  }

  return false;
} //from: https://github.com/github-modules/github-url-to-object/blob/master/index.js

const laxUrlRegex = /(?:(?:[^:]+:)?[/][/])?(?:.+@)?([^/]+)([/][^?#]+)/;
function githubUrlToObject(repoUrl, opts) {
  var obj = {};
  opts = opts || {};
  if (!repoUrl) return null; // Allow an object with nested \`url\` string
  // (common practice in package.json files)

  if (repoUrl.url) repoUrl = repoUrl.url;
  if (typeof repoUrl !== "string") return null;
  var shorthand = repoUrl.match(/^([\\w-_]+)\\/([\\w-_\\.]+)(?:#([\\w-_\\.]+))?$/);
  var mediumhand = repoUrl.match(/^github:([\\w-_]+)\\/([\\w-_\\.]+)(?:#([\\w-_\\.]+))?$/);
  var antiquated = repoUrl.match(/^git@[\\w-_\\.]+:([\\w-_]+)\\/([\\w-_\\.]+)$/);

  if (shorthand) {
    obj.user = shorthand[1];
    obj.repo = shorthand[2];
    obj.branch = shorthand[3] || "master";
    obj.host = "github.com";
  } else if (mediumhand) {
    obj.user = mediumhand[1];
    obj.repo = mediumhand[2];
    obj.branch = mediumhand[3] || "master";
    obj.host = "github.com";
  } else if (antiquated) {
    obj.user = antiquated[1];
    obj.repo = antiquated[2].replace(/\\.git$/i, "");
    obj.branch = "master";
    obj.host = "github.com";
  } else {
    // Turn git+http URLs into http URLs
    repoUrl = repoUrl.replace(/^git\\+/, "");
    if (!isUrl(repoUrl)) return null;
    const [, hostname, pathname] = repoUrl.match(laxUrlRegex) || [];
    if (!hostname) return null;
    if (hostname !== "github.com" && hostname !== "www.github.com" && !opts.enterprise) return null;
    var parts = pathname.match(/^\\/([\\w-_]+)\\/([\\w-_\\.]+)(\\/tree\\/[\\w-_\\.\\/]+)?(\\/blob\\/[\\s\\w-_\\.\\/]+)?/); // ([\\w-_\\.]+)

    if (!parts) return null;
    obj.user = parts[1];
    obj.repo = parts[2].replace(/\\.git$/i, "");
    obj.host = hostname || "github.com";

    if (parts[3] && /^\\/tree\\/master\\//.test(parts[3])) {
      obj.branch = "master";
      obj.path = parts[3].replace(/\\/$/, "");
    } else if (parts[3]) {
      obj.branch = parts[3].replace(/^\\/tree\\//, "").match(/[\\w-_.]+\\/{0,1}[\\w-_]+/)[0];
    } else if (parts[4]) {
      obj.branch = parts[4].replace(/^\\/blob\\//, "").match(/[\\w-_.]+\\/{0,1}[\\w-_]+/)[0];
    } else {
      obj.branch = "master";
    }
  }

  if (obj.host === "github.com") {
    obj.apiHost = "api.github.com";
  } else {
    obj.apiHost = \`\${obj.host}/api/v3\`;
  }

  obj.tarball_url = \`https://\${obj.apiHost}/repos/\${obj.user}/\${obj.repo}/tarball/\${obj.branch}\`;
  obj.clone_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}\`;

  if (obj.branch === "master") {
    obj.https_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}\`;
    obj.travis_url = \`https://travis-ci.org/\${obj.user}/\${obj.repo}\`;
    obj.zip_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}/archive/master.zip\`;
  } else {
    obj.https_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}/blob/\${obj.branch}\`;
    obj.travis_url = \`https://travis-ci.org/\${obj.user}/\${obj.repo}?branch=\${obj.branch}\`;
    obj.zip_url = \`https://\${obj.host}/\${obj.user}/\${obj.repo}/archive/\${obj.branch}.zip\`;
  } // Support deep paths (like lerna-style repos)


  if (obj.path) {
    obj.https_url += obj.path;
  }

  obj.api_url = \`https://\${obj.apiHost}/repos/\${obj.user}/\${obj.repo}\`;
  return obj;
} // from: https://github.com/Elixirdoc/github-url-raw

async function githubUrlRaw(url) {
  if (url.includes("gist.github.com")) {
    const gistId = url.split("/").slice(-1)[0];
    const response = await axios__WEBPACK_IMPORTED_MODULE_0___default.a.get("https://api.github.com/gists/" + gistId);

    if (response.status === 200) {
      // TODO: handle multiple files, e.g.: display them all
      const plugin_file = Object.values(response.data.files).filter(file => {
        return file.filename.endsWith(".imjoy.html");
      })[0];
      return plugin_file.raw_url;
    } else {
      throw "Failed to fetch from Gist: " + response.statusText;
    }
  }

  if (!url.includes("blob") || !url.includes("github")) {
    return null;
  }

  var ghObj = githubUrlToObject(url);
  var githubUser = ghObj.user;
  var githubRepo = ghObj.repo; // var githubBranch = ghObj.branch;

  var re = new RegExp("^https://github.com/" + githubUser + "/" + githubRepo + "/blob/", "g");
  var regStr = url.replace(re, "");
  return "https://raw.githubusercontent.com/" + githubUser + "/" + githubRepo + "/" + regStr;
}
function githubImJoyManifest(url) {
  var ghObj = githubUrlToObject(url);
  var githubUser = ghObj.user;
  var githubRepo = ghObj.repo;
  var githubBranch = ghObj.branch;
  return "https://raw.githubusercontent.com/" + githubUser + "/" + githubRepo + "/" + githubBranch + "/manifest.imjoy.json";
}
function githubRepo(url) {
  var ghObj = githubUrlToObject(url);
  return ghObj.user + "/" + ghObj.repo;
}
const hot_lut = [[10, 0, 0], [13, 0, 0], [15, 0, 0], [18, 0, 0], [21, 0, 0], [23, 0, 0], [26, 0, 0], [28, 0, 0], [31, 0, 0], [34, 0, 0], [36, 0, 0], [39, 0, 0], [42, 0, 0], [44, 0, 0], [47, 0, 0], [49, 0, 0], [52, 0, 0], [55, 0, 0], [57, 0, 0], [60, 0, 0], [63, 0, 0], [65, 0, 0], [68, 0, 0], [70, 0, 0], [73, 0, 0], [76, 0, 0], [78, 0, 0], [81, 0, 0], [84, 0, 0], [86, 0, 0], [89, 0, 0], [91, 0, 0], [94, 0, 0], [97, 0, 0], [99, 0, 0], [102, 0, 0], [105, 0, 0], [107, 0, 0], [110, 0, 0], [112, 0, 0], [115, 0, 0], [118, 0, 0], [120, 0, 0], [123, 0, 0], [126, 0, 0], [128, 0, 0], [131, 0, 0], [133, 0, 0], [136, 0, 0], [139, 0, 0], [141, 0, 0], [144, 0, 0], [147, 0, 0], [149, 0, 0], [152, 0, 0], [154, 0, 0], [157, 0, 0], [160, 0, 0], [162, 0, 0], [165, 0, 0], [168, 0, 0], [170, 0, 0], [173, 0, 0], [175, 0, 0], [178, 0, 0], [181, 0, 0], [183, 0, 0], [186, 0, 0], [189, 0, 0], [191, 0, 0], [194, 0, 0], [196, 0, 0], [199, 0, 0], [202, 0, 0], [204, 0, 0], [207, 0, 0], [210, 0, 0], [212, 0, 0], [215, 0, 0], [217, 0, 0], [220, 0, 0], [223, 0, 0], [225, 0, 0], [228, 0, 0], [231, 0, 0], [233, 0, 0], [236, 0, 0], [238, 0, 0], [241, 0, 0], [244, 0, 0], [246, 0, 0], [249, 0, 0], [252, 0, 0], [254, 0, 0], [255, 2, 0], [255, 5, 0], [255, 7, 0], [255, 10, 0], [255, 12, 0], [255, 15, 0], [255, 18, 0], [255, 20, 0], [255, 23, 0], [255, 26, 0], [255, 28, 0], [255, 31, 0], [255, 33, 0], [255, 36, 0], [255, 39, 0], [255, 41, 0], [255, 44, 0], [255, 47, 0], [255, 49, 0], [255, 52, 0], [255, 54, 0], [255, 57, 0], [255, 60, 0], [255, 62, 0], [255, 65, 0], [255, 68, 0], [255, 70, 0], [255, 73, 0], [255, 75, 0], [255, 78, 0], [255, 81, 0], [255, 83, 0], [255, 86, 0], [255, 89, 0], [255, 91, 0], [255, 94, 0], [255, 96, 0], [255, 99, 0], [255, 102, 0], [255, 104, 0], [255, 107, 0], [255, 110, 0], [255, 112, 0], [255, 115, 0], [255, 117, 0], [255, 120, 0], [255, 123, 0], [255, 125, 0], [255, 128, 0], [255, 131, 0], [255, 133, 0], [255, 136, 0], [255, 138, 0], [255, 141, 0], [255, 144, 0], [255, 146, 0], [255, 149, 0], [255, 151, 0], [255, 154, 0], [255, 157, 0], [255, 159, 0], [255, 162, 0], [255, 165, 0], [255, 167, 0], [255, 170, 0], [255, 172, 0], [255, 175, 0], [255, 178, 0], [255, 180, 0], [255, 183, 0], [255, 186, 0], [255, 188, 0], [255, 191, 0], [255, 193, 0], [255, 196, 0], [255, 199, 0], [255, 201, 0], [255, 204, 0], [255, 207, 0], [255, 209, 0], [255, 212, 0], [255, 214, 0], [255, 217, 0], [255, 220, 0], [255, 222, 0], [255, 225, 0], [255, 228, 0], [255, 230, 0], [255, 233, 0], [255, 235, 0], [255, 238, 0], [255, 241, 0], [255, 243, 0], [255, 246, 0], [255, 249, 0], [255, 251, 0], [255, 254, 0], [255, 255, 2], [255, 255, 6], [255, 255, 10], [255, 255, 14], [255, 255, 18], [255, 255, 22], [255, 255, 26], [255, 255, 30], [255, 255, 34], [255, 255, 38], [255, 255, 42], [255, 255, 46], [255, 255, 50], [255, 255, 54], [255, 255, 58], [255, 255, 62], [255, 255, 65], [255, 255, 69], [255, 255, 73], [255, 255, 77], [255, 255, 81], [255, 255, 85], [255, 255, 89], [255, 255, 93], [255, 255, 97], [255, 255, 101], [255, 255, 105], [255, 255, 109], [255, 255, 113], [255, 255, 117], [255, 255, 121], [255, 255, 125], [255, 255, 128], [255, 255, 132], [255, 255, 136], [255, 255, 140], [255, 255, 144], [255, 255, 148], [255, 255, 152], [255, 255, 156], [255, 255, 160], [255, 255, 164], [255, 255, 168], [255, 255, 172], [255, 255, 176], [255, 255, 180], [255, 255, 184], [255, 255, 188], [255, 255, 191], [255, 255, 195], [255, 255, 199], [255, 255, 203], [255, 255, 207], [255, 255, 211], [255, 255, 215], [255, 255, 219], [255, 255, 223], [255, 255, 227], [255, 255, 231], [255, 255, 235], [255, 255, 239], [255, 255, 243], [255, 255, 247], [255, 255, 251], [255, 255, 255]];

//# sourceURL=webpack://%5Bname%5D/./src/utils.js?`)},"./src/windowManager.js":function(module,__webpack_exports__,__webpack_require__){eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WindowManager", function() { return WindowManager; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");

class WindowManager {
  constructor({
    event_bus = null
  }) {
    this.event_bus = event_bus;
    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(this.event_bus);
    this.windows = [];
    this.window_ids = {};
    this.active_windows = [];
    this.selected_window = null;
    this.window_mode = "grid";
    this.registered_inputs = {};
    this.registered_loaders = {};
    this.default_window_pos = {
      x: 0,
      y: 0,
      w: 20,
      h: 10,
      index: 0
    };
  }

  generateGridPosition(config) {
    config.i = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
    config.index = this.default_window_pos.index;
    config.w = config.w || this.default_window_pos.w;
    config.h = config.h || this.default_window_pos.h;

    if (config.x === undefined) {
      config.x = this.default_window_pos.x;
      this.default_window_pos.x = this.default_window_pos.x + this.default_window_pos.w;
    }

    if (config.y === undefined) {
      config.y = this.default_window_pos.y;
    }

    if (this.default_window_pos.x >= 20) {
      this.default_window_pos.x = 0;
      this.default_window_pos.y = this.default_window_pos.y + this.default_window_pos.h;
    }

    this.default_window_pos.index = this.default_window_pos.index + 1;
  }

  registerInputLoader(op_key, inputs, loader) {
    if (this.registered_inputs[op_key]) console.log(\`WARNING: input loader \${op_key} already exists, it will be replaced.\`);
    this.registered_inputs[op_key] = inputs;
    this.registered_loaders[op_key] = loader;
  }

  unregisterInputLoader(op_key) {
    delete this.registered_inputs[op_key];
    delete this.registered_loaders[op_key];
  }

  getDataLoaders(data) {
    const loaders = {}; // find all the plugins registered for this type

    for (let k in this.registered_inputs) {
      if (this.registered_inputs[k].loader_key && this.registered_inputs[k].schema(data)) {
        try {
          const loader_key = this.registered_inputs[k].loader_key;

          if (this.registered_loaders[loader_key]) {
            loaders[loader_key] = this.registered_loaders[loader_key];
          }
        } catch (e) {
          console.error("Failed to get loaders.", e);
        }
      }
    }

    return loaders;
  }

  closeWindow(w) {
    const index = this.windows.indexOf(w);

    if (index > -1) {
      this.windows.splice(index, 1);
      delete this.window_ids[w.id];
    }

    if (w.selected || this.selected_window === w) {
      w.selected = false;

      if (this.window_mode === "single") {
        this.selected_window = this.windows[0];
      } else {
        this.selected_window = null;
      }
    }

    this.event_bus.emit("close_window", w);
  }

  setupCallbacks(w) {
    w._callbacks = w._callbacks || {};
    w.api = w.api || {};

    w.api.on = (name, handler, fire_if_emitted) => {
      if (w._callbacks[name]) {
        w._callbacks[name].push(handler);
      } else {
        w._callbacks[name] = [handler];
      }

      if (fire_if_emitted && w._callbacks[name].emitted) {
        handler(w._callbacks[name].emitted_data);
      }
    };

    w.api.off = (name, handler) => {
      if (w._callbacks[name]) {
        if (handler) {
          const handlers = w._callbacks[name];
          const idx = handlers.indexOf(handler);

          if (idx >= 0) {
            handlers.splice(idx, 1);
          } else {
            console.warn(\`callback \${name} does not exist.\`);
          }
        } else {
          delete w._callbacks[name];
        }
      } else {
        console.warn(\`callback \${name} does not exist.\`);
      }
    };

    w.api.emit = (name, data) => {
      // eslint-disable-next-line no-async-promise-executor
      return new Promise(async (resolve, reject) => {
        const errors = [];

        try {
          if (w._callbacks[name]) {
            for (let cb of w._callbacks[name]) {
              try {
                await cb(data !== undefined ? data : undefined);
              } catch (e) {
                errors.push(e);
                console.error(e);
              }
            }
          } else {
            // if no handler set, store the data
            w._callbacks[name] = [];
            w._callbacks[name].emitted = true;
            w._callbacks[name].emitted_data = data;
          }

          if (errors.length <= 0) {
            resolve();
          } else {
            reject(errors);
          }
        } catch (e) {
          reject(e);
        }
      });
    };

    w._refresh_callbacks = [];

    w.api.refresh = w.refresh = async () => {
      await Promise.all(w._refresh_callbacks.map(item => item()));
    };

    w._resize_callbacks = [];

    w.api.resize = w.resize = async contentRect => {
      contentRect = contentRect || w.$el && w.$el.getBoundingClientRect();
      w.api.emit("resize", contentRect);
    };

    w.api.focus = w.focus = () => {
      w.api.emit("focus");
    };

    w.api.show = w.show = () => {
      this.selectWindow(w);
      w.api.emit("show");
    };

    w.api.hide = w.hide = () => {
      w.api.emit("hide");
    };

    w.api.close = w.close = () => {
      return new Promise(resolve => {
        w.api.emit("close"); // leave 800ms for handling close events

        setTimeout(() => {
          this.closeWindow(w);
          resolve();
        }, 800);
      });
    };
  }

  addWindow(w) {
    return new Promise((resolve, reject) => {
      try {
        w.id = w.id || w.name + Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["randId"])();
        if (!w.dialog) this.generateGridPosition(w);

        if (w.standalone) {
          w.h = 0;
          w.w = 0;
        }

        if (this.window_ids[w.id]) {
          this.windows.splice(this.windows.indexOf(this.window_ids[w.id]), 1);
        }

        this.windows.push(w);
        this.window_ids[w.id] = w;
        this.setupCallbacks(w);
        this.selectWindow(w);
        this.event_bus.emit("add_window", w);
        let checkingTimer = null;
        let count = 40;

        const checkWindowReady = function () {
          const window_id = document.getElementById(w.window_id);

          if (window_id) {
            clearInterval(checkingTimer);
            resolve(w.id);
          }

          if (count-- < 0) {
            clearInterval(checkingTimer);
            reject(\`Failed to create window (element with id=\${w.window_id} not detected in 2s).\`);
          }
        };

        checkingTimer = setInterval(checkWindowReady, 50); //hack for testing

        if (w.__test__mode__) {
          w.api.emit("ready");
        }
      } catch (e) {
        reject(e);
      }
    });
  }

  selectWindow(w) {
    if (!w) return;

    if (w.dialog) {
      w.selected = true;
      this.active_windows = [w];
    } else {
      for (let i = 0; i < this.active_windows.length; i++) {
        if (this.active_windows[i]) {
          this.active_windows[i].selected = false;
          this.active_windows[i].refresh();
        }
      }

      if (this.window_mode === "single" || w.standalone) {
        this.selected_window = w;
      } else {
        this.selected_window = null;
      }

      this.active_windows = [w];
      if (!w.standalone && w.focus) w.focus();
    }

    w.selected = true;

    if (w.refresh) {
      w.refresh();
    }
  }

  resizeAll() {
    for (var i = this.windows.length; i--;) {
      try {
        this.windows[i].resize();
      } catch (e) {}
    }
  }

  closeAll() {
    const current_index = this.default_window_pos && this.default_window_pos.index || 0;
    this.default_window_pos = {
      i: 0,
      x: 0,
      y: 0,
      w: 20,
      h: 10,
      index: current_index
    };
    this.status_text = "";

    for (var i = this.windows.length; i--;) {
      if (this.windows[i].type != "imjoy/plugin-editor") {
        // delete this.window_ids[this.windows[i].id]
        // this.windows.splice(i, 1);
        this.windows[i].close();
      }
    }

    if (this.windows.length === 0) {
      this.default_window_pos.index = 0;
    } //this.event_bus.emit('close_window')

  }

  destroy() {
    this.disconnect();
  }

}

//# sourceURL=webpack://%5Bname%5D/./src/windowManager.js?`)},0:function(module,exports){eval(`/* (ignored) */

//# sourceURL=webpack://%5Bname%5D/./nextTick_(ignored)?`)}})})})(imjoyCore$1);var imjoyCoreExports=imjoyCore$1.exports,imjoyCore=imjoyCoreExports,lib={},Mosaic$1={},baseGetTag$3=_baseGetTag,isObject$9=isObject_1,asyncTag="[object AsyncFunction]",funcTag$2="[object Function]",genTag$1="[object GeneratorFunction]",proxyTag="[object Proxy]";function isFunction$2(_){if(!isObject$9(_))return!1;var j=baseGetTag$3(_);return j==funcTag$2||j==genTag$1||j==asyncTag||j==proxyTag}var isFunction_1=isFunction$2,root$7=_root,coreJsData$1=root$7["__core-js_shared__"],_coreJsData=coreJsData$1,coreJsData=_coreJsData,maskSrcKey=function(){var _=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||"");return _?"Symbol(src)_1."+_:""}();function isMasked$1(_){return!!maskSrcKey&&maskSrcKey in _}var _isMasked=isMasked$1,funcProto$1=Function.prototype,funcToString$1=funcProto$1.toString;function toSource$2(_){if(_!=null){try{return funcToString$1.call(_)}catch{}try{return _+""}catch{}}return""}var _toSource=toSource$2,isFunction$1=isFunction_1,isMasked=_isMasked,isObject$8=isObject_1,toSource$1=_toSource,reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reIsHostCtor=/^\[object .+?Constructor\]$/,funcProto=Function.prototype,objectProto$e=Object.prototype,funcToString=funcProto.toString,hasOwnProperty$c=objectProto$e.hasOwnProperty,reIsNative=RegExp("^"+funcToString.call(hasOwnProperty$c).replace(reRegExpChar,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function baseIsNative$1(_){if(!isObject$8(_)||isMasked(_))return!1;var j=isFunction$1(_)?reIsNative:reIsHostCtor;return j.test(toSource$1(_))}var _baseIsNative=baseIsNative$1;function getValue$1(_,j){return _==null?void 0:_[j]}var _getValue=getValue$1,baseIsNative=_baseIsNative,getValue=_getValue;function getNative$7(_,j){var $=getValue(_,j);return baseIsNative($)?$:void 0}var _getNative=getNative$7,getNative$6=_getNative,defineProperty$2=function(){try{var _=getNative$6(Object,"defineProperty");return _({},"",{}),_}catch{}}(),_defineProperty$5=defineProperty$2,defineProperty$1=_defineProperty$5;function baseAssignValue$3(_,j,$){j=="__proto__"&&defineProperty$1?defineProperty$1(_,j,{configurable:!0,enumerable:!0,value:$,writable:!0}):_[j]=$}var _baseAssignValue=baseAssignValue$3;function arrayAggregator$1(_,j,$,_e){for(var et=-1,tt=_==null?0:_.length;++et<tt;){var nt=_[et];j(_e,nt,$(nt),_)}return _e}var _arrayAggregator=arrayAggregator$1;function createBaseFor$1(_){return function(j,$,_e){for(var et=-1,tt=Object(j),nt=_e(j),rt=nt.length;rt--;){var at=nt[_?rt:++et];if($(tt[at],at,tt)===!1)break}return j}}var _createBaseFor=createBaseFor$1,createBaseFor=_createBaseFor,baseFor$1=createBaseFor(),_baseFor=baseFor$1;function baseTimes$1(_,j){for(var $=-1,_e=Array(_);++$<_;)_e[$]=j($);return _e}var _baseTimes=baseTimes$1,baseGetTag$2=_baseGetTag,isObjectLike$5=isObjectLike_1,argsTag$3="[object Arguments]";function baseIsArguments$1(_){return isObjectLike$5(_)&&baseGetTag$2(_)==argsTag$3}var _baseIsArguments=baseIsArguments$1,baseIsArguments=_baseIsArguments,isObjectLike$4=isObjectLike_1,objectProto$d=Object.prototype,hasOwnProperty$b=objectProto$d.hasOwnProperty,propertyIsEnumerable$1=objectProto$d.propertyIsEnumerable,isArguments$4=baseIsArguments(function(){return arguments}())?baseIsArguments:function(_){return isObjectLike$4(_)&&hasOwnProperty$b.call(_,"callee")&&!propertyIsEnumerable$1.call(_,"callee")},isArguments_1=isArguments$4,isArray$c=Array.isArray,isArray_1=isArray$c,isBuffer$4={exports:{}};function stubFalse(){return!1}var stubFalse_1=stubFalse;isBuffer$4.exports;(function(_,j){var $=_root,_e=stubFalse_1,et=j&&!j.nodeType&&j,tt=et&&!0&&_&&!_.nodeType&&_,nt=tt&&tt.exports===et,rt=nt?$.Buffer:void 0,at=rt?rt.isBuffer:void 0,it=at||_e;_.exports=it})(isBuffer$4,isBuffer$4.exports);var isBufferExports=isBuffer$4.exports,MAX_SAFE_INTEGER$1=9007199254740991,reIsUint=/^(?:0|[1-9]\d*)$/;function isIndex$3(_,j){var $=typeof _;return j=j??MAX_SAFE_INTEGER$1,!!j&&($=="number"||$!="symbol"&&reIsUint.test(_))&&_>-1&&_%1==0&&_<j}var _isIndex=isIndex$3,MAX_SAFE_INTEGER=9007199254740991;function isLength$3(_){return typeof _=="number"&&_>-1&&_%1==0&&_<=MAX_SAFE_INTEGER}var isLength_1=isLength$3,baseGetTag$1=_baseGetTag,isLength$2=isLength_1,isObjectLike$3=isObjectLike_1,argsTag$2="[object Arguments]",arrayTag$2="[object Array]",boolTag$3="[object Boolean]",dateTag$3="[object Date]",errorTag$2="[object Error]",funcTag$1="[object Function]",mapTag$6="[object Map]",numberTag$3="[object Number]",objectTag$3="[object Object]",regexpTag$3="[object RegExp]",setTag$6="[object Set]",stringTag$3="[object String]",weakMapTag$2="[object WeakMap]",arrayBufferTag$3="[object ArrayBuffer]",dataViewTag$4="[object DataView]",float32Tag$2="[object Float32Array]",float64Tag$2="[object Float64Array]",int8Tag$2="[object Int8Array]",int16Tag$2="[object Int16Array]",int32Tag$2="[object Int32Array]",uint8Tag$2="[object Uint8Array]",uint8ClampedTag$2="[object Uint8ClampedArray]",uint16Tag$2="[object Uint16Array]",uint32Tag$2="[object Uint32Array]",typedArrayTags={};typedArrayTags[float32Tag$2]=typedArrayTags[float64Tag$2]=typedArrayTags[int8Tag$2]=typedArrayTags[int16Tag$2]=typedArrayTags[int32Tag$2]=typedArrayTags[uint8Tag$2]=typedArrayTags[uint8ClampedTag$2]=typedArrayTags[uint16Tag$2]=typedArrayTags[uint32Tag$2]=!0;typedArrayTags[argsTag$2]=typedArrayTags[arrayTag$2]=typedArrayTags[arrayBufferTag$3]=typedArrayTags[boolTag$3]=typedArrayTags[dataViewTag$4]=typedArrayTags[dateTag$3]=typedArrayTags[errorTag$2]=typedArrayTags[funcTag$1]=typedArrayTags[mapTag$6]=typedArrayTags[numberTag$3]=typedArrayTags[objectTag$3]=typedArrayTags[regexpTag$3]=typedArrayTags[setTag$6]=typedArrayTags[stringTag$3]=typedArrayTags[weakMapTag$2]=!1;function baseIsTypedArray$1(_){return isObjectLike$3(_)&&isLength$2(_.length)&&!!typedArrayTags[baseGetTag$1(_)]}var _baseIsTypedArray=baseIsTypedArray$1;function baseUnary$3(_){return function(j){return _(j)}}var _baseUnary=baseUnary$3,_nodeUtil={exports:{}};_nodeUtil.exports;(function(_,j){var $=_freeGlobal,_e=j&&!j.nodeType&&j,et=_e&&!0&&_&&!_.nodeType&&_,tt=et&&et.exports===_e,nt=tt&&$.process,rt=function(){try{var at=et&&et.require&&et.require("util").types;return at||nt&&nt.binding&&nt.binding("util")}catch{}}();_.exports=rt})(_nodeUtil,_nodeUtil.exports);var _nodeUtilExports=_nodeUtil.exports,baseIsTypedArray=_baseIsTypedArray,baseUnary$2=_baseUnary,nodeUtil$2=_nodeUtilExports,nodeIsTypedArray=nodeUtil$2&&nodeUtil$2.isTypedArray,isTypedArray$3=nodeIsTypedArray?baseUnary$2(nodeIsTypedArray):baseIsTypedArray,isTypedArray_1=isTypedArray$3,baseTimes=_baseTimes,isArguments$3=isArguments_1,isArray$b=isArray_1,isBuffer$3=isBufferExports,isIndex$2=_isIndex,isTypedArray$2=isTypedArray_1,objectProto$c=Object.prototype,hasOwnProperty$a=objectProto$c.hasOwnProperty;function arrayLikeKeys$2(_,j){var $=isArray$b(_),_e=!$&&isArguments$3(_),et=!$&&!_e&&isBuffer$3(_),tt=!$&&!_e&&!et&&isTypedArray$2(_),nt=$||_e||et||tt,rt=nt?baseTimes(_.length,String):[],at=rt.length;for(var it in _)(j||hasOwnProperty$a.call(_,it))&&!(nt&&(it=="length"||et&&(it=="offset"||it=="parent")||tt&&(it=="buffer"||it=="byteLength"||it=="byteOffset")||isIndex$2(it,at)))&&rt.push(it);return rt}var _arrayLikeKeys=arrayLikeKeys$2,objectProto$b=Object.prototype;function isPrototype$4(_){var j=_&&_.constructor,$=typeof j=="function"&&j.prototype||objectProto$b;return _===$}var _isPrototype=isPrototype$4;function overArg$2(_,j){return function($){return _(j($))}}var _overArg=overArg$2,overArg$1=_overArg,nativeKeys$1=overArg$1(Object.keys,Object),_nativeKeys=nativeKeys$1,isPrototype$3=_isPrototype,nativeKeys=_nativeKeys,objectProto$a=Object.prototype,hasOwnProperty$9=objectProto$a.hasOwnProperty;function baseKeys$2(_){if(!isPrototype$3(_))return nativeKeys(_);var j=[];for(var $ in Object(_))hasOwnProperty$9.call(_,$)&&$!="constructor"&&j.push($);return j}var _baseKeys=baseKeys$2,isFunction=isFunction_1,isLength$1=isLength_1;function isArrayLike$4(_){return _!=null&&isLength$1(_.length)&&!isFunction(_)}var isArrayLike_1=isArrayLike$4,arrayLikeKeys$1=_arrayLikeKeys,baseKeys$1=_baseKeys,isArrayLike$3=isArrayLike_1;function keys$6(_){return isArrayLike$3(_)?arrayLikeKeys$1(_):baseKeys$1(_)}var keys_1=keys$6,baseFor=_baseFor,keys$5=keys_1;function baseForOwn$1(_,j){return _&&baseFor(_,j,keys$5)}var _baseForOwn=baseForOwn$1,isArrayLike$2=isArrayLike_1;function createBaseEach$1(_,j){return function($,_e){if($==null)return $;if(!isArrayLike$2($))return _($,_e);for(var et=$.length,tt=j?et:-1,nt=Object($);(j?tt--:++tt<et)&&_e(nt[tt],tt,nt)!==!1;);return $}}var _createBaseEach=createBaseEach$1,baseForOwn=_baseForOwn,createBaseEach=_createBaseEach,baseEach$1=createBaseEach(baseForOwn),_baseEach=baseEach$1,baseEach=_baseEach;function baseAggregator$1(_,j,$,_e){return baseEach(_,function(et,tt,nt){j(_e,et,$(et),nt)}),_e}var _baseAggregator=baseAggregator$1;function listCacheClear$1(){this.__data__=[],this.size=0}var _listCacheClear=listCacheClear$1;function eq$3(_,j){return _===j||_!==_&&j!==j}var eq_1=eq$3,eq$2=eq_1;function assocIndexOf$4(_,j){for(var $=_.length;$--;)if(eq$2(_[$][0],j))return $;return-1}var _assocIndexOf=assocIndexOf$4,assocIndexOf$3=_assocIndexOf,arrayProto=Array.prototype,splice=arrayProto.splice;function listCacheDelete$1(_){var j=this.__data__,$=assocIndexOf$3(j,_);if($<0)return!1;var _e=j.length-1;return $==_e?j.pop():splice.call(j,$,1),--this.size,!0}var _listCacheDelete=listCacheDelete$1,assocIndexOf$2=_assocIndexOf;function listCacheGet$1(_){var j=this.__data__,$=assocIndexOf$2(j,_);return $<0?void 0:j[$][1]}var _listCacheGet=listCacheGet$1,assocIndexOf$1=_assocIndexOf;function listCacheHas$1(_){return assocIndexOf$1(this.__data__,_)>-1}var _listCacheHas=listCacheHas$1,assocIndexOf=_assocIndexOf;function listCacheSet$1(_,j){var $=this.__data__,_e=assocIndexOf($,_);return _e<0?(++this.size,$.push([_,j])):$[_e][1]=j,this}var _listCacheSet=listCacheSet$1,listCacheClear=_listCacheClear,listCacheDelete=_listCacheDelete,listCacheGet=_listCacheGet,listCacheHas=_listCacheHas,listCacheSet=_listCacheSet;function ListCache$4(_){var j=-1,$=_==null?0:_.length;for(this.clear();++j<$;){var _e=_[j];this.set(_e[0],_e[1])}}ListCache$4.prototype.clear=listCacheClear;ListCache$4.prototype.delete=listCacheDelete;ListCache$4.prototype.get=listCacheGet;ListCache$4.prototype.has=listCacheHas;ListCache$4.prototype.set=listCacheSet;var _ListCache=ListCache$4,ListCache$3=_ListCache;function stackClear$1(){this.__data__=new ListCache$3,this.size=0}var _stackClear=stackClear$1;function stackDelete$1(_){var j=this.__data__,$=j.delete(_);return this.size=j.size,$}var _stackDelete=stackDelete$1;function stackGet$1(_){return this.__data__.get(_)}var _stackGet=stackGet$1;function stackHas$1(_){return this.__data__.has(_)}var _stackHas=stackHas$1,getNative$5=_getNative,root$6=_root,Map$4=getNative$5(root$6,"Map"),_Map=Map$4,getNative$4=_getNative,nativeCreate$4=getNative$4(Object,"create"),_nativeCreate=nativeCreate$4,nativeCreate$3=_nativeCreate;function hashClear$1(){this.__data__=nativeCreate$3?nativeCreate$3(null):{},this.size=0}var _hashClear=hashClear$1;function hashDelete$1(_){var j=this.has(_)&&delete this.__data__[_];return this.size-=j?1:0,j}var _hashDelete=hashDelete$1,nativeCreate$2=_nativeCreate,HASH_UNDEFINED$2="__lodash_hash_undefined__",objectProto$9=Object.prototype,hasOwnProperty$8=objectProto$9.hasOwnProperty;function hashGet$1(_){var j=this.__data__;if(nativeCreate$2){var $=j[_];return $===HASH_UNDEFINED$2?void 0:$}return hasOwnProperty$8.call(j,_)?j[_]:void 0}var _hashGet=hashGet$1,nativeCreate$1=_nativeCreate,objectProto$8=Object.prototype,hasOwnProperty$7=objectProto$8.hasOwnProperty;function hashHas$1(_){var j=this.__data__;return nativeCreate$1?j[_]!==void 0:hasOwnProperty$7.call(j,_)}var _hashHas=hashHas$1,nativeCreate=_nativeCreate,HASH_UNDEFINED$1="__lodash_hash_undefined__";function hashSet$1(_,j){var $=this.__data__;return this.size+=this.has(_)?0:1,$[_]=nativeCreate&&j===void 0?HASH_UNDEFINED$1:j,this}var _hashSet=hashSet$1,hashClear=_hashClear,hashDelete=_hashDelete,hashGet=_hashGet,hashHas=_hashHas,hashSet=_hashSet;function Hash$1(_){var j=-1,$=_==null?0:_.length;for(this.clear();++j<$;){var _e=_[j];this.set(_e[0],_e[1])}}Hash$1.prototype.clear=hashClear;Hash$1.prototype.delete=hashDelete;Hash$1.prototype.get=hashGet;Hash$1.prototype.has=hashHas;Hash$1.prototype.set=hashSet;var _Hash=Hash$1,Hash=_Hash,ListCache$2=_ListCache,Map$3=_Map;function mapCacheClear$1(){this.size=0,this.__data__={hash:new Hash,map:new(Map$3||ListCache$2),string:new Hash}}var _mapCacheClear=mapCacheClear$1;function isKeyable$1(_){var j=typeof _;return j=="string"||j=="number"||j=="symbol"||j=="boolean"?_!=="__proto__":_===null}var _isKeyable=isKeyable$1,isKeyable=_isKeyable;function getMapData$4(_,j){var $=_.__data__;return isKeyable(j)?$[typeof j=="string"?"string":"hash"]:$.map}var _getMapData=getMapData$4,getMapData$3=_getMapData;function mapCacheDelete$1(_){var j=getMapData$3(this,_).delete(_);return this.size-=j?1:0,j}var _mapCacheDelete=mapCacheDelete$1,getMapData$2=_getMapData;function mapCacheGet$1(_){return getMapData$2(this,_).get(_)}var _mapCacheGet=mapCacheGet$1,getMapData$1=_getMapData;function mapCacheHas$1(_){return getMapData$1(this,_).has(_)}var _mapCacheHas=mapCacheHas$1,getMapData=_getMapData;function mapCacheSet$1(_,j){var $=getMapData(this,_),_e=$.size;return $.set(_,j),this.size+=$.size==_e?0:1,this}var _mapCacheSet=mapCacheSet$1,mapCacheClear=_mapCacheClear,mapCacheDelete=_mapCacheDelete,mapCacheGet=_mapCacheGet,mapCacheHas=_mapCacheHas,mapCacheSet=_mapCacheSet;function MapCache$3(_){var j=-1,$=_==null?0:_.length;for(this.clear();++j<$;){var _e=_[j];this.set(_e[0],_e[1])}}MapCache$3.prototype.clear=mapCacheClear;MapCache$3.prototype.delete=mapCacheDelete;MapCache$3.prototype.get=mapCacheGet;MapCache$3.prototype.has=mapCacheHas;MapCache$3.prototype.set=mapCacheSet;var _MapCache=MapCache$3,ListCache$1=_ListCache,Map$2=_Map,MapCache$2=_MapCache,LARGE_ARRAY_SIZE=200;function stackSet$1(_,j){var $=this.__data__;if($ instanceof ListCache$1){var _e=$.__data__;if(!Map$2||_e.length<LARGE_ARRAY_SIZE-1)return _e.push([_,j]),this.size=++$.size,this;$=this.__data__=new MapCache$2(_e)}return $.set(_,j),this.size=$.size,this}var _stackSet=stackSet$1,ListCache=_ListCache,stackClear=_stackClear,stackDelete=_stackDelete,stackGet=_stackGet,stackHas=_stackHas,stackSet=_stackSet;function Stack$3(_){var j=this.__data__=new ListCache(_);this.size=j.size}Stack$3.prototype.clear=stackClear;Stack$3.prototype.delete=stackDelete;Stack$3.prototype.get=stackGet;Stack$3.prototype.has=stackHas;Stack$3.prototype.set=stackSet;var _Stack=Stack$3,HASH_UNDEFINED="__lodash_hash_undefined__";function setCacheAdd$1(_){return this.__data__.set(_,HASH_UNDEFINED),this}var _setCacheAdd=setCacheAdd$1;function setCacheHas$1(_){return this.__data__.has(_)}var _setCacheHas=setCacheHas$1,MapCache$1=_MapCache,setCacheAdd=_setCacheAdd,setCacheHas=_setCacheHas;function SetCache$1(_){var j=-1,$=_==null?0:_.length;for(this.__data__=new MapCache$1;++j<$;)this.add(_[j])}SetCache$1.prototype.add=SetCache$1.prototype.push=setCacheAdd;SetCache$1.prototype.has=setCacheHas;var _SetCache=SetCache$1;function arraySome$1(_,j){for(var $=-1,_e=_==null?0:_.length;++$<_e;)if(j(_[$],$,_))return!0;return!1}var _arraySome=arraySome$1;function cacheHas$1(_,j){return _.has(j)}var _cacheHas=cacheHas$1,SetCache=_SetCache,arraySome=_arraySome,cacheHas=_cacheHas,COMPARE_PARTIAL_FLAG$5=1,COMPARE_UNORDERED_FLAG$3=2;function equalArrays$2(_,j,$,_e,et,tt){var nt=$&COMPARE_PARTIAL_FLAG$5,rt=_.length,at=j.length;if(rt!=at&&!(nt&&at>rt))return!1;var it=tt.get(_),ot=tt.get(j);if(it&&ot)return it==j&&ot==_;var st=-1,ct=!0,pt=$&COMPARE_UNORDERED_FLAG$3?new SetCache:void 0;for(tt.set(_,j),tt.set(j,_);++st<rt;){var dt=_[st],ft=j[st];if(_e)var gt=nt?_e(ft,dt,st,j,_,tt):_e(dt,ft,st,_,j,tt);if(gt!==void 0){if(gt)continue;ct=!1;break}if(pt){if(!arraySome(j,function(ut,lt){if(!cacheHas(pt,lt)&&(dt===ut||et(dt,ut,$,_e,tt)))return pt.push(lt)})){ct=!1;break}}else if(!(dt===ft||et(dt,ft,$,_e,tt))){ct=!1;break}}return tt.delete(_),tt.delete(j),ct}var _equalArrays=equalArrays$2,root$5=_root,Uint8Array$3=root$5.Uint8Array,_Uint8Array=Uint8Array$3;function mapToArray$1(_){var j=-1,$=Array(_.size);return _.forEach(function(_e,et){$[++j]=[et,_e]}),$}var _mapToArray=mapToArray$1;function setToArray$1(_){var j=-1,$=Array(_.size);return _.forEach(function(_e){$[++j]=_e}),$}var _setToArray=setToArray$1,Symbol$4=_Symbol,Uint8Array$2=_Uint8Array,eq$1=eq_1,equalArrays$1=_equalArrays,mapToArray=_mapToArray,setToArray=_setToArray,COMPARE_PARTIAL_FLAG$4=1,COMPARE_UNORDERED_FLAG$2=2,boolTag$2="[object Boolean]",dateTag$2="[object Date]",errorTag$1="[object Error]",mapTag$5="[object Map]",numberTag$2="[object Number]",regexpTag$2="[object RegExp]",setTag$5="[object Set]",stringTag$2="[object String]",symbolTag$2="[object Symbol]",arrayBufferTag$2="[object ArrayBuffer]",dataViewTag$3="[object DataView]",symbolProto$2=Symbol$4?Symbol$4.prototype:void 0,symbolValueOf$1=symbolProto$2?symbolProto$2.valueOf:void 0;function equalByTag$1(_,j,$,_e,et,tt,nt){switch($){case dataViewTag$3:if(_.byteLength!=j.byteLength||_.byteOffset!=j.byteOffset)return!1;_=_.buffer,j=j.buffer;case arrayBufferTag$2:return!(_.byteLength!=j.byteLength||!tt(new Uint8Array$2(_),new Uint8Array$2(j)));case boolTag$2:case dateTag$2:case numberTag$2:return eq$1(+_,+j);case errorTag$1:return _.name==j.name&&_.message==j.message;case regexpTag$2:case stringTag$2:return _==j+"";case mapTag$5:var rt=mapToArray;case setTag$5:var at=_e&COMPARE_PARTIAL_FLAG$4;if(rt||(rt=setToArray),_.size!=j.size&&!at)return!1;var it=nt.get(_);if(it)return it==j;_e|=COMPARE_UNORDERED_FLAG$2,nt.set(_,j);var ot=equalArrays$1(rt(_),rt(j),_e,et,tt,nt);return nt.delete(_),ot;case symbolTag$2:if(symbolValueOf$1)return symbolValueOf$1.call(_)==symbolValueOf$1.call(j)}return!1}var _equalByTag=equalByTag$1;function arrayPush$3(_,j){for(var $=-1,_e=j.length,et=_.length;++$<_e;)_[et+$]=j[$];return _}var _arrayPush=arrayPush$3,arrayPush$2=_arrayPush,isArray$a=isArray_1;function baseGetAllKeys$2(_,j,$){var _e=j(_);return isArray$a(_)?_e:arrayPush$2(_e,$(_))}var _baseGetAllKeys=baseGetAllKeys$2;function arrayFilter$1(_,j){for(var $=-1,_e=_==null?0:_.length,et=0,tt=[];++$<_e;){var nt=_[$];j(nt,$,_)&&(tt[et++]=nt)}return tt}var _arrayFilter=arrayFilter$1;function stubArray$2(){return[]}var stubArray_1=stubArray$2,arrayFilter=_arrayFilter,stubArray$1=stubArray_1,objectProto$7=Object.prototype,propertyIsEnumerable=objectProto$7.propertyIsEnumerable,nativeGetSymbols$1=Object.getOwnPropertySymbols,getSymbols$3=nativeGetSymbols$1?function(_){return _==null?[]:(_=Object(_),arrayFilter(nativeGetSymbols$1(_),function(j){return propertyIsEnumerable.call(_,j)}))}:stubArray$1,_getSymbols=getSymbols$3,baseGetAllKeys$1=_baseGetAllKeys,getSymbols$2=_getSymbols,keys$4=keys_1;function getAllKeys$2(_){return baseGetAllKeys$1(_,keys$4,getSymbols$2)}var _getAllKeys=getAllKeys$2,getAllKeys$1=_getAllKeys,COMPARE_PARTIAL_FLAG$3=1,objectProto$6=Object.prototype,hasOwnProperty$6=objectProto$6.hasOwnProperty;function equalObjects$1(_,j,$,_e,et,tt){var nt=$&COMPARE_PARTIAL_FLAG$3,rt=getAllKeys$1(_),at=rt.length,it=getAllKeys$1(j),ot=it.length;if(at!=ot&&!nt)return!1;for(var st=at;st--;){var ct=rt[st];if(!(nt?ct in j:hasOwnProperty$6.call(j,ct)))return!1}var pt=tt.get(_),dt=tt.get(j);if(pt&&dt)return pt==j&&dt==_;var ft=!0;tt.set(_,j),tt.set(j,_);for(var gt=nt;++st<at;){ct=rt[st];var ut=_[ct],lt=j[ct];if(_e)var ht=nt?_e(lt,ut,ct,j,_,tt):_e(ut,lt,ct,_,j,tt);if(!(ht===void 0?ut===lt||et(ut,lt,$,_e,tt):ht)){ft=!1;break}gt||(gt=ct=="constructor")}if(ft&&!gt){var yt=_.constructor,vt=j.constructor;yt!=vt&&"constructor"in _&&"constructor"in j&&!(typeof yt=="function"&&yt instanceof yt&&typeof vt=="function"&&vt instanceof vt)&&(ft=!1)}return tt.delete(_),tt.delete(j),ft}var _equalObjects=equalObjects$1,getNative$3=_getNative,root$4=_root,DataView$1=getNative$3(root$4,"DataView"),_DataView=DataView$1,getNative$2=_getNative,root$3=_root,Promise$2=getNative$2(root$3,"Promise"),_Promise=Promise$2,getNative$1=_getNative,root$2=_root,Set$2=getNative$1(root$2,"Set"),_Set=Set$2,getNative=_getNative,root$1=_root,WeakMap$2=getNative(root$1,"WeakMap"),_WeakMap=WeakMap$2,DataView=_DataView,Map$1=_Map,Promise$1=_Promise,Set$1=_Set,WeakMap$1=_WeakMap,baseGetTag=_baseGetTag,toSource=_toSource,mapTag$4="[object Map]",objectTag$2="[object Object]",promiseTag="[object Promise]",setTag$4="[object Set]",weakMapTag$1="[object WeakMap]",dataViewTag$2="[object DataView]",dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map$1),promiseCtorString=toSource(Promise$1),setCtorString=toSource(Set$1),weakMapCtorString=toSource(WeakMap$1),getTag$5=baseGetTag;(DataView&&getTag$5(new DataView(new ArrayBuffer(1)))!=dataViewTag$2||Map$1&&getTag$5(new Map$1)!=mapTag$4||Promise$1&&getTag$5(Promise$1.resolve())!=promiseTag||Set$1&&getTag$5(new Set$1)!=setTag$4||WeakMap$1&&getTag$5(new WeakMap$1)!=weakMapTag$1)&&(getTag$5=function(_){var j=baseGetTag(_),$=j==objectTag$2?_.constructor:void 0,_e=$?toSource($):"";if(_e)switch(_e){case dataViewCtorString:return dataViewTag$2;case mapCtorString:return mapTag$4;case promiseCtorString:return promiseTag;case setCtorString:return setTag$4;case weakMapCtorString:return weakMapTag$1}return j});var _getTag=getTag$5,Stack$2=_Stack,equalArrays=_equalArrays,equalByTag=_equalByTag,equalObjects=_equalObjects,getTag$4=_getTag,isArray$9=isArray_1,isBuffer$2=isBufferExports,isTypedArray$1=isTypedArray_1,COMPARE_PARTIAL_FLAG$2=1,argsTag$1="[object Arguments]",arrayTag$1="[object Array]",objectTag$1="[object Object]",objectProto$5=Object.prototype,hasOwnProperty$5=objectProto$5.hasOwnProperty;function baseIsEqualDeep$1(_,j,$,_e,et,tt){var nt=isArray$9(_),rt=isArray$9(j),at=nt?arrayTag$1:getTag$4(_),it=rt?arrayTag$1:getTag$4(j);at=at==argsTag$1?objectTag$1:at,it=it==argsTag$1?objectTag$1:it;var ot=at==objectTag$1,st=it==objectTag$1,ct=at==it;if(ct&&isBuffer$2(_)){if(!isBuffer$2(j))return!1;nt=!0,ot=!1}if(ct&&!ot)return tt||(tt=new Stack$2),nt||isTypedArray$1(_)?equalArrays(_,j,$,_e,et,tt):equalByTag(_,j,at,$,_e,et,tt);if(!($&COMPARE_PARTIAL_FLAG$2)){var pt=ot&&hasOwnProperty$5.call(_,"__wrapped__"),dt=st&&hasOwnProperty$5.call(j,"__wrapped__");if(pt||dt){var ft=pt?_.value():_,gt=dt?j.value():j;return tt||(tt=new Stack$2),et(ft,gt,$,_e,tt)}}return ct?(tt||(tt=new Stack$2),equalObjects(_,j,$,_e,et,tt)):!1}var _baseIsEqualDeep=baseIsEqualDeep$1,baseIsEqualDeep=_baseIsEqualDeep,isObjectLike$2=isObjectLike_1;function baseIsEqual$3(_,j,$,_e,et){return _===j?!0:_==null||j==null||!isObjectLike$2(_)&&!isObjectLike$2(j)?_!==_&&j!==j:baseIsEqualDeep(_,j,$,_e,baseIsEqual$3,et)}var _baseIsEqual=baseIsEqual$3,Stack$1=_Stack,baseIsEqual$2=_baseIsEqual,COMPARE_PARTIAL_FLAG$1=1,COMPARE_UNORDERED_FLAG$1=2;function baseIsMatch$1(_,j,$,_e){var et=$.length,tt=et,nt=!_e;if(_==null)return!tt;for(_=Object(_);et--;){var rt=$[et];if(nt&&rt[2]?rt[1]!==_[rt[0]]:!(rt[0]in _))return!1}for(;++et<tt;){rt=$[et];var at=rt[0],it=_[at],ot=rt[1];if(nt&&rt[2]){if(it===void 0&&!(at in _))return!1}else{var st=new Stack$1;if(_e)var ct=_e(it,ot,at,_,j,st);if(!(ct===void 0?baseIsEqual$2(ot,it,COMPARE_PARTIAL_FLAG$1|COMPARE_UNORDERED_FLAG$1,_e,st):ct))return!1}}return!0}var _baseIsMatch=baseIsMatch$1,isObject$7=isObject_1;function isStrictComparable$2(_){return _===_&&!isObject$7(_)}var _isStrictComparable=isStrictComparable$2,isStrictComparable$1=_isStrictComparable,keys$3=keys_1;function getMatchData$1(_){for(var j=keys$3(_),$=j.length;$--;){var _e=j[$],et=_[_e];j[$]=[_e,et,isStrictComparable$1(et)]}return j}var _getMatchData=getMatchData$1;function matchesStrictComparable$2(_,j){return function($){return $==null?!1:$[_]===j&&(j!==void 0||_ in Object($))}}var _matchesStrictComparable=matchesStrictComparable$2,baseIsMatch=_baseIsMatch,getMatchData=_getMatchData,matchesStrictComparable$1=_matchesStrictComparable;function baseMatches$1(_){var j=getMatchData(_);return j.length==1&&j[0][2]?matchesStrictComparable$1(j[0][0],j[0][1]):function($){return $===_||baseIsMatch($,_,j)}}var _baseMatches=baseMatches$1,isArray$8=isArray_1,isSymbol$2=isSymbol_1,reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/;function isKey$3(_,j){if(isArray$8(_))return!1;var $=typeof _;return $=="number"||$=="symbol"||$=="boolean"||_==null||isSymbol$2(_)?!0:reIsPlainProp.test(_)||!reIsDeepProp.test(_)||j!=null&&_ in Object(j)}var _isKey=isKey$3,MapCache=_MapCache,FUNC_ERROR_TEXT$3="Expected a function";function memoize$2(_,j){if(typeof _!="function"||j!=null&&typeof j!="function")throw new TypeError(FUNC_ERROR_TEXT$3);var $=function(){var _e=arguments,et=j?j.apply(this,_e):_e[0],tt=$.cache;if(tt.has(et))return tt.get(et);var nt=_.apply(this,_e);return $.cache=tt.set(et,nt)||tt,nt};return $.cache=new(memoize$2.Cache||MapCache),$}memoize$2.Cache=MapCache;var memoize_1=memoize$2,memoize$1=memoize_1,MAX_MEMOIZE_SIZE=500;function memoizeCapped$1(_){var j=memoize$1(_,function(_e){return $.size===MAX_MEMOIZE_SIZE&&$.clear(),_e}),$=j.cache;return j}var _memoizeCapped=memoizeCapped$1,memoizeCapped=_memoizeCapped,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,reEscapeChar=/\\(\\)?/g,stringToPath$1=memoizeCapped(function(_){var j=[];return _.charCodeAt(0)===46&&j.push(""),_.replace(rePropName,function($,_e,et,tt){j.push(et?tt.replace(reEscapeChar,"$1"):_e||$)}),j}),_stringToPath=stringToPath$1;function arrayMap$3(_,j){for(var $=-1,_e=_==null?0:_.length,et=Array(_e);++$<_e;)et[$]=j(_[$],$,_);return et}var _arrayMap=arrayMap$3,Symbol$3=_Symbol,arrayMap$2=_arrayMap,isArray$7=isArray_1,isSymbol$1=isSymbol_1,INFINITY$1=1/0,symbolProto$1=Symbol$3?Symbol$3.prototype:void 0,symbolToString=symbolProto$1?symbolProto$1.toString:void 0;function baseToString$1(_){if(typeof _=="string")return _;if(isArray$7(_))return arrayMap$2(_,baseToString$1)+"";if(isSymbol$1(_))return symbolToString?symbolToString.call(_):"";var j=_+"";return j=="0"&&1/_==-INFINITY$1?"-0":j}var _baseToString=baseToString$1,baseToString=_baseToString;function toString$3(_){return _==null?"":baseToString(_)}var toString_1=toString$3,isArray$6=isArray_1,isKey$2=_isKey,stringToPath=_stringToPath,toString$2=toString_1;function castPath$4(_,j){return isArray$6(_)?_:isKey$2(_,j)?[_]:stringToPath(toString$2(_))}var _castPath=castPath$4,isSymbol=isSymbol_1,INFINITY=1/0;function toKey$5(_){if(typeof _=="string"||isSymbol(_))return _;var j=_+"";return j=="0"&&1/_==-INFINITY?"-0":j}var _toKey=toKey$5,castPath$3=_castPath,toKey$4=_toKey;function baseGet$3(_,j){j=castPath$3(j,_);for(var $=0,_e=j.length;_!=null&&$<_e;)_=_[toKey$4(j[$++])];return $&&$==_e?_:void 0}var _baseGet=baseGet$3,baseGet$2=_baseGet;function get$2(_,j,$){var _e=_==null?void 0:baseGet$2(_,j);return _e===void 0?$:_e}var get_1=get$2;function baseHasIn$1(_,j){return _!=null&&j in Object(_)}var _baseHasIn=baseHasIn$1,castPath$2=_castPath,isArguments$2=isArguments_1,isArray$5=isArray_1,isIndex$1=_isIndex,isLength=isLength_1,toKey$3=_toKey;function hasPath$1(_,j,$){j=castPath$2(j,_);for(var _e=-1,et=j.length,tt=!1;++_e<et;){var nt=toKey$3(j[_e]);if(!(tt=_!=null&&$(_,nt)))break;_=_[nt]}return tt||++_e!=et?tt:(et=_==null?0:_.length,!!et&&isLength(et)&&isIndex$1(nt,et)&&(isArray$5(_)||isArguments$2(_)))}var _hasPath=hasPath$1,baseHasIn=_baseHasIn,hasPath=_hasPath;function hasIn$1(_,j){return _!=null&&hasPath(_,j,baseHasIn)}var hasIn_1=hasIn$1,baseIsEqual$1=_baseIsEqual,get$1=get_1,hasIn=hasIn_1,isKey$1=_isKey,isStrictComparable=_isStrictComparable,matchesStrictComparable=_matchesStrictComparable,toKey$2=_toKey,COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;function baseMatchesProperty$1(_,j){return isKey$1(_)&&isStrictComparable(j)?matchesStrictComparable(toKey$2(_),j):function($){var _e=get$1($,_);return _e===void 0&&_e===j?hasIn($,_):baseIsEqual$1(j,_e,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG)}}var _baseMatchesProperty=baseMatchesProperty$1;function identity$4(_){return _}var identity_1=identity$4;function baseProperty$1(_){return function(j){return j==null?void 0:j[_]}}var _baseProperty=baseProperty$1,baseGet$1=_baseGet;function basePropertyDeep$1(_){return function(j){return baseGet$1(j,_)}}var _basePropertyDeep=basePropertyDeep$1,baseProperty=_baseProperty,basePropertyDeep=_basePropertyDeep,isKey=_isKey,toKey$1=_toKey;function property$1(_){return isKey(_)?baseProperty(toKey$1(_)):basePropertyDeep(_)}var property_1=property$1,baseMatches=_baseMatches,baseMatchesProperty=_baseMatchesProperty,identity$3=identity_1,isArray$4=isArray_1,property=property_1;function baseIteratee$2(_){return typeof _=="function"?_:_==null?identity$3:typeof _=="object"?isArray$4(_)?baseMatchesProperty(_[0],_[1]):baseMatches(_):property(_)}var _baseIteratee=baseIteratee$2,arrayAggregator=_arrayAggregator,baseAggregator=_baseAggregator,baseIteratee$1=_baseIteratee,isArray$3=isArray_1;function createAggregator$1(_,j){return function($,_e){var et=isArray$3($)?arrayAggregator:baseAggregator,tt=j?j():{};return et($,_,baseIteratee$1(_e),tt)}}var _createAggregator=createAggregator$1,baseAssignValue$2=_baseAssignValue,createAggregator=_createAggregator,objectProto$4=Object.prototype,hasOwnProperty$4=objectProto$4.hasOwnProperty,countBy=createAggregator(function(_,j,$){hasOwnProperty$4.call(_,$)?++_[$]:baseAssignValue$2(_,$,1)}),countBy_1=countBy,baseAssignValue$1=_baseAssignValue,eq=eq_1,objectProto$3=Object.prototype,hasOwnProperty$3=objectProto$3.hasOwnProperty;function assignValue$3(_,j,$){var _e=_[j];(!(hasOwnProperty$3.call(_,j)&&eq(_e,$))||$===void 0&&!(j in _))&&baseAssignValue$1(_,j,$)}var _assignValue=assignValue$3,assignValue$2=_assignValue,castPath$1=_castPath,isIndex=_isIndex,isObject$6=isObject_1,toKey=_toKey;function baseSet$2(_,j,$,_e){if(!isObject$6(_))return _;j=castPath$1(j,_);for(var et=-1,tt=j.length,nt=tt-1,rt=_;rt!=null&&++et<tt;){var at=toKey(j[et]),it=$;if(at==="__proto__"||at==="constructor"||at==="prototype")return _;if(et!=nt){var ot=rt[at];it=_e?_e(ot,at,rt):void 0,it===void 0&&(it=isObject$6(ot)?ot:isIndex(j[et+1])?[]:{})}assignValue$2(rt,at,it),rt=rt[at]}return _}var _baseSet=baseSet$2,baseGet=_baseGet,baseSet$1=_baseSet,castPath=_castPath;function basePickBy$1(_,j,$){for(var _e=-1,et=j.length,tt={};++_e<et;){var nt=j[_e],rt=baseGet(_,nt);$(rt,nt)&&baseSet$1(tt,castPath(nt,_),rt)}return tt}var _basePickBy=basePickBy$1,overArg=_overArg,getPrototype$2=overArg(Object.getPrototypeOf,Object),_getPrototype=getPrototype$2,arrayPush$1=_arrayPush,getPrototype$1=_getPrototype,getSymbols$1=_getSymbols,stubArray=stubArray_1,nativeGetSymbols=Object.getOwnPropertySymbols,getSymbolsIn$2=nativeGetSymbols?function(_){for(var j=[];_;)arrayPush$1(j,getSymbols$1(_)),_=getPrototype$1(_);return j}:stubArray,_getSymbolsIn=getSymbolsIn$2;function nativeKeysIn$1(_){var j=[];if(_!=null)for(var $ in Object(_))j.push($);return j}var _nativeKeysIn=nativeKeysIn$1,isObject$5=isObject_1,isPrototype$2=_isPrototype,nativeKeysIn=_nativeKeysIn,objectProto$2=Object.prototype,hasOwnProperty$2=objectProto$2.hasOwnProperty;function baseKeysIn$1(_){if(!isObject$5(_))return nativeKeysIn(_);var j=isPrototype$2(_),$=[];for(var _e in _)_e=="constructor"&&(j||!hasOwnProperty$2.call(_,_e))||$.push(_e);return $}var _baseKeysIn=baseKeysIn$1,arrayLikeKeys=_arrayLikeKeys,baseKeysIn=_baseKeysIn,isArrayLike$1=isArrayLike_1;function keysIn$3(_){return isArrayLike$1(_)?arrayLikeKeys(_,!0):baseKeysIn(_)}var keysIn_1=keysIn$3,baseGetAllKeys=_baseGetAllKeys,getSymbolsIn$1=_getSymbolsIn,keysIn$2=keysIn_1;function getAllKeysIn$2(_){return baseGetAllKeys(_,keysIn$2,getSymbolsIn$1)}var _getAllKeysIn=getAllKeysIn$2,arrayMap$1=_arrayMap,baseIteratee=_baseIteratee,basePickBy=_basePickBy,getAllKeysIn$1=_getAllKeysIn;function pickBy(_,j){if(_==null)return{};var $=arrayMap$1(getAllKeysIn$1(_),function(_e){return[_e]});return j=baseIteratee(j),basePickBy(_,$,function(_e,et){return j(_e,et[0])})}var pickBy_1=pickBy;function memoize(_){let j=null;return()=>(j==null&&(j=_()),j)}function without$1(_,j){return _.filter($=>$!==j)}function union(_,j){const $=new Set,_e=tt=>$.add(tt);_.forEach(_e),j.forEach(_e);const et=[];return $.forEach(tt=>et.push(tt)),et}class EnterLeaveCounter{enter(j){const $=this.entered.length,_e=et=>this.isNodeInDocument(et)&&(!et.contains||et.contains(j));return this.entered=union(this.entered.filter(_e),[j]),$===0&&this.entered.length>0}leave(j){const $=this.entered.length;return this.entered=without$1(this.entered.filter(this.isNodeInDocument),j),$>0&&this.entered.length===0}reset(){this.entered=[]}constructor(j){this.entered=[],this.isNodeInDocument=j}}class NativeDragSource{initializeExposedProperties(){Object.keys(this.config.exposeProperties).forEach(j=>{Object.defineProperty(this.item,j,{configurable:!0,enumerable:!0,get(){return console.warn(`Browser doesn't allow reading "${j}" until the drop event.`),null}})})}loadDataTransfer(j){if(j){const $={};Object.keys(this.config.exposeProperties).forEach(_e=>{const et=this.config.exposeProperties[_e];et!=null&&($[_e]={value:et(j,this.config.matchesTypes),configurable:!0,enumerable:!0})}),Object.defineProperties(this.item,$)}}canDrag(){return!0}beginDrag(){return this.item}isDragging(j,$){return $===j.getSourceId()}endDrag(){}constructor(j){this.config=j,this.item={},this.initializeExposedProperties()}}const FILE="__NATIVE_FILE__",URL$1="__NATIVE_URL__",TEXT="__NATIVE_TEXT__",HTML="__NATIVE_HTML__",NativeTypes=Object.freeze(Object.defineProperty({__proto__:null,FILE,HTML,TEXT,URL:URL$1},Symbol.toStringTag,{value:"Module"}));function getDataFromDataTransfer(_,j,$){const _e=j.reduce((et,tt)=>et||_.getData(tt),"");return _e??$}const nativeTypesConfig={[FILE]:{exposeProperties:{files:_=>Array.prototype.slice.call(_.files),items:_=>_.items,dataTransfer:_=>_},matchesTypes:["Files"]},[HTML]:{exposeProperties:{html:(_,j)=>getDataFromDataTransfer(_,j,""),dataTransfer:_=>_},matchesTypes:["Html","text/html"]},[URL$1]:{exposeProperties:{urls:(_,j)=>getDataFromDataTransfer(_,j,"").split(`
`),dataTransfer:_=>_},matchesTypes:["Url","text/uri-list"]},[TEXT]:{exposeProperties:{text:(_,j)=>getDataFromDataTransfer(_,j,""),dataTransfer:_=>_},matchesTypes:["Text","text/plain"]}};function createNativeDragSource(_,j){const $=nativeTypesConfig[_];if(!$)throw new Error(`native type ${_} has no configuration`);const _e=new NativeDragSource($);return _e.loadDataTransfer(j),_e}function matchNativeItemType(_){if(!_)return null;const j=Array.prototype.slice.call(_.types||[]);return Object.keys(nativeTypesConfig).filter($=>{const _e=nativeTypesConfig[$];return _e!=null&&_e.matchesTypes?_e.matchesTypes.some(et=>j.indexOf(et)>-1):!1})[0]||null}const isFirefox=memoize(()=>/firefox/i.test(navigator.userAgent)),isSafari=memoize(()=>!!window.safari);class MonotonicInterpolant{interpolate(j){const{xs:$,ys:_e,c1s:et,c2s:tt,c3s:nt}=this;let rt=$.length-1;if(j===$[rt])return _e[rt];let at=0,it=nt.length-1,ot;for(;at<=it;){ot=Math.floor(.5*(at+it));const pt=$[ot];if(pt<j)at=ot+1;else if(pt>j)it=ot-1;else return _e[ot]}rt=Math.max(0,it);const st=j-$[rt],ct=st*st;return _e[rt]+et[rt]*st+tt[rt]*ct+nt[rt]*st*ct}constructor(j,$){const{length:_e}=j,et=[];for(let pt=0;pt<_e;pt++)et.push(pt);et.sort((pt,dt)=>j[pt]<j[dt]?-1:1);const tt=[],nt=[];let rt,at;for(let pt=0;pt<_e-1;pt++)rt=j[pt+1]-j[pt],at=$[pt+1]-$[pt],tt.push(rt),nt.push(at/rt);const it=[nt[0]];for(let pt=0;pt<tt.length-1;pt++){const dt=nt[pt],ft=nt[pt+1];if(dt*ft<=0)it.push(0);else{rt=tt[pt];const gt=tt[pt+1],ut=rt+gt;it.push(3*ut/((ut+gt)/dt+(ut+rt)/ft))}}it.push(nt[nt.length-1]);const ot=[],st=[];let ct;for(let pt=0;pt<it.length-1;pt++){ct=nt[pt];const dt=it[pt],ft=1/tt[pt],gt=dt+it[pt+1]-ct-ct;ot.push((ct-dt-gt)*ft),st.push(gt*ft*ft)}this.xs=j,this.ys=$,this.c1s=it,this.c2s=ot,this.c3s=st}}const ELEMENT_NODE$1=1;function getNodeClientOffset$1(_){const j=_.nodeType===ELEMENT_NODE$1?_:_.parentElement;if(!j)return null;const{top:$,left:_e}=j.getBoundingClientRect();return{x:_e,y:$}}function getEventClientOffset$1(_){return{x:_.clientX,y:_.clientY}}function isImageNode(_){var j;return _.nodeName==="IMG"&&(isFirefox()||!(!((j=document.documentElement)===null||j===void 0)&&j.contains(_)))}function getDragPreviewSize(_,j,$,_e){let et=_?j.width:$,tt=_?j.height:_e;return isSafari()&&_&&(tt/=window.devicePixelRatio,et/=window.devicePixelRatio),{dragPreviewWidth:et,dragPreviewHeight:tt}}function getDragPreviewOffset(_,j,$,_e,et){const tt=isImageNode(j),rt=getNodeClientOffset$1(tt?_:j),at={x:$.x-rt.x,y:$.y-rt.y},{offsetWidth:it,offsetHeight:ot}=_,{anchorX:st,anchorY:ct}=_e,{dragPreviewWidth:pt,dragPreviewHeight:dt}=getDragPreviewSize(tt,j,it,ot),ft=()=>{let bt=new MonotonicInterpolant([0,.5,1],[at.y,at.y/ot*dt,at.y+dt-ot]).interpolate(ct);return isSafari()&&tt&&(bt+=(window.devicePixelRatio-1)*dt),bt},gt=()=>new MonotonicInterpolant([0,.5,1],[at.x,at.x/it*pt,at.x+pt-it]).interpolate(st),{offsetX:ut,offsetY:lt}=et,ht=ut===0||ut,yt=lt===0||lt;return{x:ht?ut:gt(),y:yt?lt:ft()}}let OptionsReader$1=class{get window(){if(this.globalContext)return this.globalContext;if(typeof window<"u")return window}get document(){var j;return!((j=this.globalContext)===null||j===void 0)&&j.document?this.globalContext.document:this.window?this.window.document:void 0}get rootElement(){var j;return((j=this.optionsArgs)===null||j===void 0?void 0:j.rootElement)||this.window}constructor(j,$){this.ownerDocument=null,this.globalContext=j,this.optionsArgs=$}};function _defineProperty$4(_,j,$){return j in _?Object.defineProperty(_,j,{value:$,enumerable:!0,configurable:!0,writable:!0}):_[j]=$,_}function _objectSpread$4(_){for(var j=1;j<arguments.length;j++){var $=arguments[j]!=null?arguments[j]:{},_e=Object.keys($);typeof Object.getOwnPropertySymbols=="function"&&(_e=_e.concat(Object.getOwnPropertySymbols($).filter(function(et){return Object.getOwnPropertyDescriptor($,et).enumerable}))),_e.forEach(function(et){_defineProperty$4(_,et,$[et])})}return _}class HTML5BackendImpl{profile(){var j,$;return{sourcePreviewNodes:this.sourcePreviewNodes.size,sourcePreviewNodeOptions:this.sourcePreviewNodeOptions.size,sourceNodeOptions:this.sourceNodeOptions.size,sourceNodes:this.sourceNodes.size,dragStartSourceIds:((j=this.dragStartSourceIds)===null||j===void 0?void 0:j.length)||0,dropTargetIds:this.dropTargetIds.length,dragEnterTargetIds:this.dragEnterTargetIds.length,dragOverTargetIds:(($=this.dragOverTargetIds)===null||$===void 0?void 0:$.length)||0}}get window(){return this.options.window}get document(){return this.options.document}get rootElement(){return this.options.rootElement}setup(){const j=this.rootElement;if(j!==void 0){if(j.__isReactDndBackendSetUp)throw new Error("Cannot have two HTML5 backends at the same time.");j.__isReactDndBackendSetUp=!0,this.addEventListeners(j)}}teardown(){const j=this.rootElement;if(j!==void 0&&(j.__isReactDndBackendSetUp=!1,this.removeEventListeners(this.rootElement),this.clearCurrentDragSourceNode(),this.asyncEndDragFrameId)){var $;($=this.window)===null||$===void 0||$.cancelAnimationFrame(this.asyncEndDragFrameId)}}connectDragPreview(j,$,_e){return this.sourcePreviewNodeOptions.set(j,_e),this.sourcePreviewNodes.set(j,$),()=>{this.sourcePreviewNodes.delete(j),this.sourcePreviewNodeOptions.delete(j)}}connectDragSource(j,$,_e){this.sourceNodes.set(j,$),this.sourceNodeOptions.set(j,_e);const et=nt=>this.handleDragStart(nt,j),tt=nt=>this.handleSelectStart(nt);return $.setAttribute("draggable","true"),$.addEventListener("dragstart",et),$.addEventListener("selectstart",tt),()=>{this.sourceNodes.delete(j),this.sourceNodeOptions.delete(j),$.removeEventListener("dragstart",et),$.removeEventListener("selectstart",tt),$.setAttribute("draggable","false")}}connectDropTarget(j,$){const _e=nt=>this.handleDragEnter(nt,j),et=nt=>this.handleDragOver(nt,j),tt=nt=>this.handleDrop(nt,j);return $.addEventListener("dragenter",_e),$.addEventListener("dragover",et),$.addEventListener("drop",tt),()=>{$.removeEventListener("dragenter",_e),$.removeEventListener("dragover",et),$.removeEventListener("drop",tt)}}addEventListeners(j){j.addEventListener&&(j.addEventListener("dragstart",this.handleTopDragStart),j.addEventListener("dragstart",this.handleTopDragStartCapture,!0),j.addEventListener("dragend",this.handleTopDragEndCapture,!0),j.addEventListener("dragenter",this.handleTopDragEnter),j.addEventListener("dragenter",this.handleTopDragEnterCapture,!0),j.addEventListener("dragleave",this.handleTopDragLeaveCapture,!0),j.addEventListener("dragover",this.handleTopDragOver),j.addEventListener("dragover",this.handleTopDragOverCapture,!0),j.addEventListener("drop",this.handleTopDrop),j.addEventListener("drop",this.handleTopDropCapture,!0))}removeEventListeners(j){j.removeEventListener&&(j.removeEventListener("dragstart",this.handleTopDragStart),j.removeEventListener("dragstart",this.handleTopDragStartCapture,!0),j.removeEventListener("dragend",this.handleTopDragEndCapture,!0),j.removeEventListener("dragenter",this.handleTopDragEnter),j.removeEventListener("dragenter",this.handleTopDragEnterCapture,!0),j.removeEventListener("dragleave",this.handleTopDragLeaveCapture,!0),j.removeEventListener("dragover",this.handleTopDragOver),j.removeEventListener("dragover",this.handleTopDragOverCapture,!0),j.removeEventListener("drop",this.handleTopDrop),j.removeEventListener("drop",this.handleTopDropCapture,!0))}getCurrentSourceNodeOptions(){const j=this.monitor.getSourceId(),$=this.sourceNodeOptions.get(j);return _objectSpread$4({dropEffect:this.altKeyPressed?"copy":"move"},$||{})}getCurrentDropEffect(){return this.isDraggingNativeItem()?"copy":this.getCurrentSourceNodeOptions().dropEffect}getCurrentSourcePreviewNodeOptions(){const j=this.monitor.getSourceId(),$=this.sourcePreviewNodeOptions.get(j);return _objectSpread$4({anchorX:.5,anchorY:.5,captureDraggingState:!1},$||{})}isDraggingNativeItem(){const j=this.monitor.getItemType();return Object.keys(NativeTypes).some($=>NativeTypes[$]===j)}beginDragNativeItem(j,$){this.clearCurrentDragSourceNode(),this.currentNativeSource=createNativeDragSource(j,$),this.currentNativeHandle=this.registry.addSource(j,this.currentNativeSource),this.actions.beginDrag([this.currentNativeHandle])}setCurrentDragSourceNode(j){this.clearCurrentDragSourceNode(),this.currentDragSourceNode=j;const $=1e3;this.mouseMoveTimeoutTimer=setTimeout(()=>{var _e;return(_e=this.rootElement)===null||_e===void 0?void 0:_e.addEventListener("mousemove",this.endDragIfSourceWasRemovedFromDOM,!0)},$)}clearCurrentDragSourceNode(){if(this.currentDragSourceNode){if(this.currentDragSourceNode=null,this.rootElement){var j;(j=this.window)===null||j===void 0||j.clearTimeout(this.mouseMoveTimeoutTimer||void 0),this.rootElement.removeEventListener("mousemove",this.endDragIfSourceWasRemovedFromDOM,!0)}return this.mouseMoveTimeoutTimer=null,!0}return!1}handleDragStart(j,$){j.defaultPrevented||(this.dragStartSourceIds||(this.dragStartSourceIds=[]),this.dragStartSourceIds.unshift($))}handleDragEnter(j,$){this.dragEnterTargetIds.unshift($)}handleDragOver(j,$){this.dragOverTargetIds===null&&(this.dragOverTargetIds=[]),this.dragOverTargetIds.unshift($)}handleDrop(j,$){this.dropTargetIds.unshift($)}constructor(j,$,_e){this.sourcePreviewNodes=new Map,this.sourcePreviewNodeOptions=new Map,this.sourceNodes=new Map,this.sourceNodeOptions=new Map,this.dragStartSourceIds=null,this.dropTargetIds=[],this.dragEnterTargetIds=[],this.currentNativeSource=null,this.currentNativeHandle=null,this.currentDragSourceNode=null,this.altKeyPressed=!1,this.mouseMoveTimeoutTimer=null,this.asyncEndDragFrameId=null,this.dragOverTargetIds=null,this.lastClientOffset=null,this.hoverRafId=null,this.getSourceClientOffset=et=>{const tt=this.sourceNodes.get(et);return tt&&getNodeClientOffset$1(tt)||null},this.endDragNativeItem=()=>{this.isDraggingNativeItem()&&(this.actions.endDrag(),this.currentNativeHandle&&this.registry.removeSource(this.currentNativeHandle),this.currentNativeHandle=null,this.currentNativeSource=null)},this.isNodeInDocument=et=>!!(et&&this.document&&this.document.body&&this.document.body.contains(et)),this.endDragIfSourceWasRemovedFromDOM=()=>{const et=this.currentDragSourceNode;et==null||this.isNodeInDocument(et)||(this.clearCurrentDragSourceNode()&&this.monitor.isDragging()&&this.actions.endDrag(),this.cancelHover())},this.scheduleHover=et=>{this.hoverRafId===null&&typeof requestAnimationFrame<"u"&&(this.hoverRafId=requestAnimationFrame(()=>{this.monitor.isDragging()&&this.actions.hover(et||[],{clientOffset:this.lastClientOffset}),this.hoverRafId=null}))},this.cancelHover=()=>{this.hoverRafId!==null&&typeof cancelAnimationFrame<"u"&&(cancelAnimationFrame(this.hoverRafId),this.hoverRafId=null)},this.handleTopDragStartCapture=()=>{this.clearCurrentDragSourceNode(),this.dragStartSourceIds=[]},this.handleTopDragStart=et=>{if(et.defaultPrevented)return;const{dragStartSourceIds:tt}=this;this.dragStartSourceIds=null;const nt=getEventClientOffset$1(et);this.monitor.isDragging()&&(this.actions.endDrag(),this.cancelHover()),this.actions.beginDrag(tt||[],{publishSource:!1,getSourceClientOffset:this.getSourceClientOffset,clientOffset:nt});const{dataTransfer:rt}=et,at=matchNativeItemType(rt);if(this.monitor.isDragging()){if(rt&&typeof rt.setDragImage=="function"){const ot=this.monitor.getSourceId(),st=this.sourceNodes.get(ot),ct=this.sourcePreviewNodes.get(ot)||st;if(ct){const{anchorX:pt,anchorY:dt,offsetX:ft,offsetY:gt}=this.getCurrentSourcePreviewNodeOptions(),ht=getDragPreviewOffset(st,ct,nt,{anchorX:pt,anchorY:dt},{offsetX:ft,offsetY:gt});rt.setDragImage(ct,ht.x,ht.y)}}try{rt==null||rt.setData("application/json",{})}catch{}this.setCurrentDragSourceNode(et.target);const{captureDraggingState:it}=this.getCurrentSourcePreviewNodeOptions();it?this.actions.publishDragSource():setTimeout(()=>this.actions.publishDragSource(),0)}else if(at)this.beginDragNativeItem(at);else{if(rt&&!rt.types&&(et.target&&!et.target.hasAttribute||!et.target.hasAttribute("draggable")))return;et.preventDefault()}},this.handleTopDragEndCapture=()=>{this.clearCurrentDragSourceNode()&&this.monitor.isDragging()&&this.actions.endDrag(),this.cancelHover()},this.handleTopDragEnterCapture=et=>{if(this.dragEnterTargetIds=[],this.isDraggingNativeItem()){var tt;(tt=this.currentNativeSource)===null||tt===void 0||tt.loadDataTransfer(et.dataTransfer)}if(!this.enterLeaveCounter.enter(et.target)||this.monitor.isDragging())return;const{dataTransfer:rt}=et,at=matchNativeItemType(rt);at&&this.beginDragNativeItem(at,rt)},this.handleTopDragEnter=et=>{const{dragEnterTargetIds:tt}=this;if(this.dragEnterTargetIds=[],!this.monitor.isDragging())return;this.altKeyPressed=et.altKey,tt.length>0&&this.actions.hover(tt,{clientOffset:getEventClientOffset$1(et)}),tt.some(rt=>this.monitor.canDropOnTarget(rt))&&(et.preventDefault(),et.dataTransfer&&(et.dataTransfer.dropEffect=this.getCurrentDropEffect()))},this.handleTopDragOverCapture=et=>{if(this.dragOverTargetIds=[],this.isDraggingNativeItem()){var tt;(tt=this.currentNativeSource)===null||tt===void 0||tt.loadDataTransfer(et.dataTransfer)}},this.handleTopDragOver=et=>{const{dragOverTargetIds:tt}=this;if(this.dragOverTargetIds=[],!this.monitor.isDragging()){et.preventDefault(),et.dataTransfer&&(et.dataTransfer.dropEffect="none");return}this.altKeyPressed=et.altKey,this.lastClientOffset=getEventClientOffset$1(et),this.scheduleHover(tt),(tt||[]).some(rt=>this.monitor.canDropOnTarget(rt))?(et.preventDefault(),et.dataTransfer&&(et.dataTransfer.dropEffect=this.getCurrentDropEffect())):this.isDraggingNativeItem()?et.preventDefault():(et.preventDefault(),et.dataTransfer&&(et.dataTransfer.dropEffect="none"))},this.handleTopDragLeaveCapture=et=>{this.isDraggingNativeItem()&&et.preventDefault(),this.enterLeaveCounter.leave(et.target)&&(this.isDraggingNativeItem()&&setTimeout(()=>this.endDragNativeItem(),0),this.cancelHover())},this.handleTopDropCapture=et=>{if(this.dropTargetIds=[],this.isDraggingNativeItem()){var tt;et.preventDefault(),(tt=this.currentNativeSource)===null||tt===void 0||tt.loadDataTransfer(et.dataTransfer)}else matchNativeItemType(et.dataTransfer)&&et.preventDefault();this.enterLeaveCounter.reset()},this.handleTopDrop=et=>{const{dropTargetIds:tt}=this;this.dropTargetIds=[],this.actions.hover(tt,{clientOffset:getEventClientOffset$1(et)}),this.actions.drop({dropEffect:this.getCurrentDropEffect()}),this.isDraggingNativeItem()?this.endDragNativeItem():this.monitor.isDragging()&&this.actions.endDrag(),this.cancelHover()},this.handleSelectStart=et=>{const tt=et.target;typeof tt.dragDrop=="function"&&(tt.tagName==="INPUT"||tt.tagName==="SELECT"||tt.tagName==="TEXTAREA"||tt.isContentEditable||(et.preventDefault(),tt.dragDrop()))},this.options=new OptionsReader$1($,_e),this.actions=j.getActions(),this.monitor=j.getMonitor(),this.registry=j.getRegistry(),this.enterLeaveCounter=new EnterLeaveCounter(this.isNodeInDocument)}}const HTML5Backend=function _(j,$,_e){return new HTML5BackendImpl(j,$,_e)};function invariant(_,j,...$){if(isProduction()&&j===void 0)throw new Error("invariant requires an error message argument");if(!_){let _e;if(j===void 0)_e=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{let et=0;_e=new Error(j.replace(/%s/g,function(){return $[et++]})),_e.name="Invariant Violation"}throw _e.framesToPop=1,_e}}function isProduction(){return typeof process<"u"&&!0}var ListenerType;(function(_){_.mouse="mouse",_.touch="touch",_.keyboard="keyboard"})(ListenerType||(ListenerType={}));class OptionsReader{get delay(){var j;return(j=this.args.delay)!==null&&j!==void 0?j:0}get scrollAngleRanges(){return this.args.scrollAngleRanges}get getDropTargetElementsAtPoint(){return this.args.getDropTargetElementsAtPoint}get ignoreContextMenu(){var j;return(j=this.args.ignoreContextMenu)!==null&&j!==void 0?j:!1}get enableHoverOutsideTarget(){var j;return(j=this.args.enableHoverOutsideTarget)!==null&&j!==void 0?j:!1}get enableKeyboardEvents(){var j;return(j=this.args.enableKeyboardEvents)!==null&&j!==void 0?j:!1}get enableMouseEvents(){var j;return(j=this.args.enableMouseEvents)!==null&&j!==void 0?j:!1}get enableTouchEvents(){var j;return(j=this.args.enableTouchEvents)!==null&&j!==void 0?j:!0}get touchSlop(){return this.args.touchSlop||0}get delayTouchStart(){var j,$,_e,et;return(et=(_e=(j=this.args)===null||j===void 0?void 0:j.delayTouchStart)!==null&&_e!==void 0?_e:($=this.args)===null||$===void 0?void 0:$.delay)!==null&&et!==void 0?et:0}get delayMouseStart(){var j,$,_e,et;return(et=(_e=(j=this.args)===null||j===void 0?void 0:j.delayMouseStart)!==null&&_e!==void 0?_e:($=this.args)===null||$===void 0?void 0:$.delay)!==null&&et!==void 0?et:0}get window(){if(this.context&&this.context.window)return this.context.window;if(typeof window<"u")return window}get document(){var j;if(!((j=this.context)===null||j===void 0)&&j.document)return this.context.document;if(this.window)return this.window.document}get rootElement(){var j;return((j=this.args)===null||j===void 0?void 0:j.rootElement)||this.document}constructor(j,$){this.args=j,this.context=$}}function distance(_,j,$,_e){return Math.sqrt(Math.pow(Math.abs($-_),2)+Math.pow(Math.abs(_e-j),2))}function inAngleRanges(_,j,$,_e,et){if(!et)return!1;const tt=Math.atan2(_e-j,$-_)*180/Math.PI+180;for(let nt=0;nt<et.length;++nt){const rt=et[nt];if(rt&&(rt.start==null||tt>=rt.start)&&(rt.end==null||tt<=rt.end))return!0}return!1}const MouseButtons={Left:1,Right:2,Center:4},MouseButton={Left:0,Center:1,Right:2};function eventShouldStartDrag(_){return _.button===void 0||_.button===MouseButton.Left}function eventShouldEndDrag(_){return _.buttons===void 0||(_.buttons&MouseButtons.Left)===0}function isTouchEvent$1(_){return!!_.targetTouches}const ELEMENT_NODE=1;function getNodeClientOffset(_){const j=_.nodeType===ELEMENT_NODE?_:_.parentElement;if(!j)return;const{top:$,left:_e}=j.getBoundingClientRect();return{x:_e,y:$}}function getEventClientTouchOffset(_,j){if(_.targetTouches.length===1)return getEventClientOffset(_.targetTouches[0]);if(j&&_.touches.length===1&&_.touches[0].target===j.target)return getEventClientOffset(_.touches[0])}function getEventClientOffset(_,j){return isTouchEvent$1(_)?getEventClientTouchOffset(_,j):{x:_.clientX,y:_.clientY}}const eventNames={[ListenerType.mouse]:{start:"mousedown",move:"mousemove",end:"mouseup",contextmenu:"contextmenu"},[ListenerType.touch]:{start:"touchstart",move:"touchmove",end:"touchend"},[ListenerType.keyboard]:{keydown:"keydown"}};class TouchBackendImpl{profile(){var j;return{sourceNodes:this.sourceNodes.size,sourcePreviewNodes:this.sourcePreviewNodes.size,sourcePreviewNodeOptions:this.sourcePreviewNodeOptions.size,targetNodes:this.targetNodes.size,dragOverTargetIds:((j=this.dragOverTargetIds)===null||j===void 0?void 0:j.length)||0}}get document(){return this.options.document}setup(){const j=this.options.rootElement;j&&(invariant(!TouchBackendImpl.isSetUp,"Cannot have two Touch backends at the same time."),TouchBackendImpl.isSetUp=!0,this.addEventListener(j,"start",this.getTopMoveStartHandler()),this.addEventListener(j,"start",this.handleTopMoveStartCapture,!0),this.addEventListener(j,"move",this.handleTopMove),this.addEventListener(j,"move",this.handleTopMoveCapture,!0),this.addEventListener(j,"end",this.handleTopMoveEndCapture,!0),this.options.enableMouseEvents&&!this.options.ignoreContextMenu&&this.addEventListener(j,"contextmenu",this.handleTopMoveEndCapture),this.options.enableKeyboardEvents&&this.addEventListener(j,"keydown",this.handleCancelOnEscape,!0))}teardown(){const j=this.options.rootElement;j&&(TouchBackendImpl.isSetUp=!1,this._mouseClientOffset={},this.removeEventListener(j,"start",this.handleTopMoveStartCapture,!0),this.removeEventListener(j,"start",this.handleTopMoveStart),this.removeEventListener(j,"move",this.handleTopMoveCapture,!0),this.removeEventListener(j,"move",this.handleTopMove),this.removeEventListener(j,"end",this.handleTopMoveEndCapture,!0),this.options.enableMouseEvents&&!this.options.ignoreContextMenu&&this.removeEventListener(j,"contextmenu",this.handleTopMoveEndCapture),this.options.enableKeyboardEvents&&this.removeEventListener(j,"keydown",this.handleCancelOnEscape,!0),this.uninstallSourceNodeRemovalObserver())}addEventListener(j,$,_e,et=!1){const tt=et;this.listenerTypes.forEach(function(nt){const rt=eventNames[nt][$];rt&&j.addEventListener(rt,_e,tt)})}removeEventListener(j,$,_e,et=!1){const tt=et;this.listenerTypes.forEach(function(nt){const rt=eventNames[nt][$];rt&&j.removeEventListener(rt,_e,tt)})}connectDragSource(j,$){const _e=this.handleMoveStart.bind(this,j);return this.sourceNodes.set(j,$),this.addEventListener($,"start",_e),()=>{this.sourceNodes.delete(j),this.removeEventListener($,"start",_e)}}connectDragPreview(j,$,_e){return this.sourcePreviewNodeOptions.set(j,_e),this.sourcePreviewNodes.set(j,$),()=>{this.sourcePreviewNodes.delete(j),this.sourcePreviewNodeOptions.delete(j)}}connectDropTarget(j,$){const _e=this.options.rootElement;if(!this.document||!_e)return()=>{};const et=tt=>{if(!this.document||!_e||!this.monitor.isDragging())return;let nt;switch(tt.type){case eventNames.mouse.move:nt={x:tt.clientX,y:tt.clientY};break;case eventNames.touch.move:var rt,at;nt={x:((rt=tt.touches[0])===null||rt===void 0?void 0:rt.clientX)||0,y:((at=tt.touches[0])===null||at===void 0?void 0:at.clientY)||0};break}const it=nt!=null?this.document.elementFromPoint(nt.x,nt.y):void 0,ot=it&&$.contains(it);if(it===$||ot)return this.handleMove(tt,j)};return this.addEventListener(this.document.body,"move",et),this.targetNodes.set(j,$),()=>{this.document&&(this.targetNodes.delete(j),this.removeEventListener(this.document.body,"move",et))}}getTopMoveStartHandler(){return!this.options.delayTouchStart&&!this.options.delayMouseStart?this.handleTopMoveStart:this.handleTopMoveStartDelay}installSourceNodeRemovalObserver(j){this.uninstallSourceNodeRemovalObserver(),this.draggedSourceNode=j,this.draggedSourceNodeRemovalObserver=new MutationObserver(()=>{j&&!j.parentElement&&(this.resurrectSourceNode(),this.uninstallSourceNodeRemovalObserver())}),!(!j||!j.parentElement)&&this.draggedSourceNodeRemovalObserver.observe(j.parentElement,{childList:!0})}resurrectSourceNode(){this.document&&this.draggedSourceNode&&(this.draggedSourceNode.style.display="none",this.draggedSourceNode.removeAttribute("data-reactid"),this.document.body.appendChild(this.draggedSourceNode))}uninstallSourceNodeRemovalObserver(){this.draggedSourceNodeRemovalObserver&&this.draggedSourceNodeRemovalObserver.disconnect(),this.draggedSourceNodeRemovalObserver=void 0,this.draggedSourceNode=void 0}constructor(j,$,_e){this.getSourceClientOffset=et=>{const tt=this.sourceNodes.get(et);return tt&&getNodeClientOffset(tt)},this.handleTopMoveStartCapture=et=>{eventShouldStartDrag(et)&&(this.moveStartSourceIds=[])},this.handleMoveStart=et=>{Array.isArray(this.moveStartSourceIds)&&this.moveStartSourceIds.unshift(et)},this.handleTopMoveStart=et=>{if(!eventShouldStartDrag(et))return;const tt=getEventClientOffset(et);tt&&(isTouchEvent$1(et)&&(this.lastTargetTouchFallback=et.targetTouches[0]),this._mouseClientOffset=tt),this.waitingForDelay=!1},this.handleTopMoveStartDelay=et=>{if(!eventShouldStartDrag(et))return;const tt=et.type===eventNames.touch.start?this.options.delayTouchStart:this.options.delayMouseStart;this.timeout=setTimeout(this.handleTopMoveStart.bind(this,et),tt),this.waitingForDelay=!0},this.handleTopMoveCapture=()=>{this.dragOverTargetIds=[]},this.handleMove=(et,tt)=>{this.dragOverTargetIds&&this.dragOverTargetIds.unshift(tt)},this.handleTopMove=et=>{if(this.timeout&&clearTimeout(this.timeout),!this.document||this.waitingForDelay)return;const{moveStartSourceIds:tt,dragOverTargetIds:nt}=this,rt=this.options.enableHoverOutsideTarget,at=getEventClientOffset(et,this.lastTargetTouchFallback);if(!at)return;if(this._isScrolling||!this.monitor.isDragging()&&inAngleRanges(this._mouseClientOffset.x||0,this._mouseClientOffset.y||0,at.x,at.y,this.options.scrollAngleRanges)){this._isScrolling=!0;return}if(!this.monitor.isDragging()&&this._mouseClientOffset.hasOwnProperty("x")&&tt&&distance(this._mouseClientOffset.x||0,this._mouseClientOffset.y||0,at.x,at.y)>(this.options.touchSlop?this.options.touchSlop:0)&&(this.moveStartSourceIds=void 0,this.actions.beginDrag(tt,{clientOffset:this._mouseClientOffset,getSourceClientOffset:this.getSourceClientOffset,publishSource:!1})),!this.monitor.isDragging())return;const it=this.sourceNodes.get(this.monitor.getSourceId());this.installSourceNodeRemovalObserver(it),this.actions.publishDragSource(),et.cancelable&&et.preventDefault();const ot=(nt||[]).map(dt=>this.targetNodes.get(dt)).filter(dt=>!!dt),st=this.options.getDropTargetElementsAtPoint?this.options.getDropTargetElementsAtPoint(at.x,at.y,ot):this.document.elementsFromPoint(at.x,at.y),ct=[];for(const dt in st){if(!st.hasOwnProperty(dt))continue;let ft=st[dt];for(ft!=null&&ct.push(ft);ft;)ft=ft.parentElement,ft&&ct.indexOf(ft)===-1&&ct.push(ft)}const pt=ct.filter(dt=>ot.indexOf(dt)>-1).map(dt=>this._getDropTargetId(dt)).filter(dt=>!!dt).filter((dt,ft,gt)=>gt.indexOf(dt)===ft);if(rt)for(const dt in this.targetNodes){const ft=this.targetNodes.get(dt);if(it&&ft&&ft.contains(it)&&pt.indexOf(dt)===-1){pt.unshift(dt);break}}pt.reverse(),this.actions.hover(pt,{clientOffset:at})},this._getDropTargetId=et=>{const tt=this.targetNodes.keys();let nt=tt.next();for(;nt.done===!1;){const rt=nt.value;if(et===this.targetNodes.get(rt))return rt;nt=tt.next()}},this.handleTopMoveEndCapture=et=>{if(this._isScrolling=!1,this.lastTargetTouchFallback=void 0,!!eventShouldEndDrag(et)){if(!this.monitor.isDragging()||this.monitor.didDrop()){this.moveStartSourceIds=void 0;return}et.cancelable&&et.preventDefault(),this._mouseClientOffset={},this.uninstallSourceNodeRemovalObserver(),this.actions.drop(),this.actions.endDrag()}},this.handleCancelOnEscape=et=>{et.key==="Escape"&&this.monitor.isDragging()&&(this._mouseClientOffset={},this.uninstallSourceNodeRemovalObserver(),this.actions.endDrag())},this.options=new OptionsReader(_e,$),this.actions=j.getActions(),this.monitor=j.getMonitor(),this.sourceNodes=new Map,this.sourcePreviewNodes=new Map,this.sourcePreviewNodeOptions=new Map,this.targetNodes=new Map,this.listenerTypes=[],this._mouseClientOffset={},this._isScrolling=!1,this.options.enableMouseEvents&&this.listenerTypes.push(ListenerType.mouse),this.options.enableTouchEvents&&this.listenerTypes.push(ListenerType.touch),this.options.enableKeyboardEvents&&this.listenerTypes.push(ListenerType.keyboard)}}const TouchBackend=function _(j,$={},_e={}){return new TouchBackendImpl(j,$,_e)};var D=(_,j,$)=>{if(!j.has(_))throw TypeError("Cannot "+$)},t$2=(_,j,$)=>(D(_,j,"read from private field"),$?$.call(_):j.get(_)),o=(_,j,$)=>{if(j.has(_))throw TypeError("Cannot add the same private member more than once");j instanceof WeakSet?j.add(_):j.set(_,$)},p$4=(_,j,$,_e)=>(D(_,j,"write to private field"),j.set(_,$),$),w$1,b=class{constructor(){o(this,w$1,void 0),this.register=_=>{t$2(this,w$1).push(_)},this.unregister=_=>{let j;for(;(j=t$2(this,w$1).indexOf(_))!==-1;)t$2(this,w$1).splice(j,1)},this.backendChanged=_=>{for(let j of t$2(this,w$1))j.backendChanged(_)},p$4(this,w$1,[])}};w$1=new WeakMap;var a$2,f$1,c,d,h$2,x$1,T,E$1,v$1,y,g$1,l$2=class Qt{constructor(j,$,_e){if(o(this,a$2,void 0),o(this,f$1,void 0),o(this,c,void 0),o(this,d,void 0),o(this,h$2,void 0),o(this,x$1,(et,tt,nt)=>{if(!nt.backend)throw new Error(`You must specify a 'backend' property in your Backend entry: ${JSON.stringify(nt)}`);let rt=nt.backend(et,tt,nt.options),at=nt.id,it=!nt.id&&rt&&rt.constructor;if(it&&(at=rt.constructor.name),at)it&&console.warn(`Deprecation notice: You are using a pipeline which doesn't include backends' 'id'.
        This might be unsupported in the future, please specify 'id' explicitely for every backend.`);else throw new Error(`You must specify an 'id' property in your Backend entry: ${JSON.stringify(nt)}
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-5xx`);if(t$2(this,c)[at])throw new Error(`You must specify a unique 'id' property in your Backend entry:
        ${JSON.stringify(nt)} (conflicts with: ${JSON.stringify(t$2(this,c)[at])})`);return{id:at,instance:rt,preview:nt.preview??!1,transition:nt.transition,skipDispatchOnTransition:nt.skipDispatchOnTransition??!1}}),this.setup=()=>{if(!(typeof window>"u")){if(Qt.isSetUp)throw new Error("Cannot have two MultiBackends at the same time.");Qt.isSetUp=!0,t$2(this,T).call(this,window),t$2(this,c)[t$2(this,a$2)].instance.setup()}},this.teardown=()=>{typeof window>"u"||(Qt.isSetUp=!1,t$2(this,E$1).call(this,window),t$2(this,c)[t$2(this,a$2)].instance.teardown())},this.connectDragSource=(et,tt,nt)=>t$2(this,g$1).call(this,"connectDragSource",et,tt,nt),this.connectDragPreview=(et,tt,nt)=>t$2(this,g$1).call(this,"connectDragPreview",et,tt,nt),this.connectDropTarget=(et,tt,nt)=>t$2(this,g$1).call(this,"connectDropTarget",et,tt,nt),this.profile=()=>t$2(this,c)[t$2(this,a$2)].instance.profile(),this.previewEnabled=()=>t$2(this,c)[t$2(this,a$2)].preview,this.previewsList=()=>t$2(this,f$1),this.backendsList=()=>t$2(this,d),o(this,T,et=>{t$2(this,d).forEach(tt=>{tt.transition&&et.addEventListener(tt.transition.event,t$2(this,v$1))})}),o(this,E$1,et=>{t$2(this,d).forEach(tt=>{tt.transition&&et.removeEventListener(tt.transition.event,t$2(this,v$1))})}),o(this,v$1,et=>{var nt;let tt=t$2(this,a$2);if(t$2(this,d).some(rt=>rt.id!==t$2(this,a$2)&&rt.transition&&rt.transition.check(et)?(p$4(this,a$2,rt.id),!0):!1),t$2(this,a$2)!==tt){t$2(this,c)[tt].instance.teardown(),Object.keys(t$2(this,h$2)).forEach(ot=>{let st=t$2(this,h$2)[ot];st.unsubscribe(),st.unsubscribe=t$2(this,y).call(this,st.func,...st.args)}),t$2(this,f$1).backendChanged(this);let rt=t$2(this,c)[t$2(this,a$2)];if(rt.instance.setup(),rt.skipDispatchOnTransition)return;let at=et.constructor,it=new at(et.type,et);(nt=et.target)==null||nt.dispatchEvent(it)}}),o(this,y,(et,tt,nt,rt)=>t$2(this,c)[t$2(this,a$2)].instance[et](tt,nt,rt)),o(this,g$1,(et,tt,nt,rt)=>{let at=`${et}_${tt}`,it=t$2(this,y).call(this,et,tt,nt,rt);return t$2(this,h$2)[at]={func:et,args:[tt,nt,rt],unsubscribe:it},()=>{t$2(this,h$2)[at].unsubscribe(),delete t$2(this,h$2)[at]}}),!_e||!_e.backends||_e.backends.length<1)throw new Error(`You must specify at least one Backend, if you are coming from 2.x.x (or don't understand this error)
        see this guide: https://github.com/louisbrunner/dnd-multi-backend/tree/master/packages/react-dnd-multi-backend#migrating-from-2xx`);p$4(this,f$1,new b),p$4(this,c,{}),p$4(this,d,[]),_e.backends.forEach(et=>{let tt=t$2(this,x$1).call(this,j,$,et);t$2(this,c)[tt.id]=tt,t$2(this,d).push(tt)}),p$4(this,a$2,t$2(this,d)[0].id),p$4(this,h$2,{})}};a$2=new WeakMap,f$1=new WeakMap,c=new WeakMap,d=new WeakMap,h$2=new WeakMap,x$1=new WeakMap,T=new WeakMap,E$1=new WeakMap,v$1=new WeakMap,y=new WeakMap,g$1=new WeakMap,l$2.isSetUp=!1;var M=l$2,P=(_,j,$)=>new M(_,j,$),m$1=(_,j)=>({event:_,check:j}),S=m$1("touchstart",_=>{let j=_;return j.touches!==null&&j.touches!==void 0}),L=m$1("dragstart",_=>_.type.indexOf("drag")!==-1||_.type.indexOf("drop")!==-1),O=m$1("mousedown",_=>_.type.indexOf("touch")===-1&&_.type.indexOf("mouse")!==-1),C=m$1("pointerdown",_=>_.pointerType=="mouse"),s$1={backends:[{id:"html5",backend:HTML5Backend,transition:C},{id:"touch",backend:TouchBackend,options:{enableMouseEvents:!0},preview:!0,transition:S}]};const dist$2=Object.freeze(Object.defineProperty({__proto__:null,HTML5toTouch:s$1},Symbol.toStringTag,{value:"Module"})),require$$4=getAugmentedNamespace(dist$2),DndContext=reactExports.createContext({dragDropManager:void 0});function formatProdErrorMessage(_){return"Minified Redux error #"+_+"; visit https://redux.js.org/Errors?code="+_+" for the full message or use the non-minified dev environment for full errors. "}var $$observable=function(){return typeof Symbol=="function"&&Symbol.observable||"@@observable"}(),randomString=function _(){return Math.random().toString(36).substring(7).split("").join(".")},ActionTypes={INIT:"@@redux/INIT"+randomString(),REPLACE:"@@redux/REPLACE"+randomString(),PROBE_UNKNOWN_ACTION:function _(){return"@@redux/PROBE_UNKNOWN_ACTION"+randomString()}};function isPlainObject(_){if(typeof _!="object"||_===null)return!1;for(var j=_;Object.getPrototypeOf(j)!==null;)j=Object.getPrototypeOf(j);return Object.getPrototypeOf(_)===j}function createStore$1(_,j,$){var _e;if(typeof j=="function"&&typeof $=="function"||typeof $=="function"&&typeof arguments[3]=="function")throw new Error(formatProdErrorMessage(0));if(typeof j=="function"&&typeof $>"u"&&($=j,j=void 0),typeof $<"u"){if(typeof $!="function")throw new Error(formatProdErrorMessage(1));return $(createStore$1)(_,j)}if(typeof _!="function")throw new Error(formatProdErrorMessage(2));var et=_,tt=j,nt=[],rt=nt,at=!1;function it(){rt===nt&&(rt=nt.slice())}function ot(){if(at)throw new Error(formatProdErrorMessage(3));return tt}function st(ft){if(typeof ft!="function")throw new Error(formatProdErrorMessage(4));if(at)throw new Error(formatProdErrorMessage(5));var gt=!0;return it(),rt.push(ft),function(){if(gt){if(at)throw new Error(formatProdErrorMessage(6));gt=!1,it();var lt=rt.indexOf(ft);rt.splice(lt,1),nt=null}}}function ct(ft){if(!isPlainObject(ft))throw new Error(formatProdErrorMessage(7));if(typeof ft.type>"u")throw new Error(formatProdErrorMessage(8));if(at)throw new Error(formatProdErrorMessage(9));try{at=!0,tt=et(tt,ft)}finally{at=!1}for(var gt=nt=rt,ut=0;ut<gt.length;ut++){var lt=gt[ut];lt()}return ft}function pt(ft){if(typeof ft!="function")throw new Error(formatProdErrorMessage(10));et=ft,ct({type:ActionTypes.REPLACE})}function dt(){var ft,gt=st;return ft={subscribe:function(lt){if(typeof lt!="object"||lt===null)throw new Error(formatProdErrorMessage(11));function ht(){lt.next&&lt.next(ot())}ht();var yt=gt(ht);return{unsubscribe:yt}}},ft[$$observable]=function(){return this},ft}return ct({type:ActionTypes.INIT}),_e={dispatch:ct,subscribe:st,getState:ot,replaceReducer:pt},_e[$$observable]=dt,_e}function get(_,j,$){return j.split(".").reduce((_e,et)=>_e&&_e[et]?_e[et]:$||null,_)}function without(_,j){return _.filter($=>$!==j)}function isObject$4(_){return typeof _=="object"}function xor(_,j){const $=new Map,_e=tt=>{$.set(tt,$.has(tt)?$.get(tt)+1:1)};_.forEach(_e),j.forEach(_e);const et=[];return $.forEach((tt,nt)=>{tt===1&&et.push(nt)}),et}function intersection(_,j){return _.filter($=>j.indexOf($)>-1)}const INIT_COORDS="dnd-core/INIT_COORDS",BEGIN_DRAG="dnd-core/BEGIN_DRAG",PUBLISH_DRAG_SOURCE="dnd-core/PUBLISH_DRAG_SOURCE",HOVER="dnd-core/HOVER",DROP="dnd-core/DROP",END_DRAG="dnd-core/END_DRAG";function setClientOffset(_,j){return{type:INIT_COORDS,payload:{sourceClientOffset:j||null,clientOffset:_||null}}}const ResetCoordinatesAction={type:INIT_COORDS,payload:{clientOffset:null,sourceClientOffset:null}};function createBeginDrag(_){return function($=[],_e={publishSource:!0}){const{publishSource:et=!0,clientOffset:tt,getSourceClientOffset:nt}=_e,rt=_.getMonitor(),at=_.getRegistry();_.dispatch(setClientOffset(tt)),verifyInvariants$1($,rt,at);const it=getDraggableSource($,rt);if(it==null){_.dispatch(ResetCoordinatesAction);return}let ot=null;if(tt){if(!nt)throw new Error("getSourceClientOffset must be defined");verifyGetSourceClientOffsetIsFunction(nt),ot=nt(it)}_.dispatch(setClientOffset(tt,ot));const ct=at.getSource(it).beginDrag(rt,it);if(ct==null)return;verifyItemIsObject(ct),at.pinSource(it);const pt=at.getSourceType(it);return{type:BEGIN_DRAG,payload:{itemType:pt,item:ct,sourceId:it,clientOffset:tt||null,sourceClientOffset:ot||null,isSourcePublic:!!et}}}}function verifyInvariants$1(_,j,$){invariant(!j.isDragging(),"Cannot call beginDrag while dragging."),_.forEach(function(_e){invariant($.getSource(_e),"Expected sourceIds to be registered.")})}function verifyGetSourceClientOffsetIsFunction(_){invariant(typeof _=="function","When clientOffset is provided, getSourceClientOffset must be a function.")}function verifyItemIsObject(_){invariant(isObject$4(_),"Item must be an object.")}function getDraggableSource(_,j){let $=null;for(let _e=_.length-1;_e>=0;_e--)if(j.canDragSource(_[_e])){$=_[_e];break}return $}function _defineProperty$3(_,j,$){return j in _?Object.defineProperty(_,j,{value:$,enumerable:!0,configurable:!0,writable:!0}):_[j]=$,_}function _objectSpread$3(_){for(var j=1;j<arguments.length;j++){var $=arguments[j]!=null?arguments[j]:{},_e=Object.keys($);typeof Object.getOwnPropertySymbols=="function"&&(_e=_e.concat(Object.getOwnPropertySymbols($).filter(function(et){return Object.getOwnPropertyDescriptor($,et).enumerable}))),_e.forEach(function(et){_defineProperty$3(_,et,$[et])})}return _}function createDrop(_){return function($={}){const _e=_.getMonitor(),et=_.getRegistry();verifyInvariants(_e),getDroppableTargets(_e).forEach((nt,rt)=>{const at=determineDropResult(nt,rt,et,_e),it={type:DROP,payload:{dropResult:_objectSpread$3({},$,at)}};_.dispatch(it)})}}function verifyInvariants(_){invariant(_.isDragging(),"Cannot call drop while not dragging."),invariant(!_.didDrop(),"Cannot call drop twice during one drag operation.")}function determineDropResult(_,j,$,_e){const et=$.getTarget(_);let tt=et?et.drop(_e,_):void 0;return verifyDropResultType(tt),typeof tt>"u"&&(tt=j===0?{}:_e.getDropResult()),tt}function verifyDropResultType(_){invariant(typeof _>"u"||isObject$4(_),"Drop result must either be an object or undefined.")}function getDroppableTargets(_){const j=_.getTargetIds().filter(_.canDropOnTarget,_);return j.reverse(),j}function createEndDrag(_){return function(){const $=_.getMonitor(),_e=_.getRegistry();verifyIsDragging($);const et=$.getSourceId();return et!=null&&(_e.getSource(et,!0).endDrag($,et),_e.unpinSource()),{type:END_DRAG}}}function verifyIsDragging(_){invariant(_.isDragging(),"Cannot call endDrag while not dragging.")}function matchesType(_,j){return j===null?_===null:Array.isArray(_)?_.some($=>$===j):_===j}function createHover(_){return function($,{clientOffset:_e}={}){verifyTargetIdsIsArray($);const et=$.slice(0),tt=_.getMonitor(),nt=_.getRegistry(),rt=tt.getItemType();return removeNonMatchingTargetIds(et,nt,rt),checkInvariants(et,tt,nt),hoverAllTargets(et,tt,nt),{type:HOVER,payload:{targetIds:et,clientOffset:_e||null}}}}function verifyTargetIdsIsArray(_){invariant(Array.isArray(_),"Expected targetIds to be an array.")}function checkInvariants(_,j,$){invariant(j.isDragging(),"Cannot call hover while not dragging."),invariant(!j.didDrop(),"Cannot call hover after drop.");for(let _e=0;_e<_.length;_e++){const et=_[_e];invariant(_.lastIndexOf(et)===_e,"Expected targetIds to be unique in the passed array.");const tt=$.getTarget(et);invariant(tt,"Expected targetIds to be registered.")}}function removeNonMatchingTargetIds(_,j,$){for(let _e=_.length-1;_e>=0;_e--){const et=_[_e],tt=j.getTargetType(et);matchesType(tt,$)||_.splice(_e,1)}}function hoverAllTargets(_,j,$){_.forEach(function(_e){$.getTarget(_e).hover(j,_e)})}function createPublishDragSource(_){return function(){if(_.getMonitor().isDragging())return{type:PUBLISH_DRAG_SOURCE}}}function createDragDropActions(_){return{beginDrag:createBeginDrag(_),publishDragSource:createPublishDragSource(_),hover:createHover(_),drop:createDrop(_),endDrag:createEndDrag(_)}}class DragDropManagerImpl{receiveBackend(j){this.backend=j}getMonitor(){return this.monitor}getBackend(){return this.backend}getRegistry(){return this.monitor.registry}getActions(){const j=this,{dispatch:$}=this.store;function _e(tt){return(...nt)=>{const rt=tt.apply(j,nt);typeof rt<"u"&&$(rt)}}const et=createDragDropActions(this);return Object.keys(et).reduce((tt,nt)=>{const rt=et[nt];return tt[nt]=_e(rt),tt},{})}dispatch(j){this.store.dispatch(j)}constructor(j,$){this.isSetUp=!1,this.handleRefCountChange=()=>{const _e=this.store.getState().refCount>0;this.backend&&(_e&&!this.isSetUp?(this.backend.setup(),this.isSetUp=!0):!_e&&this.isSetUp&&(this.backend.teardown(),this.isSetUp=!1))},this.store=j,this.monitor=$,j.subscribe(this.handleRefCountChange)}}function add(_,j){return{x:_.x+j.x,y:_.y+j.y}}function subtract(_,j){return{x:_.x-j.x,y:_.y-j.y}}function getSourceClientOffset(_){const{clientOffset:j,initialClientOffset:$,initialSourceClientOffset:_e}=_;return!j||!$||!_e?null:subtract(add(j,_e),$)}function getDifferenceFromInitialOffset(_){const{clientOffset:j,initialClientOffset:$}=_;return!j||!$?null:subtract(j,$)}const NONE=[],ALL=[];NONE.__IS_NONE__=!0;ALL.__IS_ALL__=!0;function areDirty(_,j){return _===NONE?!1:_===ALL||typeof j>"u"?!0:intersection(j,_).length>0}class DragDropMonitorImpl{subscribeToStateChange(j,$={}){const{handlerIds:_e}=$;invariant(typeof j=="function","listener must be a function."),invariant(typeof _e>"u"||Array.isArray(_e),"handlerIds, when specified, must be an array of strings.");let et=this.store.getState().stateId;const tt=()=>{const nt=this.store.getState(),rt=nt.stateId;try{rt===et||rt===et+1&&!areDirty(nt.dirtyHandlerIds,_e)||j()}finally{et=rt}};return this.store.subscribe(tt)}subscribeToOffsetChange(j){invariant(typeof j=="function","listener must be a function.");let $=this.store.getState().dragOffset;const _e=()=>{const et=this.store.getState().dragOffset;et!==$&&($=et,j())};return this.store.subscribe(_e)}canDragSource(j){if(!j)return!1;const $=this.registry.getSource(j);return invariant($,`Expected to find a valid source. sourceId=${j}`),this.isDragging()?!1:$.canDrag(this,j)}canDropOnTarget(j){if(!j)return!1;const $=this.registry.getTarget(j);if(invariant($,`Expected to find a valid target. targetId=${j}`),!this.isDragging()||this.didDrop())return!1;const _e=this.registry.getTargetType(j),et=this.getItemType();return matchesType(_e,et)&&$.canDrop(this,j)}isDragging(){return!!this.getItemType()}isDraggingSource(j){if(!j)return!1;const $=this.registry.getSource(j,!0);if(invariant($,`Expected to find a valid source. sourceId=${j}`),!this.isDragging()||!this.isSourcePublic())return!1;const _e=this.registry.getSourceType(j),et=this.getItemType();return _e!==et?!1:$.isDragging(this,j)}isOverTarget(j,$={shallow:!1}){if(!j)return!1;const{shallow:_e}=$;if(!this.isDragging())return!1;const et=this.registry.getTargetType(j),tt=this.getItemType();if(tt&&!matchesType(et,tt))return!1;const nt=this.getTargetIds();if(!nt.length)return!1;const rt=nt.indexOf(j);return _e?rt===nt.length-1:rt>-1}getItemType(){return this.store.getState().dragOperation.itemType}getItem(){return this.store.getState().dragOperation.item}getSourceId(){return this.store.getState().dragOperation.sourceId}getTargetIds(){return this.store.getState().dragOperation.targetIds}getDropResult(){return this.store.getState().dragOperation.dropResult}didDrop(){return this.store.getState().dragOperation.didDrop}isSourcePublic(){return!!this.store.getState().dragOperation.isSourcePublic}getInitialClientOffset(){return this.store.getState().dragOffset.initialClientOffset}getInitialSourceClientOffset(){return this.store.getState().dragOffset.initialSourceClientOffset}getClientOffset(){return this.store.getState().dragOffset.clientOffset}getSourceClientOffset(){return getSourceClientOffset(this.store.getState().dragOffset)}getDifferenceFromInitialOffset(){return getDifferenceFromInitialOffset(this.store.getState().dragOffset)}constructor(j,$){this.store=j,this.registry=$}}const scope=typeof global<"u"?global:self,BrowserMutationObserver=scope.MutationObserver||scope.WebKitMutationObserver;function makeRequestCallFromTimer(_){return function(){const $=setTimeout(et,0),_e=setInterval(et,50);function et(){clearTimeout($),clearInterval(_e),_()}}}function makeRequestCallFromMutationObserver(_){let j=1;const $=new BrowserMutationObserver(_),_e=document.createTextNode("");return $.observe(_e,{characterData:!0}),function(){j=-j,_e.data=j}}const makeRequestCall=typeof BrowserMutationObserver=="function"?makeRequestCallFromMutationObserver:makeRequestCallFromTimer;class AsapQueue{enqueueTask(j){const{queue:$,requestFlush:_e}=this;$.length||(_e(),this.flushing=!0),$[$.length]=j}constructor(){this.queue=[],this.pendingErrors=[],this.flushing=!1,this.index=0,this.capacity=1024,this.flush=()=>{const{queue:j}=this;for(;this.index<j.length;){const $=this.index;if(this.index++,j[$].call(),this.index>this.capacity){for(let _e=0,et=j.length-this.index;_e<et;_e++)j[_e]=j[_e+this.index];j.length-=this.index,this.index=0}}j.length=0,this.index=0,this.flushing=!1},this.registerPendingError=j=>{this.pendingErrors.push(j),this.requestErrorThrow()},this.requestFlush=makeRequestCall(this.flush),this.requestErrorThrow=makeRequestCallFromTimer(()=>{if(this.pendingErrors.length)throw this.pendingErrors.shift()})}}class RawTask{call(){try{this.task&&this.task()}catch(j){this.onError(j)}finally{this.task=null,this.release(this)}}constructor(j,$){this.onError=j,this.release=$,this.task=null}}class TaskFactory{create(j){const $=this.freeTasks,_e=$.length?$.pop():new RawTask(this.onError,et=>$[$.length]=et);return _e.task=j,_e}constructor(j){this.onError=j,this.freeTasks=[]}}const asapQueue=new AsapQueue,taskFactory=new TaskFactory(asapQueue.registerPendingError);function asap(_){asapQueue.enqueueTask(taskFactory.create(_))}const ADD_SOURCE="dnd-core/ADD_SOURCE",ADD_TARGET="dnd-core/ADD_TARGET",REMOVE_SOURCE="dnd-core/REMOVE_SOURCE",REMOVE_TARGET="dnd-core/REMOVE_TARGET";function addSource(_){return{type:ADD_SOURCE,payload:{sourceId:_}}}function addTarget(_){return{type:ADD_TARGET,payload:{targetId:_}}}function removeSource(_){return{type:REMOVE_SOURCE,payload:{sourceId:_}}}function removeTarget(_){return{type:REMOVE_TARGET,payload:{targetId:_}}}function validateSourceContract(_){invariant(typeof _.canDrag=="function","Expected canDrag to be a function."),invariant(typeof _.beginDrag=="function","Expected beginDrag to be a function."),invariant(typeof _.endDrag=="function","Expected endDrag to be a function.")}function validateTargetContract(_){invariant(typeof _.canDrop=="function","Expected canDrop to be a function."),invariant(typeof _.hover=="function","Expected hover to be a function."),invariant(typeof _.drop=="function","Expected beginDrag to be a function.")}function validateType(_,j){if(j&&Array.isArray(_)){_.forEach($=>validateType($,!1));return}invariant(typeof _=="string"||typeof _=="symbol",j?"Type can only be a string, a symbol, or an array of either.":"Type can only be a string or a symbol.")}var HandlerRole;(function(_){_.SOURCE="SOURCE",_.TARGET="TARGET"})(HandlerRole||(HandlerRole={}));let nextUniqueId=0;function getNextUniqueId(){return nextUniqueId++}function getNextHandlerId(_){const j=getNextUniqueId().toString();switch(_){case HandlerRole.SOURCE:return`S${j}`;case HandlerRole.TARGET:return`T${j}`;default:throw new Error(`Unknown Handler Role: ${_}`)}}function parseRoleFromHandlerId(_){switch(_[0]){case"S":return HandlerRole.SOURCE;case"T":return HandlerRole.TARGET;default:throw new Error(`Cannot parse handler ID: ${_}`)}}function mapContainsValue(_,j){const $=_.entries();let _e=!1;do{const{done:et,value:[,tt]}=$.next();if(tt===j)return!0;_e=!!et}while(!_e);return!1}class HandlerRegistryImpl{addSource(j,$){validateType(j),validateSourceContract($);const _e=this.addHandler(HandlerRole.SOURCE,j,$);return this.store.dispatch(addSource(_e)),_e}addTarget(j,$){validateType(j,!0),validateTargetContract($);const _e=this.addHandler(HandlerRole.TARGET,j,$);return this.store.dispatch(addTarget(_e)),_e}containsHandler(j){return mapContainsValue(this.dragSources,j)||mapContainsValue(this.dropTargets,j)}getSource(j,$=!1){return invariant(this.isSourceId(j),"Expected a valid source ID."),$&&j===this.pinnedSourceId?this.pinnedSource:this.dragSources.get(j)}getTarget(j){return invariant(this.isTargetId(j),"Expected a valid target ID."),this.dropTargets.get(j)}getSourceType(j){return invariant(this.isSourceId(j),"Expected a valid source ID."),this.types.get(j)}getTargetType(j){return invariant(this.isTargetId(j),"Expected a valid target ID."),this.types.get(j)}isSourceId(j){return parseRoleFromHandlerId(j)===HandlerRole.SOURCE}isTargetId(j){return parseRoleFromHandlerId(j)===HandlerRole.TARGET}removeSource(j){invariant(this.getSource(j),"Expected an existing source."),this.store.dispatch(removeSource(j)),asap(()=>{this.dragSources.delete(j),this.types.delete(j)})}removeTarget(j){invariant(this.getTarget(j),"Expected an existing target."),this.store.dispatch(removeTarget(j)),this.dropTargets.delete(j),this.types.delete(j)}pinSource(j){const $=this.getSource(j);invariant($,"Expected an existing source."),this.pinnedSourceId=j,this.pinnedSource=$}unpinSource(){invariant(this.pinnedSource,"No source is pinned at the time."),this.pinnedSourceId=null,this.pinnedSource=null}addHandler(j,$,_e){const et=getNextHandlerId(j);return this.types.set(et,$),j===HandlerRole.SOURCE?this.dragSources.set(et,_e):j===HandlerRole.TARGET&&this.dropTargets.set(et,_e),et}constructor(j){this.types=new Map,this.dragSources=new Map,this.dropTargets=new Map,this.pinnedSourceId=null,this.pinnedSource=null,this.store=j}}const strictEquality=(_,j)=>_===j;function areCoordsEqual(_,j){return!_&&!j?!0:!_||!j?!1:_.x===j.x&&_.y===j.y}function areArraysEqual(_,j,$=strictEquality){if(_.length!==j.length)return!1;for(let _e=0;_e<_.length;++_e)if(!$(_[_e],j[_e]))return!1;return!0}function reduce$5(_=NONE,j){switch(j.type){case HOVER:break;case ADD_SOURCE:case ADD_TARGET:case REMOVE_TARGET:case REMOVE_SOURCE:return NONE;case BEGIN_DRAG:case PUBLISH_DRAG_SOURCE:case END_DRAG:case DROP:default:return ALL}const{targetIds:$=[],prevTargetIds:_e=[]}=j.payload,et=xor($,_e);if(!(et.length>0||!areArraysEqual($,_e)))return NONE;const nt=_e[_e.length-1],rt=$[$.length-1];return nt!==rt&&(nt&&et.push(nt),rt&&et.push(rt)),et}function _defineProperty$2(_,j,$){return j in _?Object.defineProperty(_,j,{value:$,enumerable:!0,configurable:!0,writable:!0}):_[j]=$,_}function _objectSpread$2(_){for(var j=1;j<arguments.length;j++){var $=arguments[j]!=null?arguments[j]:{},_e=Object.keys($);typeof Object.getOwnPropertySymbols=="function"&&(_e=_e.concat(Object.getOwnPropertySymbols($).filter(function(et){return Object.getOwnPropertyDescriptor($,et).enumerable}))),_e.forEach(function(et){_defineProperty$2(_,et,$[et])})}return _}const initialState$1={initialSourceClientOffset:null,initialClientOffset:null,clientOffset:null};function reduce$4(_=initialState$1,j){const{payload:$}=j;switch(j.type){case INIT_COORDS:case BEGIN_DRAG:return{initialSourceClientOffset:$.sourceClientOffset,initialClientOffset:$.clientOffset,clientOffset:$.clientOffset};case HOVER:return areCoordsEqual(_.clientOffset,$.clientOffset)?_:_objectSpread$2({},_,{clientOffset:$.clientOffset});case END_DRAG:case DROP:return initialState$1;default:return _}}function _defineProperty$1(_,j,$){return j in _?Object.defineProperty(_,j,{value:$,enumerable:!0,configurable:!0,writable:!0}):_[j]=$,_}function _objectSpread$1(_){for(var j=1;j<arguments.length;j++){var $=arguments[j]!=null?arguments[j]:{},_e=Object.keys($);typeof Object.getOwnPropertySymbols=="function"&&(_e=_e.concat(Object.getOwnPropertySymbols($).filter(function(et){return Object.getOwnPropertyDescriptor($,et).enumerable}))),_e.forEach(function(et){_defineProperty$1(_,et,$[et])})}return _}const initialState={itemType:null,item:null,sourceId:null,targetIds:[],dropResult:null,didDrop:!1,isSourcePublic:null};function reduce$3(_=initialState,j){const{payload:$}=j;switch(j.type){case BEGIN_DRAG:return _objectSpread$1({},_,{itemType:$.itemType,item:$.item,sourceId:$.sourceId,isSourcePublic:$.isSourcePublic,dropResult:null,didDrop:!1});case PUBLISH_DRAG_SOURCE:return _objectSpread$1({},_,{isSourcePublic:!0});case HOVER:return _objectSpread$1({},_,{targetIds:$.targetIds});case REMOVE_TARGET:return _.targetIds.indexOf($.targetId)===-1?_:_objectSpread$1({},_,{targetIds:without(_.targetIds,$.targetId)});case DROP:return _objectSpread$1({},_,{dropResult:$.dropResult,didDrop:!0,targetIds:[]});case END_DRAG:return _objectSpread$1({},_,{itemType:null,item:null,sourceId:null,dropResult:null,didDrop:!1,isSourcePublic:null,targetIds:[]});default:return _}}function reduce$2(_=0,j){switch(j.type){case ADD_SOURCE:case ADD_TARGET:return _+1;case REMOVE_SOURCE:case REMOVE_TARGET:return _-1;default:return _}}function reduce$1(_=0){return _+1}function _defineProperty(_,j,$){return j in _?Object.defineProperty(_,j,{value:$,enumerable:!0,configurable:!0,writable:!0}):_[j]=$,_}function _objectSpread(_){for(var j=1;j<arguments.length;j++){var $=arguments[j]!=null?arguments[j]:{},_e=Object.keys($);typeof Object.getOwnPropertySymbols=="function"&&(_e=_e.concat(Object.getOwnPropertySymbols($).filter(function(et){return Object.getOwnPropertyDescriptor($,et).enumerable}))),_e.forEach(function(et){_defineProperty(_,et,$[et])})}return _}function reduce(_={},j){return{dirtyHandlerIds:reduce$5(_.dirtyHandlerIds,{type:j.type,payload:_objectSpread({},j.payload,{prevTargetIds:get(_,"dragOperation.targetIds",[])})}),dragOffset:reduce$4(_.dragOffset,j),refCount:reduce$2(_.refCount,j),dragOperation:reduce$3(_.dragOperation,j),stateId:reduce$1(_.stateId)}}function createDragDropManager(_,j=void 0,$={},_e=!1){const et=makeStoreInstance(_e),tt=new DragDropMonitorImpl(et,new HandlerRegistryImpl(et)),nt=new DragDropManagerImpl(et,tt),rt=_(nt,j,$);return nt.receiveBackend(rt),nt}function makeStoreInstance(_){const j=typeof window<"u"&&window.__REDUX_DEVTOOLS_EXTENSION__;return createStore$1(reduce,_&&j&&j({name:"dnd-core",instanceId:"dnd-core"}))}function _objectWithoutProperties(_,j){if(_==null)return{};var $=_objectWithoutPropertiesLoose(_,j),_e,et;if(Object.getOwnPropertySymbols){var tt=Object.getOwnPropertySymbols(_);for(et=0;et<tt.length;et++)_e=tt[et],!(j.indexOf(_e)>=0)&&Object.prototype.propertyIsEnumerable.call(_,_e)&&($[_e]=_[_e])}return $}function _objectWithoutPropertiesLoose(_,j){if(_==null)return{};var $={},_e=Object.keys(_),et,tt;for(tt=0;tt<_e.length;tt++)et=_e[tt],!(j.indexOf(et)>=0)&&($[et]=_[et]);return $}let refCount=0;const INSTANCE_SYM=Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");var DndProvider=reactExports.memo(function _(j){var{children:$}=j,_e=_objectWithoutProperties(j,["children"]);const[et,tt]=getDndContextValue(_e);return reactExports.useEffect(()=>{if(tt){const nt=getGlobalContext();return++refCount,()=>{--refCount===0&&(nt[INSTANCE_SYM]=null)}}},[]),jsxRuntimeExports.jsx(DndContext.Provider,{value:et,children:$})});function getDndContextValue(_){if("manager"in _)return[{dragDropManager:_.manager},!1];const j=createSingletonDndContext(_.backend,_.context,_.options,_.debugMode),$=!_.context;return[j,$]}function createSingletonDndContext(_,j=getGlobalContext(),$,_e){const et=j;return et[INSTANCE_SYM]||(et[INSTANCE_SYM]={dragDropManager:createDragDropManager(_,j,$,_e)}),et[INSTANCE_SYM]}function getGlobalContext(){return typeof global<"u"?global:window}const DragPreviewImage=reactExports.memo(function _({connect:j,src:$}){return reactExports.useEffect(()=>{if(typeof Image>"u")return;let _e=!1;const et=new Image;return et.src=$,et.onload=()=>{j(et),_e=!0},()=>{_e&&j(null)}}),null});var fastDeepEqual=function _(j,$){if(j===$)return!0;if(j&&$&&typeof j=="object"&&typeof $=="object"){if(j.constructor!==$.constructor)return!1;var _e,et,tt;if(Array.isArray(j)){if(_e=j.length,_e!=$.length)return!1;for(et=_e;et--!==0;)if(!_(j[et],$[et]))return!1;return!0}if(j.constructor===RegExp)return j.source===$.source&&j.flags===$.flags;if(j.valueOf!==Object.prototype.valueOf)return j.valueOf()===$.valueOf();if(j.toString!==Object.prototype.toString)return j.toString()===$.toString();if(tt=Object.keys(j),_e=tt.length,_e!==Object.keys($).length)return!1;for(et=_e;et--!==0;)if(!Object.prototype.hasOwnProperty.call($,tt[et]))return!1;for(et=_e;et--!==0;){var nt=tt[et];if(!_(j[nt],$[nt]))return!1}return!0}return j!==j&&$!==$};const equal=getDefaultExportFromCjs(fastDeepEqual),useIsomorphicLayoutEffect=typeof window<"u"?reactExports.useLayoutEffect:reactExports.useEffect;function useCollector(_,j,$){const[_e,et]=reactExports.useState(()=>j(_)),tt=reactExports.useCallback(()=>{const nt=j(_);equal(_e,nt)||(et(nt),$&&$())},[_e,_,$]);return useIsomorphicLayoutEffect(tt),[_e,tt]}function useMonitorOutput(_,j,$){const[_e,et]=useCollector(_,j,$);return useIsomorphicLayoutEffect(function(){const nt=_.getHandlerId();if(nt!=null)return _.subscribeToStateChange(et,{handlerIds:[nt]})},[_,et]),_e}function useCollectedProps(_,j,$){return useMonitorOutput(j,_||(()=>({})),()=>$.reconnect())}function useOptionalFactory(_,j){const $=[...j||[]];return j==null&&typeof _!="function"&&$.push(_),reactExports.useMemo(()=>typeof _=="function"?_():_,$)}function useConnectDragSource(_){return reactExports.useMemo(()=>_.hooks.dragSource(),[_])}function useConnectDragPreview(_){return reactExports.useMemo(()=>_.hooks.dragPreview(),[_])}let isCallingCanDrag=!1,isCallingIsDragging=!1;class DragSourceMonitorImpl{receiveHandlerId(j){this.sourceId=j}getHandlerId(){return this.sourceId}canDrag(){invariant(!isCallingCanDrag,"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return isCallingCanDrag=!0,this.internalMonitor.canDragSource(this.sourceId)}finally{isCallingCanDrag=!1}}isDragging(){if(!this.sourceId)return!1;invariant(!isCallingIsDragging,"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return isCallingIsDragging=!0,this.internalMonitor.isDraggingSource(this.sourceId)}finally{isCallingIsDragging=!1}}subscribeToStateChange(j,$){return this.internalMonitor.subscribeToStateChange(j,$)}isDraggingSource(j){return this.internalMonitor.isDraggingSource(j)}isOverTarget(j,$){return this.internalMonitor.isOverTarget(j,$)}getTargetIds(){return this.internalMonitor.getTargetIds()}isSourcePublic(){return this.internalMonitor.isSourcePublic()}getSourceId(){return this.internalMonitor.getSourceId()}subscribeToOffsetChange(j){return this.internalMonitor.subscribeToOffsetChange(j)}canDragSource(j){return this.internalMonitor.canDragSource(j)}canDropOnTarget(j){return this.internalMonitor.canDropOnTarget(j)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(j){this.sourceId=null,this.internalMonitor=j.getMonitor()}}let isCallingCanDrop=!1;class DropTargetMonitorImpl{receiveHandlerId(j){this.targetId=j}getHandlerId(){return this.targetId}subscribeToStateChange(j,$){return this.internalMonitor.subscribeToStateChange(j,$)}canDrop(){if(!this.targetId)return!1;invariant(!isCallingCanDrop,"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");try{return isCallingCanDrop=!0,this.internalMonitor.canDropOnTarget(this.targetId)}finally{isCallingCanDrop=!1}}isOver(j){return this.targetId?this.internalMonitor.isOverTarget(this.targetId,j):!1}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(j){this.targetId=null,this.internalMonitor=j.getMonitor()}}function registerTarget(_,j,$){const _e=$.getRegistry(),et=_e.addTarget(_,j);return[et,()=>_e.removeTarget(et)]}function registerSource(_,j,$){const _e=$.getRegistry(),et=_e.addSource(_,j);return[et,()=>_e.removeSource(et)]}function shallowEqual(_,j,$,_e){let et;if(et!==void 0)return!!et;if(_===j)return!0;if(typeof _!="object"||!_||typeof j!="object"||!j)return!1;const tt=Object.keys(_),nt=Object.keys(j);if(tt.length!==nt.length)return!1;const rt=Object.prototype.hasOwnProperty.bind(j);for(let at=0;at<tt.length;at++){const it=tt[at];if(!rt(it))return!1;const ot=_[it],st=j[it];if(et=void 0,et===!1||et===void 0&&ot!==st)return!1}return!0}function isRef(_){return _!==null&&typeof _=="object"&&Object.prototype.hasOwnProperty.call(_,"current")}function throwIfCompositeComponentElement(_){if(typeof _.type=="string")return;const j=_.type.displayName||_.type.name||"the component";throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${j} into a <div>, or turn it into a drag source or a drop target itself.`)}function wrapHookToRecognizeElement(_){return(j=null,$=null)=>{if(!reactExports.isValidElement(j)){const tt=j;return _(tt,$),tt}const _e=j;return throwIfCompositeComponentElement(_e),cloneWithRef(_e,$?tt=>_(tt,$):_)}}function wrapConnectorHooks(_){const j={};return Object.keys(_).forEach($=>{const _e=_[$];if($.endsWith("Ref"))j[$]=_[$];else{const et=wrapHookToRecognizeElement(_e);j[$]=()=>et}}),j}function setRef(_,j){typeof _=="function"?_(j):_.current=j}function cloneWithRef(_,j){const $=_.ref;return invariant(typeof $!="string","Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"),$?reactExports.cloneElement(_,{ref:_e=>{setRef($,_e),setRef(j,_e)}}):reactExports.cloneElement(_,{ref:j})}class SourceConnector{receiveHandlerId(j){this.handlerId!==j&&(this.handlerId=j,this.reconnect())}get connectTarget(){return this.dragSource}get dragSourceOptions(){return this.dragSourceOptionsInternal}set dragSourceOptions(j){this.dragSourceOptionsInternal=j}get dragPreviewOptions(){return this.dragPreviewOptionsInternal}set dragPreviewOptions(j){this.dragPreviewOptionsInternal=j}reconnect(){const j=this.reconnectDragSource();this.reconnectDragPreview(j)}reconnectDragSource(){const j=this.dragSource,$=this.didHandlerIdChange()||this.didConnectedDragSourceChange()||this.didDragSourceOptionsChange();return $&&this.disconnectDragSource(),this.handlerId?j?($&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragSource=j,this.lastConnectedDragSourceOptions=this.dragSourceOptions,this.dragSourceUnsubscribe=this.backend.connectDragSource(this.handlerId,j,this.dragSourceOptions)),$):(this.lastConnectedDragSource=j,$):$}reconnectDragPreview(j=!1){const $=this.dragPreview,_e=j||this.didHandlerIdChange()||this.didConnectedDragPreviewChange()||this.didDragPreviewOptionsChange();if(_e&&this.disconnectDragPreview(),!!this.handlerId){if(!$){this.lastConnectedDragPreview=$;return}_e&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragPreview=$,this.lastConnectedDragPreviewOptions=this.dragPreviewOptions,this.dragPreviewUnsubscribe=this.backend.connectDragPreview(this.handlerId,$,this.dragPreviewOptions))}}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didConnectedDragSourceChange(){return this.lastConnectedDragSource!==this.dragSource}didConnectedDragPreviewChange(){return this.lastConnectedDragPreview!==this.dragPreview}didDragSourceOptionsChange(){return!shallowEqual(this.lastConnectedDragSourceOptions,this.dragSourceOptions)}didDragPreviewOptionsChange(){return!shallowEqual(this.lastConnectedDragPreviewOptions,this.dragPreviewOptions)}disconnectDragSource(){this.dragSourceUnsubscribe&&(this.dragSourceUnsubscribe(),this.dragSourceUnsubscribe=void 0)}disconnectDragPreview(){this.dragPreviewUnsubscribe&&(this.dragPreviewUnsubscribe(),this.dragPreviewUnsubscribe=void 0,this.dragPreviewNode=null,this.dragPreviewRef=null)}get dragSource(){return this.dragSourceNode||this.dragSourceRef&&this.dragSourceRef.current}get dragPreview(){return this.dragPreviewNode||this.dragPreviewRef&&this.dragPreviewRef.current}clearDragSource(){this.dragSourceNode=null,this.dragSourceRef=null}clearDragPreview(){this.dragPreviewNode=null,this.dragPreviewRef=null}constructor(j){this.hooks=wrapConnectorHooks({dragSource:($,_e)=>{this.clearDragSource(),this.dragSourceOptions=_e||null,isRef($)?this.dragSourceRef=$:this.dragSourceNode=$,this.reconnectDragSource()},dragPreview:($,_e)=>{this.clearDragPreview(),this.dragPreviewOptions=_e||null,isRef($)?this.dragPreviewRef=$:this.dragPreviewNode=$,this.reconnectDragPreview()}}),this.handlerId=null,this.dragSourceRef=null,this.dragSourceOptionsInternal=null,this.dragPreviewRef=null,this.dragPreviewOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDragSource=null,this.lastConnectedDragSourceOptions=null,this.lastConnectedDragPreview=null,this.lastConnectedDragPreviewOptions=null,this.backend=j}}class TargetConnector{get connectTarget(){return this.dropTarget}reconnect(){const j=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();j&&this.disconnectDropTarget();const $=this.dropTarget;if(this.handlerId){if(!$){this.lastConnectedDropTarget=$;return}j&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDropTarget=$,this.lastConnectedDropTargetOptions=this.dropTargetOptions,this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,$,this.dropTargetOptions))}}receiveHandlerId(j){j!==this.handlerId&&(this.handlerId=j,this.reconnect())}get dropTargetOptions(){return this.dropTargetOptionsInternal}set dropTargetOptions(j){this.dropTargetOptionsInternal=j}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didDropTargetChange(){return this.lastConnectedDropTarget!==this.dropTarget}didOptionsChange(){return!shallowEqual(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}disconnectDropTarget(){this.unsubscribeDropTarget&&(this.unsubscribeDropTarget(),this.unsubscribeDropTarget=void 0)}get dropTarget(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}clearDropTarget(){this.dropTargetRef=null,this.dropTargetNode=null}constructor(j){this.hooks=wrapConnectorHooks({dropTarget:($,_e)=>{this.clearDropTarget(),this.dropTargetOptions=_e,isRef($)?this.dropTargetRef=$:this.dropTargetNode=$,this.reconnect()}}),this.handlerId=null,this.dropTargetRef=null,this.dropTargetOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDropTarget=null,this.lastConnectedDropTargetOptions=null,this.backend=j}}function useDragDropManager(){const{dragDropManager:_}=reactExports.useContext(DndContext);return invariant(_!=null,"Expected drag drop context"),_}function useDragSourceConnector(_,j){const $=useDragDropManager(),_e=reactExports.useMemo(()=>new SourceConnector($.getBackend()),[$]);return useIsomorphicLayoutEffect(()=>(_e.dragSourceOptions=_||null,_e.reconnect(),()=>_e.disconnectDragSource()),[_e,_]),useIsomorphicLayoutEffect(()=>(_e.dragPreviewOptions=j||null,_e.reconnect(),()=>_e.disconnectDragPreview()),[_e,j]),_e}function useDragSourceMonitor(){const _=useDragDropManager();return reactExports.useMemo(()=>new DragSourceMonitorImpl(_),[_])}class DragSourceImpl{beginDrag(){const j=this.spec,$=this.monitor;let _e=null;return typeof j.item=="object"?_e=j.item:typeof j.item=="function"?_e=j.item($):_e={},_e??null}canDrag(){const j=this.spec,$=this.monitor;return typeof j.canDrag=="boolean"?j.canDrag:typeof j.canDrag=="function"?j.canDrag($):!0}isDragging(j,$){const _e=this.spec,et=this.monitor,{isDragging:tt}=_e;return tt?tt(et):$===j.getSourceId()}endDrag(){const j=this.spec,$=this.monitor,_e=this.connector,{end:et}=j;et&&et($.getItem(),$),_e.reconnect()}constructor(j,$,_e){this.spec=j,this.monitor=$,this.connector=_e}}function useDragSource(_,j,$){const _e=reactExports.useMemo(()=>new DragSourceImpl(_,j,$),[j,$]);return reactExports.useEffect(()=>{_e.spec=_},[_]),_e}function useDragType(_){return reactExports.useMemo(()=>{const j=_.type;return invariant(j!=null,"spec.type must be defined"),j},[_])}function useRegisteredDragSource(_,j,$){const _e=useDragDropManager(),et=useDragSource(_,j,$),tt=useDragType(_);useIsomorphicLayoutEffect(function(){if(tt!=null){const[rt,at]=registerSource(tt,et,_e);return j.receiveHandlerId(rt),$.receiveHandlerId(rt),at}},[_e,j,$,et,tt])}function useDrag(_,j){const $=useOptionalFactory(_,j);invariant(!$.begin,"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");const _e=useDragSourceMonitor(),et=useDragSourceConnector($.options,$.previewOptions);return useRegisteredDragSource($,_e,et),[useCollectedProps($.collect,_e,et),useConnectDragSource(et),useConnectDragPreview(et)]}function useDragLayer(_){const $=useDragDropManager().getMonitor(),[_e,et]=useCollector($,_);return reactExports.useEffect(()=>$.subscribeToOffsetChange(et)),reactExports.useEffect(()=>$.subscribeToStateChange(et)),_e}function useConnectDropTarget(_){return reactExports.useMemo(()=>_.hooks.dropTarget(),[_])}function useDropTargetConnector(_){const j=useDragDropManager(),$=reactExports.useMemo(()=>new TargetConnector(j.getBackend()),[j]);return useIsomorphicLayoutEffect(()=>($.dropTargetOptions=_||null,$.reconnect(),()=>$.disconnectDropTarget()),[_]),$}function useDropTargetMonitor(){const _=useDragDropManager();return reactExports.useMemo(()=>new DropTargetMonitorImpl(_),[_])}function useAccept(_){const{accept:j}=_;return reactExports.useMemo(()=>(invariant(_.accept!=null,"accept must be defined"),Array.isArray(j)?j:[j]),[j])}class DropTargetImpl{canDrop(){const j=this.spec,$=this.monitor;return j.canDrop?j.canDrop($.getItem(),$):!0}hover(){const j=this.spec,$=this.monitor;j.hover&&j.hover($.getItem(),$)}drop(){const j=this.spec,$=this.monitor;if(j.drop)return j.drop($.getItem(),$)}constructor(j,$){this.spec=j,this.monitor=$}}function useDropTarget(_,j){const $=reactExports.useMemo(()=>new DropTargetImpl(_,j),[j]);return reactExports.useEffect(()=>{$.spec=_},[_]),$}function useRegisteredDropTarget(_,j,$){const _e=useDragDropManager(),et=useDropTarget(_,j),tt=useAccept(_);useIsomorphicLayoutEffect(function(){const[rt,at]=registerTarget(tt,et,_e);return j.receiveHandlerId(rt),$.receiveHandlerId(rt),at},[_e,j,et,$,tt.map(nt=>nt.toString()).join("|")])}function useDrop(_,j){const $=useOptionalFactory(_,j),_e=useDropTargetMonitor(),et=useDropTargetConnector($.options);return useRegisteredDropTarget($,_e,et),[useCollectedProps($.collect,_e,et),useConnectDropTarget(et)]}const dist$1=Object.freeze(Object.defineProperty({__proto__:null,DndContext,DndProvider,DragPreviewImage,useDrag,useDragDropManager,useDragLayer,useDrop},Symbol.toStringTag,{value:"Module"})),require$$7$1=getAugmentedNamespace(dist$1);var i=(_,j)=>({x:_.x-j.x,y:_.y-j.y}),a$1=_=>{let j=_.getInitialClientOffset(),$=_.getInitialSourceClientOffset();return j===null||$===null?{x:0,y:0}:i(j,$)},u$3=(_,j)=>{let $=_.getClientOffset();if($===null)return null;if(!j.current||!j.current.getBoundingClientRect)return i($,a$1(_));let _e=j.current.getBoundingClientRect(),et={x:_e.width/2,y:_e.height/2};return i($,et)},p$3=_=>{let j=`translate(${_.x.toFixed(1)}px, ${_.y.toFixed(1)}px)`;return{pointerEvents:"none",position:"fixed",top:0,left:0,transform:j,WebkitTransform:j}},l$1=()=>{let _=reactExports.useRef(null),j=useDragLayer($=>({currentOffset:u$3($,_),isDragging:$.isDragging(),itemType:$.getItemType(),item:$.getItem(),monitor:$}));return!j.isDragging||j.currentOffset===null?{display:!1}:{display:!0,itemType:j.itemType,item:j.item,style:p$3(j.currentOffset),monitor:j.monitor,ref:_}},s=reactExports.createContext(void 0),x=_=>{let j=l$1();if(!j.display)return null;let{display:$,..._e}=j,et;return"children"in _?typeof _.children=="function"?et=_.children(_e):et=_.children:et=_.generator(_e),React.createElement(s.Provider,{value:_e},et)},u$2=reactExports.createContext(null),g=({portal:_,...j})=>{let[$,_e]=reactExports.useState(null);return React.createElement(u$2.Provider,{value:_??$},React.createElement(DndProvider,{backend:P,...j}),_?null:React.createElement("div",{ref:_e}))},p$2=()=>{let[_,j]=reactExports.useState(!1),$=reactExports.useContext(DndContext);return reactExports.useEffect(()=>{var tt;let _e=(tt=$==null?void 0:$.dragDropManager)==null?void 0:tt.getBackend(),et={backendChanged:nt=>{j(nt.previewEnabled())}};return j(_e.previewEnabled()),_e.previewsList().register(et),()=>{_e.previewsList().unregister(et)}},[$,$.dragDropManager]),_},E=_=>{let j=p$2(),$=reactExports.useContext(u$2);if(!j)return null;let _e=React.createElement(x,{..._});return $!==null?reactDomExports.createPortal(_e,$):_e};E.Context=s;var R=(_,j,$,_e)=>{let et=$.getBackend();$.receiveBackend(_e);let tt=j(_);return $.receiveBackend(et),tt},a=(_,j)=>{var rt;let $=reactExports.useContext(DndContext),_e=(rt=$==null?void 0:$.dragDropManager)==null?void 0:rt.getBackend();if(_e===void 0)throw new Error("could not find backend, make sure you are using a <DndProvider />");let et=j(_),tt={},nt=_e.backendsList();for(let at of nt)tt[at.id]=R(_,j,$.dragDropManager,at.instance);return[et,tt]},pe=_=>a(_,useDrag),le=_=>a(_,useDrop),Se=()=>{let _=p$2(),j=l$1();return _?j:{display:!1}};const dist=Object.freeze(Object.defineProperty({__proto__:null,DndProvider:g,HTML5DragTransition:L,MouseTransition:O,MultiBackend:P,PointerTransition:C,Preview:E,PreviewContext:s,TouchTransition:S,createTransition:m$1,useMultiDrag:pe,useMultiDrop:le,usePreview:Se},Symbol.toStringTag,{value:"Module"})),require$$7=getAugmentedNamespace(dist);var commonjsBrowser={},v1$1={},rng$1={};Object.defineProperty(rng$1,"__esModule",{value:!0});rng$1.default=rng;let getRandomValues;const rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}var stringify$1={},validate$1={},regex={};Object.defineProperty(regex,"__esModule",{value:!0});regex.default=void 0;var _default$c=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;regex.default=_default$c;Object.defineProperty(validate$1,"__esModule",{value:!0});validate$1.default=void 0;var _regex=_interopRequireDefault$8(regex);function _interopRequireDefault$8(_){return _&&_.__esModule?_:{default:_}}function validate(_){return typeof _=="string"&&_regex.default.test(_)}var _default$b=validate;validate$1.default=_default$b;Object.defineProperty(stringify$1,"__esModule",{value:!0});stringify$1.default=void 0;stringify$1.unsafeStringify=unsafeStringify;var _validate$2=_interopRequireDefault$7(validate$1);function _interopRequireDefault$7(_){return _&&_.__esModule?_:{default:_}}const byteToHex=[];for(let _=0;_<256;++_)byteToHex.push((_+256).toString(16).slice(1));function unsafeStringify(_,j=0){return byteToHex[_[j+0]]+byteToHex[_[j+1]]+byteToHex[_[j+2]]+byteToHex[_[j+3]]+"-"+byteToHex[_[j+4]]+byteToHex[_[j+5]]+"-"+byteToHex[_[j+6]]+byteToHex[_[j+7]]+"-"+byteToHex[_[j+8]]+byteToHex[_[j+9]]+"-"+byteToHex[_[j+10]]+byteToHex[_[j+11]]+byteToHex[_[j+12]]+byteToHex[_[j+13]]+byteToHex[_[j+14]]+byteToHex[_[j+15]]}function stringify(_,j=0){const $=unsafeStringify(_,j);if(!(0,_validate$2.default)($))throw TypeError("Stringified UUID is invalid");return $}var _default$a=stringify;stringify$1.default=_default$a;Object.defineProperty(v1$1,"__esModule",{value:!0});v1$1.default=void 0;var _rng$1=_interopRequireDefault$6(rng$1),_stringify$2=stringify$1;function _interopRequireDefault$6(_){return _&&_.__esModule?_:{default:_}}let _nodeId,_clockseq,_lastMSecs=0,_lastNSecs=0;function v1(_,j,$){let _e=j&&$||0;const et=j||new Array(16);_=_||{};let tt=_.node||_nodeId,nt=_.clockseq!==void 0?_.clockseq:_clockseq;if(tt==null||nt==null){const ct=_.random||(_.rng||_rng$1.default)();tt==null&&(tt=_nodeId=[ct[0]|1,ct[1],ct[2],ct[3],ct[4],ct[5]]),nt==null&&(nt=_clockseq=(ct[6]<<8|ct[7])&16383)}let rt=_.msecs!==void 0?_.msecs:Date.now(),at=_.nsecs!==void 0?_.nsecs:_lastNSecs+1;const it=rt-_lastMSecs+(at-_lastNSecs)/1e4;if(it<0&&_.clockseq===void 0&&(nt=nt+1&16383),(it<0||rt>_lastMSecs)&&_.nsecs===void 0&&(at=0),at>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");_lastMSecs=rt,_lastNSecs=at,_clockseq=nt,rt+=122192928e5;const ot=((rt&268435455)*1e4+at)%4294967296;et[_e++]=ot>>>24&255,et[_e++]=ot>>>16&255,et[_e++]=ot>>>8&255,et[_e++]=ot&255;const st=rt/4294967296*1e4&268435455;et[_e++]=st>>>8&255,et[_e++]=st&255,et[_e++]=st>>>24&15|16,et[_e++]=st>>>16&255,et[_e++]=nt>>>8|128,et[_e++]=nt&255;for(let ct=0;ct<6;++ct)et[_e+ct]=tt[ct];return j||(0,_stringify$2.unsafeStringify)(et)}var _default$9=v1;v1$1.default=_default$9;var v3$1={},v35$1={},parse$1={};Object.defineProperty(parse$1,"__esModule",{value:!0});parse$1.default=void 0;var _validate$1=_interopRequireDefault$5(validate$1);function _interopRequireDefault$5(_){return _&&_.__esModule?_:{default:_}}function parse(_){if(!(0,_validate$1.default)(_))throw TypeError("Invalid UUID");let j;const $=new Uint8Array(16);return $[0]=(j=parseInt(_.slice(0,8),16))>>>24,$[1]=j>>>16&255,$[2]=j>>>8&255,$[3]=j&255,$[4]=(j=parseInt(_.slice(9,13),16))>>>8,$[5]=j&255,$[6]=(j=parseInt(_.slice(14,18),16))>>>8,$[7]=j&255,$[8]=(j=parseInt(_.slice(19,23),16))>>>8,$[9]=j&255,$[10]=(j=parseInt(_.slice(24,36),16))/1099511627776&255,$[11]=j/4294967296&255,$[12]=j>>>24&255,$[13]=j>>>16&255,$[14]=j>>>8&255,$[15]=j&255,$}var _default$8=parse;parse$1.default=_default$8;Object.defineProperty(v35$1,"__esModule",{value:!0});v35$1.URL=v35$1.DNS=void 0;v35$1.default=v35;var _stringify$1=stringify$1,_parse=_interopRequireDefault$4(parse$1);function _interopRequireDefault$4(_){return _&&_.__esModule?_:{default:_}}function stringToBytes(_){_=unescape(encodeURIComponent(_));const j=[];for(let $=0;$<_.length;++$)j.push(_.charCodeAt($));return j}const DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8";v35$1.DNS=DNS;const URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8";v35$1.URL=URL;function v35(_,j,$){function _e(et,tt,nt,rt){var at;if(typeof et=="string"&&(et=stringToBytes(et)),typeof tt=="string"&&(tt=(0,_parse.default)(tt)),((at=tt)===null||at===void 0?void 0:at.length)!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");let it=new Uint8Array(16+et.length);if(it.set(tt),it.set(et,tt.length),it=$(it),it[6]=it[6]&15|j,it[8]=it[8]&63|128,nt){rt=rt||0;for(let ot=0;ot<16;++ot)nt[rt+ot]=it[ot];return nt}return(0,_stringify$1.unsafeStringify)(it)}try{_e.name=_}catch{}return _e.DNS=DNS,_e.URL=URL,_e}var md5$1={};Object.defineProperty(md5$1,"__esModule",{value:!0});md5$1.default=void 0;function md5(_){if(typeof _=="string"){const j=unescape(encodeURIComponent(_));_=new Uint8Array(j.length);for(let $=0;$<j.length;++$)_[$]=j.charCodeAt($)}return md5ToHexEncodedArray(wordsToMd5(bytesToWords(_),_.length*8))}function md5ToHexEncodedArray(_){const j=[],$=_.length*32,_e="0123456789abcdef";for(let et=0;et<$;et+=8){const tt=_[et>>5]>>>et%32&255,nt=parseInt(_e.charAt(tt>>>4&15)+_e.charAt(tt&15),16);j.push(nt)}return j}function getOutputLength(_){return(_+64>>>9<<4)+14+1}function wordsToMd5(_,j){_[j>>5]|=128<<j%32,_[getOutputLength(j)-1]=j;let $=1732584193,_e=-271733879,et=-1732584194,tt=271733878;for(let nt=0;nt<_.length;nt+=16){const rt=$,at=_e,it=et,ot=tt;$=md5ff($,_e,et,tt,_[nt],7,-680876936),tt=md5ff(tt,$,_e,et,_[nt+1],12,-389564586),et=md5ff(et,tt,$,_e,_[nt+2],17,606105819),_e=md5ff(_e,et,tt,$,_[nt+3],22,-1044525330),$=md5ff($,_e,et,tt,_[nt+4],7,-176418897),tt=md5ff(tt,$,_e,et,_[nt+5],12,1200080426),et=md5ff(et,tt,$,_e,_[nt+6],17,-1473231341),_e=md5ff(_e,et,tt,$,_[nt+7],22,-45705983),$=md5ff($,_e,et,tt,_[nt+8],7,1770035416),tt=md5ff(tt,$,_e,et,_[nt+9],12,-1958414417),et=md5ff(et,tt,$,_e,_[nt+10],17,-42063),_e=md5ff(_e,et,tt,$,_[nt+11],22,-1990404162),$=md5ff($,_e,et,tt,_[nt+12],7,1804603682),tt=md5ff(tt,$,_e,et,_[nt+13],12,-40341101),et=md5ff(et,tt,$,_e,_[nt+14],17,-1502002290),_e=md5ff(_e,et,tt,$,_[nt+15],22,1236535329),$=md5gg($,_e,et,tt,_[nt+1],5,-165796510),tt=md5gg(tt,$,_e,et,_[nt+6],9,-1069501632),et=md5gg(et,tt,$,_e,_[nt+11],14,643717713),_e=md5gg(_e,et,tt,$,_[nt],20,-373897302),$=md5gg($,_e,et,tt,_[nt+5],5,-701558691),tt=md5gg(tt,$,_e,et,_[nt+10],9,38016083),et=md5gg(et,tt,$,_e,_[nt+15],14,-660478335),_e=md5gg(_e,et,tt,$,_[nt+4],20,-405537848),$=md5gg($,_e,et,tt,_[nt+9],5,568446438),tt=md5gg(tt,$,_e,et,_[nt+14],9,-1019803690),et=md5gg(et,tt,$,_e,_[nt+3],14,-187363961),_e=md5gg(_e,et,tt,$,_[nt+8],20,1163531501),$=md5gg($,_e,et,tt,_[nt+13],5,-1444681467),tt=md5gg(tt,$,_e,et,_[nt+2],9,-51403784),et=md5gg(et,tt,$,_e,_[nt+7],14,1735328473),_e=md5gg(_e,et,tt,$,_[nt+12],20,-1926607734),$=md5hh($,_e,et,tt,_[nt+5],4,-378558),tt=md5hh(tt,$,_e,et,_[nt+8],11,-2022574463),et=md5hh(et,tt,$,_e,_[nt+11],16,1839030562),_e=md5hh(_e,et,tt,$,_[nt+14],23,-35309556),$=md5hh($,_e,et,tt,_[nt+1],4,-1530992060),tt=md5hh(tt,$,_e,et,_[nt+4],11,1272893353),et=md5hh(et,tt,$,_e,_[nt+7],16,-155497632),_e=md5hh(_e,et,tt,$,_[nt+10],23,-1094730640),$=md5hh($,_e,et,tt,_[nt+13],4,681279174),tt=md5hh(tt,$,_e,et,_[nt],11,-358537222),et=md5hh(et,tt,$,_e,_[nt+3],16,-722521979),_e=md5hh(_e,et,tt,$,_[nt+6],23,76029189),$=md5hh($,_e,et,tt,_[nt+9],4,-640364487),tt=md5hh(tt,$,_e,et,_[nt+12],11,-421815835),et=md5hh(et,tt,$,_e,_[nt+15],16,530742520),_e=md5hh(_e,et,tt,$,_[nt+2],23,-995338651),$=md5ii($,_e,et,tt,_[nt],6,-198630844),tt=md5ii(tt,$,_e,et,_[nt+7],10,1126891415),et=md5ii(et,tt,$,_e,_[nt+14],15,-1416354905),_e=md5ii(_e,et,tt,$,_[nt+5],21,-57434055),$=md5ii($,_e,et,tt,_[nt+12],6,1700485571),tt=md5ii(tt,$,_e,et,_[nt+3],10,-1894986606),et=md5ii(et,tt,$,_e,_[nt+10],15,-1051523),_e=md5ii(_e,et,tt,$,_[nt+1],21,-2054922799),$=md5ii($,_e,et,tt,_[nt+8],6,1873313359),tt=md5ii(tt,$,_e,et,_[nt+15],10,-30611744),et=md5ii(et,tt,$,_e,_[nt+6],15,-1560198380),_e=md5ii(_e,et,tt,$,_[nt+13],21,1309151649),$=md5ii($,_e,et,tt,_[nt+4],6,-145523070),tt=md5ii(tt,$,_e,et,_[nt+11],10,-1120210379),et=md5ii(et,tt,$,_e,_[nt+2],15,718787259),_e=md5ii(_e,et,tt,$,_[nt+9],21,-343485551),$=safeAdd($,rt),_e=safeAdd(_e,at),et=safeAdd(et,it),tt=safeAdd(tt,ot)}return[$,_e,et,tt]}function bytesToWords(_){if(_.length===0)return[];const j=_.length*8,$=new Uint32Array(getOutputLength(j));for(let _e=0;_e<j;_e+=8)$[_e>>5]|=(_[_e/8]&255)<<_e%32;return $}function safeAdd(_,j){const $=(_&65535)+(j&65535);return(_>>16)+(j>>16)+($>>16)<<16|$&65535}function bitRotateLeft(_,j){return _<<j|_>>>32-j}function md5cmn(_,j,$,_e,et,tt){return safeAdd(bitRotateLeft(safeAdd(safeAdd(j,_),safeAdd(_e,tt)),et),$)}function md5ff(_,j,$,_e,et,tt,nt){return md5cmn(j&$|~j&_e,_,j,et,tt,nt)}function md5gg(_,j,$,_e,et,tt,nt){return md5cmn(j&_e|$&~_e,_,j,et,tt,nt)}function md5hh(_,j,$,_e,et,tt,nt){return md5cmn(j^$^_e,_,j,et,tt,nt)}function md5ii(_,j,$,_e,et,tt,nt){return md5cmn($^(j|~_e),_,j,et,tt,nt)}var _default$7=md5;md5$1.default=_default$7;Object.defineProperty(v3$1,"__esModule",{value:!0});v3$1.default=void 0;var _v$1=_interopRequireDefault$3(v35$1),_md=_interopRequireDefault$3(md5$1);function _interopRequireDefault$3(_){return _&&_.__esModule?_:{default:_}}const v3=(0,_v$1.default)("v3",48,_md.default);var _default$6=v3;v3$1.default=_default$6;var v4$1={},native={};Object.defineProperty(native,"__esModule",{value:!0});native.default=void 0;const randomUUID=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var _default$5={randomUUID};native.default=_default$5;Object.defineProperty(v4$1,"__esModule",{value:!0});v4$1.default=void 0;var _native=_interopRequireDefault$2(native),_rng=_interopRequireDefault$2(rng$1),_stringify=stringify$1;function _interopRequireDefault$2(_){return _&&_.__esModule?_:{default:_}}function v4(_,j,$){if(_native.default.randomUUID&&!j&&!_)return _native.default.randomUUID();_=_||{};const _e=_.random||(_.rng||_rng.default)();if(_e[6]=_e[6]&15|64,_e[8]=_e[8]&63|128,j){$=$||0;for(let et=0;et<16;++et)j[$+et]=_e[et];return j}return(0,_stringify.unsafeStringify)(_e)}var _default$4=v4;v4$1.default=_default$4;var v5$1={},sha1$1={};Object.defineProperty(sha1$1,"__esModule",{value:!0});sha1$1.default=void 0;function f(_,j,$,_e){switch(_){case 0:return j&$^~j&_e;case 1:return j^$^_e;case 2:return j&$^j&_e^$&_e;case 3:return j^$^_e}}function ROTL(_,j){return _<<j|_>>>32-j}function sha1(_){const j=[1518500249,1859775393,2400959708,3395469782],$=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof _=="string"){const nt=unescape(encodeURIComponent(_));_=[];for(let rt=0;rt<nt.length;++rt)_.push(nt.charCodeAt(rt))}else Array.isArray(_)||(_=Array.prototype.slice.call(_));_.push(128);const _e=_.length/4+2,et=Math.ceil(_e/16),tt=new Array(et);for(let nt=0;nt<et;++nt){const rt=new Uint32Array(16);for(let at=0;at<16;++at)rt[at]=_[nt*64+at*4]<<24|_[nt*64+at*4+1]<<16|_[nt*64+at*4+2]<<8|_[nt*64+at*4+3];tt[nt]=rt}tt[et-1][14]=(_.length-1)*8/Math.pow(2,32),tt[et-1][14]=Math.floor(tt[et-1][14]),tt[et-1][15]=(_.length-1)*8&4294967295;for(let nt=0;nt<et;++nt){const rt=new Uint32Array(80);for(let pt=0;pt<16;++pt)rt[pt]=tt[nt][pt];for(let pt=16;pt<80;++pt)rt[pt]=ROTL(rt[pt-3]^rt[pt-8]^rt[pt-14]^rt[pt-16],1);let at=$[0],it=$[1],ot=$[2],st=$[3],ct=$[4];for(let pt=0;pt<80;++pt){const dt=Math.floor(pt/20),ft=ROTL(at,5)+f(dt,it,ot,st)+ct+j[dt]+rt[pt]>>>0;ct=st,st=ot,ot=ROTL(it,30)>>>0,it=at,at=ft}$[0]=$[0]+at>>>0,$[1]=$[1]+it>>>0,$[2]=$[2]+ot>>>0,$[3]=$[3]+st>>>0,$[4]=$[4]+ct>>>0}return[$[0]>>24&255,$[0]>>16&255,$[0]>>8&255,$[0]&255,$[1]>>24&255,$[1]>>16&255,$[1]>>8&255,$[1]&255,$[2]>>24&255,$[2]>>16&255,$[2]>>8&255,$[2]&255,$[3]>>24&255,$[3]>>16&255,$[3]>>8&255,$[3]&255,$[4]>>24&255,$[4]>>16&255,$[4]>>8&255,$[4]&255]}var _default$3=sha1;sha1$1.default=_default$3;Object.defineProperty(v5$1,"__esModule",{value:!0});v5$1.default=void 0;var _v=_interopRequireDefault$1(v35$1),_sha=_interopRequireDefault$1(sha1$1);function _interopRequireDefault$1(_){return _&&_.__esModule?_:{default:_}}const v5=(0,_v.default)("v5",80,_sha.default);var _default$2=v5;v5$1.default=_default$2;var nil={};Object.defineProperty(nil,"__esModule",{value:!0});nil.default=void 0;var _default$1="00000000-0000-0000-0000-000000000000";nil.default=_default$1;var version$1={};Object.defineProperty(version$1,"__esModule",{value:!0});version$1.default=void 0;var _validate=_interopRequireDefault(validate$1);function _interopRequireDefault(_){return _&&_.__esModule?_:{default:_}}function version(_){if(!(0,_validate.default)(_))throw TypeError("Invalid UUID");return parseInt(_.slice(14,15),16)}var _default=version;version$1.default=_default;(function(_){Object.defineProperty(_,"__esModule",{value:!0}),Object.defineProperty(_,"NIL",{enumerable:!0,get:function(){return tt.default}}),Object.defineProperty(_,"parse",{enumerable:!0,get:function(){return it.default}}),Object.defineProperty(_,"stringify",{enumerable:!0,get:function(){return at.default}}),Object.defineProperty(_,"v1",{enumerable:!0,get:function(){return j.default}}),Object.defineProperty(_,"v3",{enumerable:!0,get:function(){return $.default}}),Object.defineProperty(_,"v4",{enumerable:!0,get:function(){return _e.default}}),Object.defineProperty(_,"v5",{enumerable:!0,get:function(){return et.default}}),Object.defineProperty(_,"validate",{enumerable:!0,get:function(){return rt.default}}),Object.defineProperty(_,"version",{enumerable:!0,get:function(){return nt.default}});var j=ot(v1$1),$=ot(v3$1),_e=ot(v4$1),et=ot(v5$1),tt=ot(nil),nt=ot(version$1),rt=ot(validate$1),at=ot(stringify$1),it=ot(parse$1);function ot(st){return st&&st.__esModule?st:{default:st}}})(commonjsBrowser);var contextTypes={},__importDefault$d=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(contextTypes,"__esModule",{value:!0});contextTypes.MosaicWindowContext=contextTypes.MosaicContext=void 0;var react_1$c=__importDefault$d(reactExports);contextTypes.MosaicContext=react_1$c.default.createContext(void 0);contextTypes.MosaicWindowContext=react_1$c.default.createContext(void 0);var MosaicRoot$1={},Symbol$2=_Symbol,isArguments$1=isArguments_1,isArray$2=isArray_1,spreadableSymbol=Symbol$2?Symbol$2.isConcatSpreadable:void 0;function isFlattenable$1(_){return isArray$2(_)||isArguments$1(_)||!!(spreadableSymbol&&_&&_[spreadableSymbol])}var _isFlattenable=isFlattenable$1,arrayPush=_arrayPush,isFlattenable=_isFlattenable;function baseFlatten$1(_,j,$,_e,et){var tt=-1,nt=_.length;for($||($=isFlattenable),et||(et=[]);++tt<nt;){var rt=_[tt];j>0&&$(rt)?j>1?baseFlatten$1(rt,j-1,$,_e,et):arrayPush(et,rt):_e||(et[et.length]=rt)}return et}var _baseFlatten=baseFlatten$1,baseFlatten=_baseFlatten;function flatten(_){var j=_==null?0:_.length;return j?baseFlatten(_,1):[]}var flatten_1$1=flatten,Split$1={};function baseClamp$1(_,j,$){return _===_&&($!==void 0&&(_=_<=$?_:$),j!==void 0&&(_=_>=j?_:j)),_}var _baseClamp=baseClamp$1,baseClamp=_baseClamp,toNumber$1=toNumber_1;function clamp(_,j,$){return $===void 0&&($=j,j=void 0),$!==void 0&&($=toNumber$1($),$=$===$?$:0),j!==void 0&&(j=toNumber$1(j),j=j===j?j:0),baseClamp(toNumber$1(_),j,$)}var clamp_1$1=clamp,root=_root,now$1=function(){return root.Date.now()},now_1=now$1,isObject$3=isObject_1,now=now_1,toNumber=toNumber_1,FUNC_ERROR_TEXT$2="Expected a function",nativeMax$1=Math.max,nativeMin=Math.min;function debounce$1(_,j,$){var _e,et,tt,nt,rt,at,it=0,ot=!1,st=!1,ct=!0;if(typeof _!="function")throw new TypeError(FUNC_ERROR_TEXT$2);j=toNumber(j)||0,isObject$3($)&&(ot=!!$.leading,st="maxWait"in $,tt=st?nativeMax$1(toNumber($.maxWait)||0,j):tt,ct="trailing"in $?!!$.trailing:ct);function pt(bt){var mt=_e,_t=et;return _e=et=void 0,it=bt,nt=_.apply(_t,mt),nt}function dt(bt){return it=bt,rt=setTimeout(ut,j),ot?pt(bt):nt}function ft(bt){var mt=bt-at,_t=bt-it,Et=j-mt;return st?nativeMin(Et,tt-_t):Et}function gt(bt){var mt=bt-at,_t=bt-it;return at===void 0||mt>=j||mt<0||st&&_t>=tt}function ut(){var bt=now();if(gt(bt))return lt(bt);rt=setTimeout(ut,ft(bt))}function lt(bt){return rt=void 0,ct&&_e?pt(bt):(_e=et=void 0,nt)}function ht(){rt!==void 0&&clearTimeout(rt),it=0,_e=at=et=rt=void 0}function yt(){return rt===void 0?nt:lt(now())}function vt(){var bt=now(),mt=gt(bt);if(_e=arguments,et=this,at=bt,mt){if(rt===void 0)return dt(at);if(st)return clearTimeout(rt),rt=setTimeout(ut,j),pt(at)}return rt===void 0&&(rt=setTimeout(ut,j)),nt}return vt.cancel=ht,vt.flush=yt,vt}var debounce_1=debounce$1,debounce=debounce_1,isObject$2=isObject_1,FUNC_ERROR_TEXT$1="Expected a function";function throttle(_,j,$){var _e=!0,et=!0;if(typeof _!="function")throw new TypeError(FUNC_ERROR_TEXT$1);return isObject$2($)&&(_e="leading"in $?!!$.leading:_e,et="trailing"in $?!!$.trailing:et),debounce(_,j,{leading:_e,maxWait:j,trailing:et})}var throttle_1$1=throttle,BoundingBox={},assertNever$1={};Object.defineProperty(assertNever$1,"__esModule",{value:!0});assertNever$1.assertNever=void 0;function assertNever(_){throw new Error("Unhandled case: "+JSON.stringify(_))}assertNever$1.assertNever=assertNever;(function(_){var j=commonjsGlobal&&commonjsGlobal.__assign||function(){return j=Object.assign||function(_e){for(var et,tt=1,nt=arguments.length;tt<nt;tt++){et=arguments[tt];for(var rt in et)Object.prototype.hasOwnProperty.call(et,rt)&&(_e[rt]=et[rt])}return _e},j.apply(this,arguments)};Object.defineProperty(_,"__esModule",{value:!0}),_.BoundingBox=void 0;var $=assertNever$1;(function(_e){function et(){return{top:0,right:0,bottom:0,left:0}}_e.empty=et;function tt(it,ot,st){var ct=nt(it,ot,st);return st==="column"?{first:j(j({},it),{bottom:100-ct}),second:j(j({},it),{top:ct})}:st==="row"?{first:j(j({},it),{right:100-ct}),second:j(j({},it),{left:ct})}:(0,$.assertNever)(st)}_e.split=tt;function nt(it,ot,st){var ct=it.top,pt=it.right,dt=it.bottom,ft=it.left;if(st==="column"){var gt=100-ct-dt;return gt*ot/100+ct}else if(st==="row"){var ut=100-pt-ft;return ut*ot/100+ft}else return(0,$.assertNever)(st)}_e.getAbsoluteSplitPercentage=nt;function rt(it,ot,st){var ct=it.top,pt=it.right,dt=it.bottom,ft=it.left;if(st==="column"){var gt=100-ct-dt;return(ot-ct)/gt*100}else if(st==="row"){var ut=100-pt-ft;return(ot-ft)/ut*100}else return(0,$.assertNever)(st)}_e.getRelativeSplitPercentage=rt;function at(it){var ot=it.top,st=it.right,ct=it.bottom,pt=it.left;return{top:"".concat(ot,"%"),right:"".concat(st,"%"),bottom:"".concat(ct,"%"),left:"".concat(pt,"%")}}_e.asStyles=at})(_.BoundingBox||(_.BoundingBox={}))})(BoundingBox);var __extends$9=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__assign$3=commonjsGlobal&&commonjsGlobal.__assign||function(){return __assign$3=Object.assign||function(_){for(var j,$=1,_e=arguments.length;$<_e;$++){j=arguments[$];for(var et in j)Object.prototype.hasOwnProperty.call(j,et)&&(_[et]=j[et])}return _},__assign$3.apply(this,arguments)},__importDefault$c=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(Split$1,"__esModule",{value:!0});Split$1.Split=void 0;var classnames_1$8=__importDefault$c(classnamesExports),clamp_1=__importDefault$c(clamp_1$1),throttle_1=__importDefault$c(throttle_1$1),react_1$b=__importDefault$c(reactExports),BoundingBox_1$1=BoundingBox,RESIZE_THROTTLE_MS=1e3/30,TOUCH_EVENT_OPTIONS={capture:!0,passive:!1},Split=function(_){__extends$9(j,_);function j(){var $=_!==null&&_.apply(this,arguments)||this;return $.rootElement=react_1$b.default.createRef(),$.listenersBound=!1,$.onMouseDown=function(_e){!isTouchEvent(_e)&&_e.button!==0||(_e.preventDefault(),$.bindListeners())},$.onMouseUp=function(_e){$.unbindListeners();var et=$.calculateRelativePercentage(_e);$.props.onRelease(et)},$.onMouseMove=function(_e){_e.preventDefault(),$.throttledUpdatePercentage(_e)},$.throttledUpdatePercentage=(0,throttle_1.default)(function(_e){var et=$.calculateRelativePercentage(_e);et!==$.props.splitPercentage&&$.props.onChange(et)},RESIZE_THROTTLE_MS),$}return j.prototype.render=function(){var $=this.props.direction;return react_1$b.default.createElement("div",{className:(0,classnames_1$8.default)("mosaic-split",{"-row":$==="row","-column":$==="column"}),ref:this.rootElement,onMouseDown:this.onMouseDown,style:this.computeStyle()},react_1$b.default.createElement("div",{className:"mosaic-split-line"}))},j.prototype.componentDidMount=function(){this.rootElement.current.addEventListener("touchstart",this.onMouseDown,TOUCH_EVENT_OPTIONS)},j.prototype.componentWillUnmount=function(){this.unbindListeners(),this.rootElement.current&&this.rootElement.current.ownerDocument.removeEventListener("touchstart",this.onMouseDown,TOUCH_EVENT_OPTIONS)},j.prototype.bindListeners=function(){this.listenersBound||(this.rootElement.current.ownerDocument.addEventListener("mousemove",this.onMouseMove,!0),this.rootElement.current.ownerDocument.addEventListener("touchmove",this.onMouseMove,TOUCH_EVENT_OPTIONS),this.rootElement.current.ownerDocument.addEventListener("mouseup",this.onMouseUp,!0),this.rootElement.current.ownerDocument.addEventListener("touchend",this.onMouseUp,!0),this.listenersBound=!0)},j.prototype.unbindListeners=function(){this.rootElement.current&&(this.rootElement.current.ownerDocument.removeEventListener("mousemove",this.onMouseMove,!0),this.rootElement.current.ownerDocument.removeEventListener("touchmove",this.onMouseMove,TOUCH_EVENT_OPTIONS),this.rootElement.current.ownerDocument.removeEventListener("mouseup",this.onMouseUp,!0),this.rootElement.current.ownerDocument.removeEventListener("touchend",this.onMouseUp,!0),this.listenersBound=!1)},j.prototype.computeStyle=function(){var $,_e=this.props,et=_e.boundingBox,tt=_e.direction,nt=_e.splitPercentage,rt=tt==="column"?"top":"left",at=BoundingBox_1$1.BoundingBox.getAbsoluteSplitPercentage(et,nt,tt);return __assign$3(__assign$3({},BoundingBox_1$1.BoundingBox.asStyles(et)),($={},$[rt]="".concat(at,"%"),$))},j.prototype.calculateRelativePercentage=function($){var _e=this.props,et=_e.minimumPaneSizePercentage,tt=_e.direction,nt=_e.boundingBox,rt=this.rootElement.current.parentElement.getBoundingClientRect(),at=isTouchEvent($)?$.changedTouches[0]:$,it;tt==="column"?it=(at.clientY-rt.top)/rt.height*100:it=(at.clientX-rt.left)/rt.width*100;var ot=BoundingBox_1$1.BoundingBox.getRelativeSplitPercentage(nt,it,tt);return(0,clamp_1.default)(ot,et,100-et)},j.defaultProps={onChange:function(){},onRelease:function(){},minimumPaneSizePercentage:20},j}(react_1$b.default.PureComponent);Split$1.Split=Split;function isTouchEvent(_){return _.changedTouches!=null}var mosaicUtilities={};function arrayEach$1(_,j){for(var $=-1,_e=_==null?0:_.length;++$<_e&&j(_[$],$,_)!==!1;);return _}var _arrayEach=arrayEach$1,assignValue$1=_assignValue,baseAssignValue=_baseAssignValue;function copyObject$4(_,j,$,_e){var et=!$;$||($={});for(var tt=-1,nt=j.length;++tt<nt;){var rt=j[tt],at=_e?_e($[rt],_[rt],rt,$,_):void 0;at===void 0&&(at=_[rt]),et?baseAssignValue($,rt,at):assignValue$1($,rt,at)}return $}var _copyObject=copyObject$4,copyObject$3=_copyObject,keys$2=keys_1;function baseAssign$1(_,j){return _&&copyObject$3(j,keys$2(j),_)}var _baseAssign=baseAssign$1,copyObject$2=_copyObject,keysIn$1=keysIn_1;function baseAssignIn$1(_,j){return _&&copyObject$2(j,keysIn$1(j),_)}var _baseAssignIn=baseAssignIn$1,_cloneBuffer={exports:{}};_cloneBuffer.exports;(function(_,j){var $=_root,_e=j&&!j.nodeType&&j,et=_e&&!0&&_&&!_.nodeType&&_,tt=et&&et.exports===_e,nt=tt?$.Buffer:void 0,rt=nt?nt.allocUnsafe:void 0;function at(it,ot){if(ot)return it.slice();var st=it.length,ct=rt?rt(st):new it.constructor(st);return it.copy(ct),ct}_.exports=at})(_cloneBuffer,_cloneBuffer.exports);var _cloneBufferExports=_cloneBuffer.exports;function copyArray$1(_,j){var $=-1,_e=_.length;for(j||(j=Array(_e));++$<_e;)j[$]=_[$];return j}var _copyArray=copyArray$1,copyObject$1=_copyObject,getSymbols=_getSymbols;function copySymbols$1(_,j){return copyObject$1(_,getSymbols(_),j)}var _copySymbols=copySymbols$1,copyObject=_copyObject,getSymbolsIn=_getSymbolsIn;function copySymbolsIn$1(_,j){return copyObject(_,getSymbolsIn(_),j)}var _copySymbolsIn=copySymbolsIn$1,objectProto$1=Object.prototype,hasOwnProperty$1=objectProto$1.hasOwnProperty;function initCloneArray$1(_){var j=_.length,$=new _.constructor(j);return j&&typeof _[0]=="string"&&hasOwnProperty$1.call(_,"index")&&($.index=_.index,$.input=_.input),$}var _initCloneArray=initCloneArray$1,Uint8Array$1=_Uint8Array;function cloneArrayBuffer$3(_){var j=new _.constructor(_.byteLength);return new Uint8Array$1(j).set(new Uint8Array$1(_)),j}var _cloneArrayBuffer=cloneArrayBuffer$3,cloneArrayBuffer$2=_cloneArrayBuffer;function cloneDataView$1(_,j){var $=j?cloneArrayBuffer$2(_.buffer):_.buffer;return new _.constructor($,_.byteOffset,_.byteLength)}var _cloneDataView=cloneDataView$1,reFlags=/\w*$/;function cloneRegExp$1(_){var j=new _.constructor(_.source,reFlags.exec(_));return j.lastIndex=_.lastIndex,j}var _cloneRegExp=cloneRegExp$1,Symbol$1=_Symbol,symbolProto=Symbol$1?Symbol$1.prototype:void 0,symbolValueOf=symbolProto?symbolProto.valueOf:void 0;function cloneSymbol$1(_){return symbolValueOf?Object(symbolValueOf.call(_)):{}}var _cloneSymbol=cloneSymbol$1,cloneArrayBuffer$1=_cloneArrayBuffer;function cloneTypedArray$1(_,j){var $=j?cloneArrayBuffer$1(_.buffer):_.buffer;return new _.constructor($,_.byteOffset,_.length)}var _cloneTypedArray=cloneTypedArray$1,cloneArrayBuffer=_cloneArrayBuffer,cloneDataView=_cloneDataView,cloneRegExp=_cloneRegExp,cloneSymbol=_cloneSymbol,cloneTypedArray=_cloneTypedArray,boolTag$1="[object Boolean]",dateTag$1="[object Date]",mapTag$3="[object Map]",numberTag$1="[object Number]",regexpTag$1="[object RegExp]",setTag$3="[object Set]",stringTag$1="[object String]",symbolTag$1="[object Symbol]",arrayBufferTag$1="[object ArrayBuffer]",dataViewTag$1="[object DataView]",float32Tag$1="[object Float32Array]",float64Tag$1="[object Float64Array]",int8Tag$1="[object Int8Array]",int16Tag$1="[object Int16Array]",int32Tag$1="[object Int32Array]",uint8Tag$1="[object Uint8Array]",uint8ClampedTag$1="[object Uint8ClampedArray]",uint16Tag$1="[object Uint16Array]",uint32Tag$1="[object Uint32Array]";function initCloneByTag$1(_,j,$){var _e=_.constructor;switch(j){case arrayBufferTag$1:return cloneArrayBuffer(_);case boolTag$1:case dateTag$1:return new _e(+_);case dataViewTag$1:return cloneDataView(_,$);case float32Tag$1:case float64Tag$1:case int8Tag$1:case int16Tag$1:case int32Tag$1:case uint8Tag$1:case uint8ClampedTag$1:case uint16Tag$1:case uint32Tag$1:return cloneTypedArray(_,$);case mapTag$3:return new _e;case numberTag$1:case stringTag$1:return new _e(_);case regexpTag$1:return cloneRegExp(_);case setTag$3:return new _e;case symbolTag$1:return cloneSymbol(_)}}var _initCloneByTag=initCloneByTag$1,isObject$1=isObject_1,objectCreate=Object.create,baseCreate$1=function(){function _(){}return function(j){if(!isObject$1(j))return{};if(objectCreate)return objectCreate(j);_.prototype=j;var $=new _;return _.prototype=void 0,$}}(),_baseCreate=baseCreate$1,baseCreate=_baseCreate,getPrototype=_getPrototype,isPrototype$1=_isPrototype;function initCloneObject$1(_){return typeof _.constructor=="function"&&!isPrototype$1(_)?baseCreate(getPrototype(_)):{}}var _initCloneObject=initCloneObject$1,getTag$3=_getTag,isObjectLike$1=isObjectLike_1,mapTag$2="[object Map]";function baseIsMap$1(_){return isObjectLike$1(_)&&getTag$3(_)==mapTag$2}var _baseIsMap=baseIsMap$1,baseIsMap=_baseIsMap,baseUnary$1=_baseUnary,nodeUtil$1=_nodeUtilExports,nodeIsMap=nodeUtil$1&&nodeUtil$1.isMap,isMap$1=nodeIsMap?baseUnary$1(nodeIsMap):baseIsMap,isMap_1=isMap$1,getTag$2=_getTag,isObjectLike=isObjectLike_1,setTag$2="[object Set]";function baseIsSet$1(_){return isObjectLike(_)&&getTag$2(_)==setTag$2}var _baseIsSet=baseIsSet$1,baseIsSet=_baseIsSet,baseUnary=_baseUnary,nodeUtil=_nodeUtilExports,nodeIsSet=nodeUtil&&nodeUtil.isSet,isSet$1=nodeIsSet?baseUnary(nodeIsSet):baseIsSet,isSet_1=isSet$1,Stack=_Stack,arrayEach=_arrayEach,assignValue=_assignValue,baseAssign=_baseAssign,baseAssignIn=_baseAssignIn,cloneBuffer=_cloneBufferExports,copyArray=_copyArray,copySymbols=_copySymbols,copySymbolsIn=_copySymbolsIn,getAllKeys=_getAllKeys,getAllKeysIn=_getAllKeysIn,getTag$1=_getTag,initCloneArray=_initCloneArray,initCloneByTag=_initCloneByTag,initCloneObject=_initCloneObject,isArray$1=isArray_1,isBuffer$1=isBufferExports,isMap=isMap_1,isObject=isObject_1,isSet=isSet_1,keys$1=keys_1,keysIn=keysIn_1,CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG$1=4,argsTag="[object Arguments]",arrayTag="[object Array]",boolTag="[object Boolean]",dateTag="[object Date]",errorTag="[object Error]",funcTag="[object Function]",genTag="[object GeneratorFunction]",mapTag$1="[object Map]",numberTag="[object Number]",objectTag="[object Object]",regexpTag="[object RegExp]",setTag$1="[object Set]",stringTag="[object String]",symbolTag="[object Symbol]",weakMapTag="[object WeakMap]",arrayBufferTag="[object ArrayBuffer]",dataViewTag="[object DataView]",float32Tag="[object Float32Array]",float64Tag="[object Float64Array]",int8Tag="[object Int8Array]",int16Tag="[object Int16Array]",int32Tag="[object Int32Array]",uint8Tag="[object Uint8Array]",uint8ClampedTag="[object Uint8ClampedArray]",uint16Tag="[object Uint16Array]",uint32Tag="[object Uint32Array]",cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag$1]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag$1]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=!0;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=!1;function baseClone$1(_,j,$,_e,et,tt){var nt,rt=j&CLONE_DEEP_FLAG,at=j&CLONE_FLAT_FLAG,it=j&CLONE_SYMBOLS_FLAG$1;if($&&(nt=et?$(_,_e,et,tt):$(_)),nt!==void 0)return nt;if(!isObject(_))return _;var ot=isArray$1(_);if(ot){if(nt=initCloneArray(_),!rt)return copyArray(_,nt)}else{var st=getTag$1(_),ct=st==funcTag||st==genTag;if(isBuffer$1(_))return cloneBuffer(_,rt);if(st==objectTag||st==argsTag||ct&&!et){if(nt=at||ct?{}:initCloneObject(_),!rt)return at?copySymbolsIn(_,baseAssignIn(nt,_)):copySymbols(_,baseAssign(nt,_))}else{if(!cloneableTags[st])return et?_:{};nt=initCloneByTag(_,st,rt)}}tt||(tt=new Stack);var pt=tt.get(_);if(pt)return pt;tt.set(_,nt),isSet(_)?_.forEach(function(gt){nt.add(baseClone$1(gt,j,$,gt,_,tt))}):isMap(_)&&_.forEach(function(gt,ut){nt.set(ut,baseClone$1(gt,j,$,ut,_,tt))});var dt=it?at?getAllKeysIn:getAllKeys:at?keysIn:keys$1,ft=ot?void 0:dt(_);return arrayEach(ft||_,function(gt,ut){ft&&(ut=gt,gt=_[ut]),assignValue(nt,ut,baseClone$1(gt,j,$,ut,_,tt))}),nt}var _baseClone=baseClone$1,baseClone=_baseClone,CLONE_SYMBOLS_FLAG=4;function clone(_){return baseClone(_,CLONE_SYMBOLS_FLAG)}var clone_1=clone;(function(_){var j=commonjsGlobal&&commonjsGlobal.__importDefault||function(dt){return dt&&dt.__esModule?dt:{default:dt}};Object.defineProperty(_,"__esModule",{value:!0}),_.getAndAssertNodeAtPathExists=_.getNodeAtPath=_.getLeaves=_.getPathToCorner=_.getOtherDirection=_.getOtherBranch=_.createBalancedTreeFromLeaves=_.isParent=_.Corner=void 0;var $=j(clone_1),_e=j(get_1);function et(dt,ft){if(ft===void 0&&(ft="row"),nt(dt)){var gt=it(ft);return{direction:ft,first:et(dt.first,gt),second:et(dt.second,gt)}}else return dt}var tt;(function(dt){dt[dt.TOP_LEFT=1]="TOP_LEFT",dt[dt.TOP_RIGHT=2]="TOP_RIGHT",dt[dt.BOTTOM_LEFT=3]="BOTTOM_LEFT",dt[dt.BOTTOM_RIGHT=4]="BOTTOM_RIGHT"})(tt=_.Corner||(_.Corner={}));function nt(dt){return dt.direction!=null}_.isParent=nt;function rt(dt,ft){if(ft===void 0&&(ft="row"),dt.length===0)return null;for(var gt=(0,$.default)(dt),ut=[];gt.length>1;){for(;gt.length>0;)gt.length>1?ut.push({direction:"row",first:gt.shift(),second:gt.shift()}):ut.unshift(gt.shift());gt=ut,ut=[]}return et(gt[0],ft)}_.createBalancedTreeFromLeaves=rt;function at(dt){if(dt==="first")return"second";if(dt==="second")return"first";throw new Error("Branch '".concat(dt,"' not a valid branch"))}_.getOtherBranch=at;function it(dt){return dt==="row"?"column":"row"}_.getOtherDirection=it;function ot(dt,ft){for(var gt=dt,ut=[];nt(gt);)gt.direction==="row"&&(ft===tt.TOP_LEFT||ft===tt.BOTTOM_LEFT)||gt.direction==="column"&&(ft===tt.TOP_LEFT||ft===tt.TOP_RIGHT)?(ut.push("first"),gt=gt.first):(ut.push("second"),gt=gt.second);return ut}_.getPathToCorner=ot;function st(dt){return dt==null?[]:nt(dt)?st(dt.first).concat(st(dt.second)):[dt]}_.getLeaves=st;function ct(dt,ft){return ft.length>0?(0,_e.default)(dt,ft,null):dt}_.getNodeAtPath=ct;function pt(dt,ft){if(dt==null)throw new Error("Root is empty, cannot fetch path");var gt=ct(dt,ft);if(gt==null)throw new Error("Path [".concat(ft.join(", "),"] did not resolve to a node"));return gt}_.getAndAssertNodeAtPathExists=pt})(mosaicUtilities);var __extends$8=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__assign$2=commonjsGlobal&&commonjsGlobal.__assign||function(){return __assign$2=Object.assign||function(_){for(var j,$=1,_e=arguments.length;$<_e;$++){j=arguments[$];for(var et in j)Object.prototype.hasOwnProperty.call(j,et)&&(_[et]=j[et])}return _},__assign$2.apply(this,arguments)},__importDefault$b=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(MosaicRoot$1,"__esModule",{value:!0});MosaicRoot$1.MosaicRoot=void 0;var flatten_1=__importDefault$b(flatten_1$1),react_1$a=__importDefault$b(reactExports),contextTypes_1$8=contextTypes,Split_1=Split$1,BoundingBox_1=BoundingBox,mosaicUtilities_1$2=mosaicUtilities,MosaicRoot=function(_){__extends$8(j,_);function j(){var $=_!==null&&_.apply(this,arguments)||this;return $.onResize=function(_e,et,tt){$.context.mosaicActions.updateTree([{path:et,spec:{splitPercentage:{$set:_e}}}],tt)},$}return j.prototype.render=function(){var $=this.props.root;return react_1$a.default.createElement("div",{className:"mosaic-root"},this.renderRecursively($,BoundingBox_1.BoundingBox.empty(),[]))},j.prototype.renderRecursively=function($,_e,et){if((0,mosaicUtilities_1$2.isParent)($)){var tt=$.splitPercentage==null?50:$.splitPercentage,nt=BoundingBox_1.BoundingBox.split(_e,tt,$.direction),rt=nt.first,at=nt.second;return(0,flatten_1.default)([this.renderRecursively($.first,rt,et.concat("first")),this.renderSplit($.direction,_e,tt,et),this.renderRecursively($.second,at,et.concat("second"))].filter(nonNullElement))}else return react_1$a.default.createElement("div",{key:$,className:"mosaic-tile",style:__assign$2({},BoundingBox_1.BoundingBox.asStyles(_e))},this.props.renderTile($,et))},j.prototype.renderSplit=function($,_e,et,tt){var nt=this,rt=this.props.resize;return rt!=="DISABLED"?react_1$a.default.createElement(Split_1.Split,__assign$2({key:tt.join(",")+"splitter"},rt,{boundingBox:_e,splitPercentage:et,direction:$,onChange:function(at){return nt.onResize(at,tt,!0)},onRelease:function(at){return nt.onResize(at,tt,!1)}})):null},j.contextType=contextTypes_1$8.MosaicContext,j}(react_1$a.default.PureComponent);MosaicRoot$1.MosaicRoot=MosaicRoot;function nonNullElement(_){return _!==null}var MosaicZeroState$1={};function noop(){}var noop_1$3=noop,OptionalBlueprint={};function arrayReduce$1(_,j,$,_e){var et=-1,tt=_==null?0:_.length;for(_e&&tt&&($=_[++et]);++et<tt;)$=j($,_[et],et,_);return $}var _arrayReduce=arrayReduce$1;function basePropertyOf$1(_){return function(j){return _==null?void 0:_[j]}}var _basePropertyOf=basePropertyOf$1,basePropertyOf=_basePropertyOf,deburredLetters={:"A",:"A",:"A",:"A",:"A",:"A",:"a",:"a",:"a",:"a",:"a",:"a",:"C",:"c",:"D",:"d",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"N",:"n",:"O",:"O",:"O",:"O",:"O",:"O",:"o",:"o",:"o",:"o",:"o",:"o",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"Y",:"y",:"y",:"Ae",:"ae",:"Th",:"th",:"ss",:"A",:"A",:"A",:"a",:"a",:"a",:"C",:"C",:"C",:"C",:"c",:"c",:"c",:"c",:"D",:"D",:"d",:"d",:"E",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"e",:"G",:"G",:"G",:"G",:"g",:"g",:"g",:"g",:"H",:"H",:"h",:"h",:"I",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"i",:"J",:"j",:"K",:"k",:"k",:"L",:"L",:"L",:"L",:"L",:"l",:"l",:"l",:"l",:"l",:"N",:"N",:"N",:"N",:"n",:"n",:"n",:"n",:"O",:"O",:"O",:"o",:"o",:"o",:"R",:"R",:"R",:"r",:"r",:"r",:"S",:"S",:"S",:"S",:"s",:"s",:"s",:"s",:"T",:"T",:"T",:"t",:"t",:"t",:"U",:"U",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"u",:"u",:"W",:"w",:"Y",:"y",:"Y",:"Z",:"Z",:"Z",:"z",:"z",:"z",:"IJ",:"ij",:"Oe",:"oe",:"'n",:"s"},deburrLetter$1=basePropertyOf(deburredLetters),_deburrLetter=deburrLetter$1,deburrLetter=_deburrLetter,toString$1=toString_1,reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,rsComboMarksRange$1="\\u0300-\\u036f",reComboHalfMarksRange$1="\\ufe20-\\ufe2f",rsComboSymbolsRange$1="\\u20d0-\\u20ff",rsComboRange$1=rsComboMarksRange$1+reComboHalfMarksRange$1+rsComboSymbolsRange$1,rsCombo$1="["+rsComboRange$1+"]",reComboMark=RegExp(rsCombo$1,"g");function deburr$1(_){return _=toString$1(_),_&&_.replace(reLatin,deburrLetter).replace(reComboMark,"")}var deburr_1=deburr$1,reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;function asciiWords$1(_){return _.match(reAsciiWord)||[]}var _asciiWords=asciiWords$1,reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;function hasUnicodeWord$1(_){return reHasUnicodeWord.test(_)}var _hasUnicodeWord=hasUnicodeWord$1,rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange="a-z\\xdf-\\xf6\\xf8-\\xff",rsMathOpRange="\\xac\\xb1\\xd7\\xf7",rsNonCharRange="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange="A-Z\\xc0-\\xd6\\xd8-\\xde",rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange,rsApos$1="[']",rsBreak="["+rsBreakRange+"]",rsCombo="["+rsComboRange+"]",rsDigits="\\d+",rsDingbat="["+rsDingbatRange+"]",rsLower="["+rsLowerRange+"]",rsMisc="[^"+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+"]",rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier="(?:"+rsCombo+"|"+rsFitz+")",rsNonAstral="[^"+rsAstralRange+"]",rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper="["+rsUpperRange+"]",rsZWJ="\\u200d",rsMiscLower="(?:"+rsLower+"|"+rsMisc+")",rsMiscUpper="(?:"+rsUpper+"|"+rsMisc+")",rsOptContrLower="(?:"+rsApos$1+"(?:d|ll|m|re|s|t|ve))?",rsOptContrUpper="(?:"+rsApos$1+"(?:D|LL|M|RE|S|T|VE))?",reOptMod=rsModifier+"?",rsOptVar="["+rsVarRange+"]?",rsOptJoin="(?:"+rsZWJ+"(?:"+[rsNonAstral,rsRegional,rsSurrPair].join("|")+")"+rsOptVar+reOptMod+")*",rsOrdLower="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",rsOrdUpper="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji="(?:"+[rsDingbat,rsRegional,rsSurrPair].join("|")+")"+rsSeq,reUnicodeWord=RegExp([rsUpper+"?"+rsLower+"+"+rsOptContrLower+"(?="+[rsBreak,rsUpper,"$"].join("|")+")",rsMiscUpper+"+"+rsOptContrUpper+"(?="+[rsBreak,rsUpper+rsMiscLower,"$"].join("|")+")",rsUpper+"?"+rsMiscLower+"+"+rsOptContrLower,rsUpper+"+"+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join("|"),"g");function unicodeWords$1(_){return _.match(reUnicodeWord)||[]}var _unicodeWords=unicodeWords$1,asciiWords=_asciiWords,hasUnicodeWord=_hasUnicodeWord,toString=toString_1,unicodeWords=_unicodeWords;function words$1(_,j,$){return _=toString(_),j=$?void 0:j,j===void 0?hasUnicodeWord(_)?unicodeWords(_):asciiWords(_):_.match(j)||[]}var words_1=words$1,arrayReduce=_arrayReduce,deburr=deburr_1,words=words_1,rsApos="[']",reApos=RegExp(rsApos,"g");function createCompounder$1(_){return function(j){return arrayReduce(words(deburr(j).replace(reApos,"")),_,"")}}var _createCompounder=createCompounder$1,createCompounder=_createCompounder,kebabCase=createCompounder(function(_,j,$){return _+($?"-":"")+j.toLowerCase()}),kebabCase_1=kebabCase;(function(_){var j=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(it,ot,st,ct){ct===void 0&&(ct=st);var pt=Object.getOwnPropertyDescriptor(ot,st);(!pt||("get"in pt?!ot.__esModule:pt.writable||pt.configurable))&&(pt={enumerable:!0,get:function(){return ot[st]}}),Object.defineProperty(it,ct,pt)}:function(it,ot,st,ct){ct===void 0&&(ct=st),it[ct]=ot[st]}),$=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(it,ot){Object.defineProperty(it,"default",{enumerable:!0,value:ot})}:function(it,ot){it.default=ot}),_e=commonjsGlobal&&commonjsGlobal.__importStar||function(it){if(it&&it.__esModule)return it;var ot={};if(it!=null)for(var st in it)st!=="default"&&Object.prototype.hasOwnProperty.call(it,st)&&j(ot,it,st);return $(ot,it),ot},et=commonjsGlobal&&commonjsGlobal.__importDefault||function(it){return it&&it.__esModule?it:{default:it}};Object.defineProperty(_,"__esModule",{value:!0}),_.OptionalBlueprint=void 0;var tt=et(classnamesExports),nt=et(kebabCase_1),rt=_e(reactExports),at=contextTypes;(function(it){it.Icon=function(ct){var pt=ct.icon,dt=ct.className,ft=ct.size,gt=ft===void 0?"standard":ft,ut=rt.useContext(at.MosaicContext).blueprintNamespace;return rt.createElement("span",{className:(0,tt.default)(dt,st(ut,pt),"".concat(ut,"-icon-").concat(gt))})};function ot(ct){for(var pt=[],dt=1;dt<arguments.length;dt++)pt[dt-1]=arguments[dt];return pt.map(function(ft){return"".concat(ct,"-").concat((0,nt.default)(ft))}).join(" ")}it.getClasses=ot;function st(ct,pt){return"".concat(ct,"-icon-").concat((0,nt.default)(pt))}it.getIconClass=st})(_.OptionalBlueprint||(_.OptionalBlueprint={}))})(OptionalBlueprint);var __extends$7=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__importDefault$a=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(MosaicZeroState$1,"__esModule",{value:!0});MosaicZeroState$1.MosaicZeroState=void 0;var classnames_1$7=__importDefault$a(classnamesExports),noop_1$2=__importDefault$a(noop_1$3),react_1$9=__importDefault$a(reactExports),contextTypes_1$7=contextTypes,OptionalBlueprint_1$5=OptionalBlueprint,MosaicZeroState=function(_){__extends$7(j,_);function j(){var $=_!==null&&_.apply(this,arguments)||this;return $.replace=function(){return Promise.resolve($.props.createNode()).then(function(_e){return $.context.mosaicActions.replaceWith([],_e)}).catch(noop_1$2.default)},$}return j.prototype.render=function(){return react_1$9.default.createElement("div",{className:(0,classnames_1$7.default)("mosaic-zero-state",OptionalBlueprint_1$5.OptionalBlueprint.getClasses(this.context.blueprintNamespace,"NON_IDEAL_STATE"))},react_1$9.default.createElement("div",{className:OptionalBlueprint_1$5.OptionalBlueprint.getClasses(this.context.blueprintNamespace,"NON_IDEAL_STATE_VISUAL")},react_1$9.default.createElement(OptionalBlueprint_1$5.OptionalBlueprint.Icon,{className:"default-zero-state-icon",size:"large",icon:"APPLICATIONS"})),react_1$9.default.createElement("h4",{className:OptionalBlueprint_1$5.OptionalBlueprint.getClasses(this.context.blueprintNamespace,"HEADING")},"No Windows Present"),react_1$9.default.createElement("div",null,this.props.createNode&&react_1$9.default.createElement("button",{className:(0,classnames_1$7.default)(OptionalBlueprint_1$5.OptionalBlueprint.getClasses(this.context.blueprintNamespace,"BUTTON"),OptionalBlueprint_1$5.OptionalBlueprint.getIconClass(this.context.blueprintNamespace,"ADD")),onClick:this.replace},"Add New Window")))},j.contextType=contextTypes_1$7.MosaicContext,j}(react_1$9.default.PureComponent);MosaicZeroState$1.MosaicZeroState=MosaicZeroState;var RootDropTargets={},arrayMap=_arrayMap;function baseValues$1(_,j){return arrayMap(j,function($){return _[$]})}var _baseValues=baseValues$1,baseValues=_baseValues,keys=keys_1;function values(_){return _==null?[]:baseValues(_,keys(_))}var values_1$1=values,internalTypes={};Object.defineProperty(internalTypes,"__esModule",{value:!0});internalTypes.MosaicDropTargetPosition=void 0;internalTypes.MosaicDropTargetPosition={TOP:"top",BOTTOM:"bottom",LEFT:"left",RIGHT:"right"};var MosaicDropTarget$1={},types={};Object.defineProperty(types,"__esModule",{value:!0});types.MosaicDragType=void 0;types.MosaicDragType={WINDOW:"MosaicWindow"};var __createBinding$1=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(_,j,$,_e){_e===void 0&&(_e=$);var et=Object.getOwnPropertyDescriptor(j,$);(!et||("get"in et?!j.__esModule:et.writable||et.configurable))&&(et={enumerable:!0,get:function(){return j[$]}}),Object.defineProperty(_,_e,et)}:function(_,j,$,_e){_e===void 0&&(_e=$),_[_e]=j[$]}),__setModuleDefault$1=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(_,j){Object.defineProperty(_,"default",{enumerable:!0,value:j})}:function(_,j){_.default=j}),__importStar$1=commonjsGlobal&&commonjsGlobal.__importStar||function(_){if(_&&_.__esModule)return _;var j={};if(_!=null)for(var $ in _)$!=="default"&&Object.prototype.hasOwnProperty.call(_,$)&&__createBinding$1(j,_,$);return __setModuleDefault$1(j,_),j},__importDefault$9=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(MosaicDropTarget$1,"__esModule",{value:!0});MosaicDropTarget$1.MosaicDropTarget=void 0;var classnames_1$6=__importDefault$9(classnamesExports),react_1$8=__importStar$1(reactExports),react_dnd_1$2=require$$7$1,contextTypes_1$6=contextTypes,types_1$1=types;function MosaicDropTarget(_){var j=_.path,$=_.position,_e=(0,react_1$8.useContext)(contextTypes_1$6.MosaicContext).mosaicId,et=(0,react_dnd_1$2.useDrop)({accept:types_1$1.MosaicDragType.WINDOW,drop:function(it,ot){return _e===(it==null?void 0:it.mosaicId)?{path:j,position:$}:{}},collect:function(it){return{isOver:it.isOver(),draggedMosaicId:(it.getItem()||{}).mosaicId}}}),tt=et[0],nt=tt.isOver,rt=tt.draggedMosaicId,at=et[1];return react_1$8.default.createElement("div",{ref:at,className:(0,classnames_1$6.default)("drop-target",$,{"drop-target-hover":nt&&rt===_e})})}MosaicDropTarget$1.MosaicDropTarget=MosaicDropTarget;(function(_){var j=commonjsGlobal&&commonjsGlobal.__importDefault||function(ot){return ot&&ot.__esModule?ot:{default:ot}};Object.defineProperty(_,"__esModule",{value:!0}),_.RootDropTargets=void 0;var $=j(classnamesExports),_e=j(values_1$1),et=j(reactExports),tt=require$$7$1,nt=internalTypes,rt=MosaicDropTarget$1,at=types;_.RootDropTargets=et.default.memo(function(){var ot=(0,tt.useDrop)({accept:at.MosaicDragType.WINDOW,collect:function(ct){return{isDragging:ct.getItem()!==null&&ct.getItemType()===at.MosaicDragType.WINDOW}}})[0].isDragging,st=it(ot,0);return et.default.createElement("div",{className:(0,$.default)("drop-target-container",{"-dragging":st})},(0,_e.default)(nt.MosaicDropTargetPosition).map(function(ct){return et.default.createElement(rt.MosaicDropTarget,{position:ct,path:[],key:ct})}))}),_.RootDropTargets.displayName="RootDropTargets";function it(ot,st){var ct=et.default.useRef(ot),pt=et.default.useState(0),dt=pt[1],ft=function(gt){ct.current=gt,dt(function(ut){return ut+1})};return ot||(ct.current=!1),et.default.useEffect(function(){if(!(ct.current===ot||!ot)){var gt=window.setTimeout(function(){return ft(!0)},st);return function(){window.clearTimeout(gt)}}},[ot]),ct.current}})(RootDropTargets);var mosaicUpdates={},immutabilityHelper={exports:{}};(function(_,j){Object.defineProperty(j,"__esModule",{value:!0});function $(mt){return typeof mt=="object"&&!("toString"in mt)?Object.prototype.toString.call(mt).slice(8,-1):mt}var _e=typeof process=="object"&&!0;function et(mt,_t){if(!mt)throw _e?new Error("Invariant failed"):new Error(_t())}j.invariant=et;var tt=Object.prototype.hasOwnProperty,nt=Array.prototype.splice,rt=Object.prototype.toString;function at(mt){return rt.call(mt).slice(8,-1)}var it=Object.assign||function(mt,_t){return ot(_t).forEach(function(Et){tt.call(_t,Et)&&(mt[Et]=_t[Et])}),mt},ot=typeof Object.getOwnPropertySymbols=="function"?function(mt){return Object.keys(mt).concat(Object.getOwnPropertySymbols(mt))}:function(mt){return Object.keys(mt)};function st(mt){return Array.isArray(mt)?it(mt.constructor(mt.length),mt):at(mt)==="Map"?new Map(mt):at(mt)==="Set"?new Set(mt):mt&&typeof mt=="object"?it(Object.create(Object.getPrototypeOf(mt)),mt):mt}var ct=function(){function mt(){this.commands=it({},pt),this.update=this.update.bind(this),this.update.extend=this.extend=this.extend.bind(this),this.update.isEquals=function(_t,Et){return _t===Et},this.update.newContext=function(){return new mt().update}}return Object.defineProperty(mt.prototype,"isEquals",{get:function(){return this.update.isEquals},set:function(_t){this.update.isEquals=_t},enumerable:!0,configurable:!0}),mt.prototype.extend=function(_t,Et){this.commands[_t]=Et},mt.prototype.update=function(_t,Et){var wt=this,St=typeof Et=="function"?{$apply:Et}:Et;Array.isArray(_t)&&Array.isArray(St)||et(!Array.isArray(St),function(){return"update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value."}),et(typeof St=="object"&&St!==null,function(){return"update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the "+("following commands: "+Object.keys(wt.commands).join(", ")+".")});var Tt=_t;return ot(St).forEach(function(At){if(tt.call(wt.commands,At)){var Ht=_t===Tt;Tt=wt.commands[At](St[At],Tt,St,_t),Ht&&wt.isEquals(Tt,_t)&&(Tt=_t)}else{var Rt=at(_t)==="Map"?wt.update(_t.get(At),St[At]):wt.update(_t[At],St[At]),Ft=at(Tt)==="Map"?Tt.get(At):Tt[At];(!wt.isEquals(Rt,Ft)||typeof Rt>"u"&&!tt.call(_t,At))&&(Tt===_t&&(Tt=st(_t)),at(Tt)==="Map"?Tt.set(At,Rt):Tt[At]=Rt)}}),Tt},mt}();j.Context=ct;var pt={$push:function(mt,_t,Et){return ft(_t,Et,"$push"),mt.length?_t.concat(mt):_t},$unshift:function(mt,_t,Et){return ft(_t,Et,"$unshift"),mt.length?mt.concat(_t):_t},$splice:function(mt,_t,Et,wt){return ut(_t,Et),mt.forEach(function(St){lt(St),_t===wt&&St.length&&(_t=st(wt)),nt.apply(_t,St)}),_t},$set:function(mt,_t,Et){return yt(Et),mt},$toggle:function(mt,_t){gt(mt,"$toggle");var Et=mt.length?st(_t):_t;return mt.forEach(function(wt){Et[wt]=!_t[wt]}),Et},$unset:function(mt,_t,Et,wt){return gt(mt,"$unset"),mt.forEach(function(St){Object.hasOwnProperty.call(_t,St)&&(_t===wt&&(_t=st(wt)),delete _t[St])}),_t},$add:function(mt,_t,Et,wt){return bt(_t,"$add"),gt(mt,"$add"),at(_t)==="Map"?mt.forEach(function(St){var Tt=St[0],At=St[1];_t===wt&&_t.get(Tt)!==At&&(_t=st(wt)),_t.set(Tt,At)}):mt.forEach(function(St){_t===wt&&!_t.has(St)&&(_t=st(wt)),_t.add(St)}),_t},$remove:function(mt,_t,Et,wt){return bt(_t,"$remove"),gt(mt,"$remove"),mt.forEach(function(St){_t===wt&&_t.has(St)&&(_t=st(wt)),_t.delete(St)}),_t},$merge:function(mt,_t,Et,wt){return vt(_t,mt),ot(mt).forEach(function(St){mt[St]!==_t[St]&&(_t===wt&&(_t=st(wt)),_t[St]=mt[St])}),_t},$apply:function(mt,_t){return ht(mt),mt(_t)}},dt=new ct;j.isEquals=dt.update.isEquals,j.extend=dt.extend,j.default=dt.update,j.default.default=_.exports=it(j.default,j);function ft(mt,_t,Et){et(Array.isArray(mt),function(){return"update(): expected target of "+$(Et)+" to be an array; got "+$(mt)+"."}),gt(_t[Et],Et)}function gt(mt,_t){et(Array.isArray(mt),function(){return"update(): expected spec of "+$(_t)+" to be an array; got "+$(mt)+". Did you forget to wrap your parameter in an array?"})}function ut(mt,_t){et(Array.isArray(mt),function(){return"Expected $splice target to be an array; got "+$(mt)}),lt(_t.$splice)}function lt(mt){et(Array.isArray(mt),function(){return"update(): expected spec of $splice to be an array of arrays; got "+$(mt)+". Did you forget to wrap your parameters in an array?"})}function ht(mt){et(typeof mt=="function",function(){return"update(): expected spec of $apply to be a function; got "+$(mt)+"."})}function yt(mt){et(Object.keys(mt).length===1,function(){return"Cannot have more than one key in an object with $set"})}function vt(mt,_t){et(_t&&typeof _t=="object",function(){return"update(): $merge expects a spec of type 'object'; got "+$(_t)}),et(mt&&typeof mt=="object",function(){return"update(): $merge expects a target of type 'object'; got "+$(mt)})}function bt(mt,_t){var Et=at(mt);et(Et==="Map"||Et==="Set",function(){return"update(): "+$(_t)+" expects a target of type Set or Map; got "+$(Et)})}})(immutabilityHelper,immutabilityHelper.exports);var immutabilityHelperExports=immutabilityHelper.exports,baseSlice$1=_baseSlice,toInteger$1=toInteger_1;function drop(_,j,$){var _e=_==null?0:_.length;return _e?(j=$||j===void 0?1:toInteger$1(j),baseSlice$1(_,j<0?0:j,_e)):[]}var drop_1$1=drop,baseIsEqual=_baseIsEqual;function isEqual(_,j){return baseIsEqual(_,j)}var isEqual_1$2=isEqual;function last(_){var j=_==null?0:_.length;return j?_[j-1]:void 0}var last_1$1=last,baseSet=_baseSet;function set(_,j,$){return _==null?_:baseSet(_,j,$)}var set_1$1=set,baseSlice=_baseSlice,toInteger=toInteger_1;function take(_,j,$){return _&&_.length?(j=$||j===void 0?1:toInteger(j),baseSlice(_,0,j<0?0:j)):[]}var take_1$1=take,__importDefault$8=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(mosaicUpdates,"__esModule",{value:!0});mosaicUpdates.createExpandUpdate=mosaicUpdates.createHideUpdate=mosaicUpdates.createDragToUpdates=mosaicUpdates.createRemoveUpdate=mosaicUpdates.updateTree=mosaicUpdates.buildSpecFromUpdate=void 0;var immutability_helper_1=__importDefault$8(immutabilityHelperExports),drop_1=__importDefault$8(drop_1$1),dropRight_1$1=__importDefault$8(dropRight_1$2),isEqual_1$1=__importDefault$8(isEqual_1$2),last_1=__importDefault$8(last_1$1),set_1=__importDefault$8(set_1$1),take_1=__importDefault$8(take_1$1),internalTypes_1$1=internalTypes,mosaicUtilities_1$1=mosaicUtilities;function buildSpecFromUpdate(_){return _.path.length>0?(0,set_1.default)({},_.path,_.spec):_.spec}mosaicUpdates.buildSpecFromUpdate=buildSpecFromUpdate;function updateTree(_,j){var $=_;return j.forEach(function(_e){$=(0,immutability_helper_1.default)($,buildSpecFromUpdate(_e))}),$}mosaicUpdates.updateTree=updateTree;function createRemoveUpdate(_,j){var $=(0,dropRight_1$1.default)(j),_e=(0,last_1.default)(j),et=$.concat((0,mosaicUtilities_1$1.getOtherBranch)(_e)),tt=(0,mosaicUtilities_1$1.getAndAssertNodeAtPathExists)(_,et);return{path:$,spec:{$set:tt}}}mosaicUpdates.createRemoveUpdate=createRemoveUpdate;function isPathPrefixEqual(_,j,$){return(0,isEqual_1$1.default)((0,take_1.default)(_,$),(0,take_1.default)(j,$))}function createDragToUpdates(_,j,$,_e){var et=(0,mosaicUtilities_1$1.getAndAssertNodeAtPathExists)(_,$),tt=[],nt=isPathPrefixEqual(j,$,$.length);if(nt)et=updateTree(et,[createRemoveUpdate(et,(0,drop_1.default)(j,$.length))]);else{tt.push(createRemoveUpdate(_,j));var rt=isPathPrefixEqual(j,$,j.length-1);rt&&$.splice(j.length-1,1)}var at=(0,mosaicUtilities_1$1.getAndAssertNodeAtPathExists)(_,j),it,ot;_e===internalTypes_1$1.MosaicDropTargetPosition.LEFT||_e===internalTypes_1$1.MosaicDropTargetPosition.TOP?(it=at,ot=et):(it=et,ot=at);var st="column";return(_e===internalTypes_1$1.MosaicDropTargetPosition.LEFT||_e===internalTypes_1$1.MosaicDropTargetPosition.RIGHT)&&(st="row"),tt.push({path:$,spec:{$set:{first:it,second:ot,direction:st}}}),tt}mosaicUpdates.createDragToUpdates=createDragToUpdates;function createHideUpdate(_){var j=(0,dropRight_1$1.default)(_),$=(0,last_1.default)(_),_e;return $==="first"?_e=0:_e=100,{path:j,spec:{splitPercentage:{$set:_e}}}}mosaicUpdates.createHideUpdate=createHideUpdate;function createExpandUpdate(_,j){for(var $,_e={},et=_.length-1;et>=0;et--){var tt=_[et],nt=tt==="first"?j:100-j;_e=($={splitPercentage:{$set:nt}},$[tt]=_e,$)}return{spec:_e,path:[]}}mosaicUpdates.createExpandUpdate=createExpandUpdate;var __extends$6=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__assign$1=commonjsGlobal&&commonjsGlobal.__assign||function(){return __assign$1=Object.assign||function(_){for(var j,$=1,_e=arguments.length;$<_e;$++){j=arguments[$];for(var et in j)Object.prototype.hasOwnProperty.call(j,et)&&(_[et]=j[et])}return _},__assign$1.apply(this,arguments)},__importDefault$7=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(Mosaic$1,"__esModule",{value:!0});Mosaic$1.Mosaic=Mosaic$1.MosaicWithoutDragDropContext=void 0;var classnames_1$5=__importDefault$7(classnamesExports);__importDefault$7(countBy_1);__importDefault$7(keys_1);__importDefault$7(pickBy_1);var rdndmb_html5_to_touch_1=require$$4,react_1$7=__importDefault$7(reactExports),react_dnd_1$1=require$$7$1,react_dnd_multi_backend_1=require$$7,uuid_1=commonjsBrowser,contextTypes_1$5=contextTypes,MosaicRoot_1=MosaicRoot$1,MosaicZeroState_1=MosaicZeroState$1,RootDropTargets_1=RootDropTargets,mosaicUpdates_1$1=mosaicUpdates,DEFAULT_EXPAND_PERCENTAGE=70;function isUncontrolled(_){return _.initialValue!=null}var MosaicWithoutDragDropContext=function(_){__extends$6(j,_);function j(){var $=this,_e;return $=_.apply(this,arguments)||this,$.state={currentNode:null,lastInitialValue:null,mosaicId:(_e=$.props.mosaicId)!==null&&_e!==void 0?_e:(0,uuid_1.v4)()},$.updateRoot=function(et,tt){tt===void 0&&(tt=!1);var nt=$.getRoot()||{};$.replaceRoot((0,mosaicUpdates_1$1.updateTree)(nt,et),tt)},$.replaceRoot=function(et,tt){tt===void 0&&(tt=!1),$.props.onChange(et),!tt&&$.props.onRelease&&$.props.onRelease(et),isUncontrolled($.props)&&$.setState({currentNode:et})},$.actions={updateTree:$.updateRoot,remove:function(et){et.length===0?$.replaceRoot(null):$.updateRoot([(0,mosaicUpdates_1$1.createRemoveUpdate)($.getRoot(),et)])},expand:function(et,tt){return tt===void 0&&(tt=DEFAULT_EXPAND_PERCENTAGE),$.updateRoot([(0,mosaicUpdates_1$1.createExpandUpdate)(et,tt)])},getRoot:function(){return $.getRoot()},hide:function(et){return $.updateRoot([(0,mosaicUpdates_1$1.createHideUpdate)(et)])},replaceWith:function(et,tt){return $.updateRoot([{path:et,spec:{$set:tt}}])}},$.childContext={mosaicActions:$.actions,mosaicId:$.state.mosaicId,blueprintNamespace:$.props.blueprintNamespace},$}return j.getDerivedStateFromProps=function($,_e){return $.mosaicId&&(_e.mosaicId,$.mosaicId),isUncontrolled($)&&$.initialValue!==_e.lastInitialValue?{lastInitialValue:$.initialValue,currentNode:$.initialValue}:null},j.prototype.render=function(){var $=this.props.className;return react_1$7.default.createElement(contextTypes_1$5.MosaicContext.Provider,{value:this.childContext},react_1$7.default.createElement("div",{className:(0,classnames_1$5.default)($,"mosaic mosaic-drop-target")},this.renderTree(),react_1$7.default.createElement(RootDropTargets_1.RootDropTargets,null)))},j.prototype.getRoot=function(){return isUncontrolled(this.props)?this.state.currentNode:this.props.value},j.prototype.renderTree=function(){var $=this.getRoot();if(this.validateTree($),$==null)return this.props.zeroStateView;var _e=this.props,et=_e.renderTile,tt=_e.resize;return react_1$7.default.createElement(MosaicRoot_1.MosaicRoot,{root:$,renderTile:et,resize:tt})},j.prototype.validateTree=function($){},j.defaultProps={onChange:function(){},zeroStateView:react_1$7.default.createElement(MosaicZeroState_1.MosaicZeroState,null),className:"mosaic-blueprint-theme",blueprintNamespace:"bp3"},j}(react_1$7.default.PureComponent);Mosaic$1.MosaicWithoutDragDropContext=MosaicWithoutDragDropContext;var Mosaic=function(_){__extends$6(j,_);function j(){return _!==null&&_.apply(this,arguments)||this}return j.prototype.render=function(){return react_1$7.default.createElement(react_dnd_1$1.DndProvider,__assign$1({backend:react_dnd_multi_backend_1.MultiBackend,options:rdndmb_html5_to_touch_1.HTML5toTouch},this.props.dragAndDropManager&&{manager:this.props.dragAndDropManager}),react_1$7.default.createElement(MosaicWithoutDragDropContext,__assign$1({},this.props)))},j}(react_1$7.default.PureComponent);Mosaic$1.Mosaic=Mosaic;var MosaicWindow$1={},FUNC_ERROR_TEXT="Expected a function";function baseDelay$1(_,j,$){if(typeof _!="function")throw new TypeError(FUNC_ERROR_TEXT);return setTimeout(function(){_.apply(void 0,$)},j)}var _baseDelay=baseDelay$1;function apply$1(_,j,$){switch($.length){case 0:return _.call(j);case 1:return _.call(j,$[0]);case 2:return _.call(j,$[0],$[1]);case 3:return _.call(j,$[0],$[1],$[2])}return _.apply(j,$)}var _apply=apply$1,apply=_apply,nativeMax=Math.max;function overRest$1(_,j,$){return j=nativeMax(j===void 0?_.length-1:j,0),function(){for(var _e=arguments,et=-1,tt=nativeMax(_e.length-j,0),nt=Array(tt);++et<tt;)nt[et]=_e[j+et];et=-1;for(var rt=Array(j+1);++et<j;)rt[et]=_e[et];return rt[j]=$(nt),apply(_,this,rt)}}var _overRest=overRest$1;function constant$1(_){return function(){return _}}var constant_1=constant$1,constant=constant_1,defineProperty=_defineProperty$5,identity$2=identity_1,baseSetToString$1=defineProperty?function(_,j){return defineProperty(_,"toString",{configurable:!0,enumerable:!1,value:constant(j),writable:!0})}:identity$2,_baseSetToString=baseSetToString$1,HOT_COUNT=800,HOT_SPAN=16,nativeNow=Date.now;function shortOut$1(_){var j=0,$=0;return function(){var _e=nativeNow(),et=HOT_SPAN-(_e-$);if($=_e,et>0){if(++j>=HOT_COUNT)return arguments[0]}else j=0;return _.apply(void 0,arguments)}}var _shortOut=shortOut$1,baseSetToString=_baseSetToString,shortOut=_shortOut,setToString$1=shortOut(baseSetToString),_setToString=setToString$1,identity$1=identity_1,overRest=_overRest,setToString=_setToString;function baseRest$1(_,j){return setToString(overRest(_,j,identity$1),_+"")}var _baseRest=baseRest$1,baseDelay=_baseDelay,baseRest=_baseRest,defer=baseRest(function(_,j){return baseDelay(_,1,j)}),defer_1$1=defer,baseKeys=_baseKeys,getTag=_getTag,isArguments=isArguments_1,isArray=isArray_1,isArrayLike=isArrayLike_1,isBuffer=isBufferExports,isPrototype=_isPrototype,isTypedArray=isTypedArray_1,mapTag="[object Map]",setTag="[object Set]",objectProto=Object.prototype,hasOwnProperty=objectProto.hasOwnProperty;function isEmpty(_){if(_==null)return!0;if(isArrayLike(_)&&(isArray(_)||typeof _=="string"||typeof _.splice=="function"||isBuffer(_)||isTypedArray(_)||isArguments(_)))return!_.length;var j=getTag(_);if(j==mapTag||j==setTag)return!_.size;if(isPrototype(_))return!baseKeys(_).length;for(var $ in _)if(hasOwnProperty.call(_,$))return!1;return!0}var isEmpty_1$1=isEmpty,defaultToolbarControls={},ExpandButton$1={},MosaicButton={};(function(_){var j=commonjsGlobal&&commonjsGlobal.__importDefault||function(at){return at&&at.__esModule?at:{default:at}};Object.defineProperty(_,"__esModule",{value:!0}),_.createDefaultToolbarButton=_.DefaultToolbarButton=void 0;var $=j(classnamesExports),_e=j(reactExports),et=contextTypes,tt=OptionalBlueprint,nt=function(at){var it=at.title,ot=at.className,st=at.onClick,ct=at.text,pt=_e.default.useContext(et.MosaicContext).blueprintNamespace;return _e.default.createElement("button",{title:it,onClick:st,className:(0,$.default)("mosaic-default-control",tt.OptionalBlueprint.getClasses(pt,"BUTTON","MINIMAL"),ot)},ct&&_e.default.createElement("span",{className:"control-text"},ct))};_.DefaultToolbarButton=nt;var rt=function(at,it,ot,st){return _e.default.createElement(_.DefaultToolbarButton,{title:at,className:it,onClick:ot,text:st})};_.createDefaultToolbarButton=rt})(MosaicButton);var __extends$5=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__importDefault$6=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(ExpandButton$1,"__esModule",{value:!0});ExpandButton$1.ExpandButton=void 0;var classnames_1$4=__importDefault$6(classnamesExports),react_1$6=__importDefault$6(reactExports),contextTypes_1$4=contextTypes,OptionalBlueprint_1$4=OptionalBlueprint,MosaicButton_1$3=MosaicButton,ExpandButton=function(_){__extends$5(j,_);function j(){return _!==null&&_.apply(this,arguments)||this}return j.prototype.render=function(){var $=this;return react_1$6.default.createElement(contextTypes_1$4.MosaicContext.Consumer,null,function(_e){var et=_e.mosaicActions;return react_1$6.default.createElement(MosaicButton_1$3.DefaultToolbarButton,{title:"Expand",className:(0,classnames_1$4.default)("expand-button",OptionalBlueprint_1$4.OptionalBlueprint.getIconClass($.context.blueprintNamespace,"MAXIMIZE")),onClick:$.createExpand(et)})})},j.prototype.createExpand=function($){var _e=this;return function(){$.expand(_e.context.mosaicWindowActions.getPath()),_e.props.onClick&&_e.props.onClick()}},j.contextType=contextTypes_1$4.MosaicWindowContext,j}(react_1$6.default.PureComponent);ExpandButton$1.ExpandButton=ExpandButton;var RemoveButton$1={},__extends$4=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__importDefault$5=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(RemoveButton$1,"__esModule",{value:!0});RemoveButton$1.RemoveButton=void 0;var classnames_1$3=__importDefault$5(classnamesExports),react_1$5=__importDefault$5(reactExports),contextTypes_1$3=contextTypes,OptionalBlueprint_1$3=OptionalBlueprint,MosaicButton_1$2=MosaicButton,RemoveButton=function(_){__extends$4(j,_);function j(){return _!==null&&_.apply(this,arguments)||this}return j.prototype.render=function(){var $=this;return react_1$5.default.createElement(contextTypes_1$3.MosaicContext.Consumer,null,function(_e){var et=_e.mosaicActions,tt=_e.blueprintNamespace;return react_1$5.default.createElement(MosaicButton_1$2.DefaultToolbarButton,{title:"Close Window",className:(0,classnames_1$3.default)("close-button",OptionalBlueprint_1$3.OptionalBlueprint.getIconClass(tt,"CROSS")),onClick:$.createRemove(et)})})},j.prototype.createRemove=function($){var _e=this;return function(){$.remove(_e.context.mosaicWindowActions.getPath()),_e.props.onClick&&_e.props.onClick()}},j.contextType=contextTypes_1$3.MosaicWindowContext,j}(react_1$5.default.PureComponent);RemoveButton$1.RemoveButton=RemoveButton;var ReplaceButton$1={},__extends$3=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__importDefault$4=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(ReplaceButton$1,"__esModule",{value:!0});ReplaceButton$1.ReplaceButton=void 0;var classnames_1$2=__importDefault$4(classnamesExports),noop_1$1=__importDefault$4(noop_1$3),react_1$4=__importDefault$4(reactExports),contextTypes_1$2=contextTypes,OptionalBlueprint_1$2=OptionalBlueprint,MosaicButton_1$1=MosaicButton,ReplaceButton=function(_){__extends$3(j,_);function j(){var $=_!==null&&_.apply(this,arguments)||this;return $.replace=function(){$.context.mosaicWindowActions.replaceWithNew().then(function(){$.props.onClick&&$.props.onClick()}).catch(noop_1$1.default)},$}return j.prototype.render=function(){return react_1$4.default.createElement(MosaicButton_1$1.DefaultToolbarButton,{title:"Replace Window",className:(0,classnames_1$2.default)("replace-button",OptionalBlueprint_1$2.OptionalBlueprint.getIconClass(this.context.blueprintNamespace,"EXCHANGE")),onClick:this.replace})},j.contextType=contextTypes_1$2.MosaicWindowContext,j}(react_1$4.default.PureComponent);ReplaceButton$1.ReplaceButton=ReplaceButton;var SplitButton$1={},__extends$2=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__importDefault$3=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(SplitButton$1,"__esModule",{value:!0});SplitButton$1.SplitButton=void 0;var classnames_1$1=__importDefault$3(classnamesExports),noop_1=__importDefault$3(noop_1$3),react_1$3=__importDefault$3(reactExports),contextTypes_1$1=contextTypes,OptionalBlueprint_1$1=OptionalBlueprint,MosaicButton_1=MosaicButton,SplitButton=function(_){__extends$2(j,_);function j(){var $=_!==null&&_.apply(this,arguments)||this;return $.split=function(){$.context.mosaicWindowActions.split().then(function(){$.props.onClick&&$.props.onClick()}).catch(noop_1.default)},$}return j.prototype.render=function(){return react_1$3.default.createElement(MosaicButton_1.DefaultToolbarButton,{title:"Split Window",className:(0,classnames_1$1.default)("split-button",OptionalBlueprint_1$1.OptionalBlueprint.getIconClass(this.context.blueprintNamespace,"ADD_COLUMN_RIGHT")),onClick:this.split})},j.contextType=contextTypes_1$1.MosaicWindowContext,j}(react_1$3.default.PureComponent);SplitButton$1.SplitButton=SplitButton;var __importDefault$2=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(defaultToolbarControls,"__esModule",{value:!0});defaultToolbarControls.DEFAULT_CONTROLS_WITHOUT_CREATION=defaultToolbarControls.DEFAULT_CONTROLS_WITH_CREATION=void 0;var react_1$2=__importDefault$2(reactExports),ExpandButton_1=ExpandButton$1,RemoveButton_1=RemoveButton$1,ReplaceButton_1=ReplaceButton$1,SplitButton_1=SplitButton$1;defaultToolbarControls.DEFAULT_CONTROLS_WITH_CREATION=react_1$2.default.Children.toArray([react_1$2.default.createElement(ReplaceButton_1.ReplaceButton,null),react_1$2.default.createElement(SplitButton_1.SplitButton,null),react_1$2.default.createElement(ExpandButton_1.ExpandButton,null),react_1$2.default.createElement(RemoveButton_1.RemoveButton,null)]);defaultToolbarControls.DEFAULT_CONTROLS_WITHOUT_CREATION=react_1$2.default.Children.toArray([react_1$2.default.createElement(ExpandButton_1.ExpandButton,null),react_1$2.default.createElement(RemoveButton_1.RemoveButton,null)]);var Separator$1={},__extends$1=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__importDefault$1=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(Separator$1,"__esModule",{value:!0});Separator$1.Separator=void 0;var react_1$1=__importDefault$1(reactExports),Separator=function(_){__extends$1(j,_);function j(){return _!==null&&_.apply(this,arguments)||this}return j.prototype.render=function(){return react_1$1.default.createElement("div",{className:"separator"})},j}(react_1$1.default.PureComponent);Separator$1.Separator=Separator;var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _=function(j,$){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_e,et){_e.__proto__=et}||function(_e,et){for(var tt in et)Object.prototype.hasOwnProperty.call(et,tt)&&(_e[tt]=et[tt])},_(j,$)};return function(j,$){if(typeof $!="function"&&$!==null)throw new TypeError("Class extends value "+String($)+" is not a constructor or null");_(j,$);function _e(){this.constructor=j}j.prototype=$===null?Object.create($):(_e.prototype=$.prototype,new _e)}}(),__assign=commonjsGlobal&&commonjsGlobal.__assign||function(){return __assign=Object.assign||function(_){for(var j,$=1,_e=arguments.length;$<_e;$++){j=arguments[$];for(var et in j)Object.prototype.hasOwnProperty.call(j,et)&&(_[et]=j[et])}return _},__assign.apply(this,arguments)},__createBinding=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(_,j,$,_e){_e===void 0&&(_e=$);var et=Object.getOwnPropertyDescriptor(j,$);(!et||("get"in et?!j.__esModule:et.writable||et.configurable))&&(et={enumerable:!0,get:function(){return j[$]}}),Object.defineProperty(_,_e,et)}:function(_,j,$,_e){_e===void 0&&(_e=$),_[_e]=j[$]}),__setModuleDefault=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(_,j){Object.defineProperty(_,"default",{enumerable:!0,value:j})}:function(_,j){_.default=j}),__importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(_){if(_&&_.__esModule)return _;var j={};if(_!=null)for(var $ in _)$!=="default"&&Object.prototype.hasOwnProperty.call(_,$)&&__createBinding(j,_,$);return __setModuleDefault(j,_),j},__importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(MosaicWindow$1,"__esModule",{value:!0});MosaicWindow$1.MosaicWindow=MosaicWindow$1.InternalMosaicWindow=void 0;var classnames_1=__importDefault(classnamesExports),defer_1=__importDefault(defer_1$1),dropRight_1=__importDefault(dropRight_1$2),isEmpty_1=__importDefault(isEmpty_1$1),isEqual_1=__importDefault(isEqual_1$2),values_1=__importDefault(values_1$1),react_1=__importStar(reactExports),react_dnd_1=require$$7$1,defaultToolbarControls_1=defaultToolbarControls,Separator_1=Separator$1,contextTypes_1=contextTypes,internalTypes_1=internalTypes,MosaicDropTarget_1=MosaicDropTarget$1,types_1=types,mosaicUpdates_1=mosaicUpdates,mosaicUtilities_1=mosaicUtilities,OptionalBlueprint_1=OptionalBlueprint,InternalMosaicWindow=function(_){__extends(j,_);function j(){var $=_!==null&&_.apply(this,arguments)||this;return $.state={additionalControlsOpen:!1},$.rootElement=null,$.renderDropTarget=function(_e){var et=$.props.path;return react_1.default.createElement(MosaicDropTarget_1.MosaicDropTarget,{position:_e,path:et,key:_e})},$.split=function(){for(var _e=[],et=0;et<arguments.length;et++)_e[et]=arguments[et];$.checkCreateNode();var tt=$.props,nt=tt.createNode,rt=tt.path,at=$.context.mosaicActions,it=at.getRoot(),ot=$.rootElement.offsetWidth>$.rootElement.offsetHeight?"row":"column";return Promise.resolve(nt.apply(void 0,_e)).then(function(st){return at.replaceWith(rt,{direction:ot,second:st,first:(0,mosaicUtilities_1.getAndAssertNodeAtPathExists)(it,rt)})})},$.swap=function(){for(var _e=[],et=0;et<arguments.length;et++)_e[et]=arguments[et];$.checkCreateNode();var tt=$.context.mosaicActions,nt=$.props,rt=nt.createNode,at=nt.path;return Promise.resolve(rt.apply(void 0,_e)).then(function(it){return tt.replaceWith(at,it)})},$.setAdditionalControlsOpen=function(_e){var et,tt,nt=_e==="toggle"?!$.state.additionalControlsOpen:_e;$.setState({additionalControlsOpen:nt}),(tt=(et=$.props).onAdditionalControlsToggle)===null||tt===void 0||tt.call(et,nt)},$.getPath=function(){return $.props.path},$.connectDragSource=function(_e){var et=$.props.connectDragSource;return et(_e)},$.childContext={blueprintNamespace:$.context.blueprintNamespace,mosaicWindowActions:{split:$.split,replaceWithNew:$.swap,setAdditionalControlsOpen:$.setAdditionalControlsOpen,getPath:$.getPath,connectDragSource:$.connectDragSource}},$}return j.prototype.render=function(){var $=this,_e=this.props,et=_e.className,tt=_e.isOver,nt=_e.renderPreview,rt=_e.additionalControls,at=_e.connectDropTarget,it=_e.connectDragPreview,ot=_e.draggedMosaicId,st=_e.disableAdditionalControlsOverlay;return react_1.default.createElement(contextTypes_1.MosaicWindowContext.Provider,{value:this.childContext},at(react_1.default.createElement("div",{className:(0,classnames_1.default)("mosaic-window mosaic-drop-target",et,{"drop-target-hover":tt&&ot===this.context.mosaicId,"additional-controls-open":this.state.additionalControlsOpen}),ref:function(ct){return $.rootElement=ct}},this.renderToolbar(),react_1.default.createElement("div",{className:"mosaic-window-body"},this.props.children),!st&&react_1.default.createElement("div",{className:"mosaic-window-body-overlay",onClick:function(){$.setAdditionalControlsOpen(!1)}}),react_1.default.createElement("div",{className:"mosaic-window-additional-actions-bar"},rt),it(nt(this.props)),react_1.default.createElement("div",{className:"drop-target-container"},(0,values_1.default)(internalTypes_1.MosaicDropTargetPosition).map(this.renderDropTarget)))))},j.prototype.getToolbarControls=function(){var $=this.props,_e=$.toolbarControls,et=$.createNode;return _e||(et?defaultToolbarControls_1.DEFAULT_CONTROLS_WITH_CREATION:defaultToolbarControls_1.DEFAULT_CONTROLS_WITHOUT_CREATION)},j.prototype.renderToolbar=function(){var $,_e=this,et=this.props,tt=et.title,nt=et.draggable,rt=et.additionalControls,at=et.additionalControlButtonText,it=et.path,ot=et.renderToolbar,st=this.state.additionalControlsOpen,ct=this.getToolbarControls(),pt=nt&&it.length>0,dt=pt?this.props.connectDragSource:function(lt){return lt};if(ot){var ft=dt(ot(this.props,nt));return react_1.default.createElement("div",{className:(0,classnames_1.default)("mosaic-window-toolbar",{draggable:pt})},ft)}var gt=dt(react_1.default.createElement("div",{title:tt,className:"mosaic-window-title"},tt)),ut=!(0,isEmpty_1.default)(rt);return react_1.default.createElement("div",{className:(0,classnames_1.default)("mosaic-window-toolbar",{draggable:pt})},gt,react_1.default.createElement("div",{className:(0,classnames_1.default)("mosaic-window-controls",OptionalBlueprint_1.OptionalBlueprint.getClasses("BUTTON_GROUP"))},ut&&react_1.default.createElement("button",{onClick:function(){return _e.setAdditionalControlsOpen(!st)},className:(0,classnames_1.default)(OptionalBlueprint_1.OptionalBlueprint.getClasses(this.context.blueprintNamespace,"BUTTON","MINIMAL"),OptionalBlueprint_1.OptionalBlueprint.getIconClass(this.context.blueprintNamespace,"MORE"),($={},$[OptionalBlueprint_1.OptionalBlueprint.getClasses(this.context.blueprintNamespace,"ACTIVE")]=st,$))},react_1.default.createElement("span",{className:"control-text"},at)),ut&&react_1.default.createElement(Separator_1.Separator,null),ct))},j.prototype.checkCreateNode=function(){if(this.props.createNode==null)throw new Error("Operation invalid unless `createNode` is defined")},j.defaultProps={additionalControlButtonText:"More",draggable:!0,renderPreview:function($){var _e=$.title;return react_1.default.createElement("div",{className:"mosaic-preview"},react_1.default.createElement("div",{className:"mosaic-window-toolbar"},react_1.default.createElement("div",{className:"mosaic-window-title"},_e)),react_1.default.createElement("div",{className:"mosaic-window-body"},react_1.default.createElement("h4",null,_e),react_1.default.createElement(OptionalBlueprint_1.OptionalBlueprint.Icon,{className:"default-preview-icon",size:"large",icon:"APPLICATION"})))},renderToolbar:null},j.contextType=contextTypes_1.MosaicContext,j}(react_1.default.Component);MosaicWindow$1.InternalMosaicWindow=InternalMosaicWindow;function ConnectedInternalMosaicWindow(_){var j=(0,react_1.useContext)(contextTypes_1.MosaicContext),$=j.mosaicActions,_e=j.mosaicId,et=(0,react_dnd_1.useDrag)({type:types_1.MosaicDragType.WINDOW,item:function(ct){_.onDragStart&&_.onDragStart();var pt=(0,defer_1.default)(function(){return $.hide(_.path)});return{mosaicId:_e,hideTimer:pt}},end:function(ct,pt){var dt=ct.hideTimer;window.clearTimeout(dt);var ft=_.path,gt=pt.getDropResult()||{},ut=gt.position,lt=gt.path;ut!=null&&lt!=null&&!(0,isEqual_1.default)(lt,ft)?($.updateTree((0,mosaicUpdates_1.createDragToUpdates)($.getRoot(),ft,lt,ut)),_.onDragEnd&&_.onDragEnd("drop")):($.updateTree([{path:(0,dropRight_1.default)(ft),spec:{splitPercentage:{$set:void 0}}}]),_.onDragEnd&&_.onDragEnd("reset"))}}),tt=et[1],nt=et[2],rt=(0,react_dnd_1.useDrop)({accept:types_1.MosaicDragType.WINDOW,collect:function(ct){var pt;return{isOver:ct.isOver(),draggedMosaicId:(pt=ct.getItem())===null||pt===void 0?void 0:pt.mosaicId}}}),at=rt[0],it=at.isOver,ot=at.draggedMosaicId,st=rt[1];return react_1.default.createElement(InternalMosaicWindow,__assign({},_,{connectDragPreview:nt,connectDragSource:tt,connectDropTarget:st,isOver:it,draggedMosaicId:ot}))}var MosaicWindow=function(_){__extends(j,_);function j(){return _!==null&&_.apply(this,arguments)||this}return j.prototype.render=function(){return react_1.default.createElement(ConnectedInternalMosaicWindow,__assign({},this.props))},j}(react_1.default.PureComponent);MosaicWindow$1.MosaicWindow=MosaicWindow;(function(_){Object.defineProperty(_,"__esModule",{value:!0}),_.DEFAULT_CONTROLS_WITHOUT_CREATION=_.DEFAULT_CONTROLS_WITH_CREATION=_.RemoveButton=_.SplitButton=_.ReplaceButton=_.ExpandButton=_.Separator=_.MosaicZeroState=_.DefaultToolbarButton=_.createDefaultToolbarButton=_.MosaicWindow=_.isParent=_.getPathToCorner=_.getOtherDirection=_.getOtherBranch=_.getNodeAtPath=_.getLeaves=_.getAndAssertNodeAtPathExists=_.Corner=_.createBalancedTreeFromLeaves=_.updateTree=_.createRemoveUpdate=_.createHideUpdate=_.createExpandUpdate=_.createDragToUpdates=_.buildSpecFromUpdate=_.MosaicWindowContext=_.MosaicContext=_.MosaicDragType=_.MosaicWithoutDragDropContext=_.Mosaic=void 0;/**
 * @license
 * Copyright 2019 Kevin Verdieck, originally developed at Palantir Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var j=Mosaic$1;Object.defineProperty(_,"Mosaic",{enumerable:!0,get:function(){return j.Mosaic}}),Object.defineProperty(_,"MosaicWithoutDragDropContext",{enumerable:!0,get:function(){return j.MosaicWithoutDragDropContext}});var $=types;Object.defineProperty(_,"MosaicDragType",{enumerable:!0,get:function(){return $.MosaicDragType}});var _e=contextTypes;Object.defineProperty(_,"MosaicContext",{enumerable:!0,get:function(){return _e.MosaicContext}}),Object.defineProperty(_,"MosaicWindowContext",{enumerable:!0,get:function(){return _e.MosaicWindowContext}});var et=mosaicUpdates;Object.defineProperty(_,"buildSpecFromUpdate",{enumerable:!0,get:function(){return et.buildSpecFromUpdate}}),Object.defineProperty(_,"createDragToUpdates",{enumerable:!0,get:function(){return et.createDragToUpdates}}),Object.defineProperty(_,"createExpandUpdate",{enumerable:!0,get:function(){return et.createExpandUpdate}}),Object.defineProperty(_,"createHideUpdate",{enumerable:!0,get:function(){return et.createHideUpdate}}),Object.defineProperty(_,"createRemoveUpdate",{enumerable:!0,get:function(){return et.createRemoveUpdate}}),Object.defineProperty(_,"updateTree",{enumerable:!0,get:function(){return et.updateTree}});var tt=mosaicUtilities;Object.defineProperty(_,"createBalancedTreeFromLeaves",{enumerable:!0,get:function(){return tt.createBalancedTreeFromLeaves}}),Object.defineProperty(_,"Corner",{enumerable:!0,get:function(){return tt.Corner}}),Object.defineProperty(_,"getAndAssertNodeAtPathExists",{enumerable:!0,get:function(){return tt.getAndAssertNodeAtPathExists}}),Object.defineProperty(_,"getLeaves",{enumerable:!0,get:function(){return tt.getLeaves}}),Object.defineProperty(_,"getNodeAtPath",{enumerable:!0,get:function(){return tt.getNodeAtPath}}),Object.defineProperty(_,"getOtherBranch",{enumerable:!0,get:function(){return tt.getOtherBranch}}),Object.defineProperty(_,"getOtherDirection",{enumerable:!0,get:function(){return tt.getOtherDirection}}),Object.defineProperty(_,"getPathToCorner",{enumerable:!0,get:function(){return tt.getPathToCorner}}),Object.defineProperty(_,"isParent",{enumerable:!0,get:function(){return tt.isParent}});var nt=MosaicWindow$1;Object.defineProperty(_,"MosaicWindow",{enumerable:!0,get:function(){return nt.MosaicWindow}});var rt=MosaicButton;Object.defineProperty(_,"createDefaultToolbarButton",{enumerable:!0,get:function(){return rt.createDefaultToolbarButton}}),Object.defineProperty(_,"DefaultToolbarButton",{enumerable:!0,get:function(){return rt.DefaultToolbarButton}});var at=MosaicZeroState$1;Object.defineProperty(_,"MosaicZeroState",{enumerable:!0,get:function(){return at.MosaicZeroState}});var it=Separator$1;Object.defineProperty(_,"Separator",{enumerable:!0,get:function(){return it.Separator}});var ot=ExpandButton$1;Object.defineProperty(_,"ExpandButton",{enumerable:!0,get:function(){return ot.ExpandButton}});var st=ReplaceButton$1;Object.defineProperty(_,"ReplaceButton",{enumerable:!0,get:function(){return st.ReplaceButton}});var ct=SplitButton$1;Object.defineProperty(_,"SplitButton",{enumerable:!0,get:function(){return ct.SplitButton}});var pt=RemoveButton$1;Object.defineProperty(_,"RemoveButton",{enumerable:!0,get:function(){return pt.RemoveButton}});var dt=defaultToolbarControls;Object.defineProperty(_,"DEFAULT_CONTROLS_WITH_CREATION",{enumerable:!0,get:function(){return dt.DEFAULT_CONTROLS_WITH_CREATION}}),Object.defineProperty(_,"DEFAULT_CONTROLS_WITHOUT_CREATION",{enumerable:!0,get:function(){return dt.DEFAULT_CONTROLS_WITHOUT_CREATION}})})(lib);var define_import_meta_env_default$1={BASE_URL:"/imjoy-mosaic/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const createStoreImpl=_=>{let j;const $=new Set,_e=(ot,st)=>{const ct=typeof ot=="function"?ot(j):ot;if(!Object.is(ct,j)){const pt=j;j=st??(typeof ct!="object"||ct===null)?ct:Object.assign({},j,ct),$.forEach(dt=>dt(j,pt))}},et=()=>j,at={setState:_e,getState:et,getInitialState:()=>it,subscribe:ot=>($.add(ot),()=>$.delete(ot)),destroy:()=>{(define_import_meta_env_default$1?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),$.clear()}},it=j=_(_e,et,at);return at},createStore=_=>_?createStoreImpl(_):createStoreImpl;var withSelector={exports:{}},withSelector_production_min={},shim={exports:{}},useSyncExternalStoreShim_production_min={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var e=reactExports;function h$1(_,j){return _===j&&(_!==0||1/_===1/j)||_!==_&&j!==j}var k=typeof Object.is=="function"?Object.is:h$1,l=e.useState,m=e.useEffect,n$1=e.useLayoutEffect,p$1=e.useDebugValue;function q$1(_,j){var $=j(),_e=l({inst:{value:$,getSnapshot:j}}),et=_e[0].inst,tt=_e[1];return n$1(function(){et.value=$,et.getSnapshot=j,r$1(et)&&tt({inst:et})},[_,$,j]),m(function(){return r$1(et)&&tt({inst:et}),_(function(){r$1(et)&&tt({inst:et})})},[_]),p$1($),$}function r$1(_){var j=_.getSnapshot;_=_.value;try{var $=j();return!k(_,$)}catch{return!0}}function t$1(_,j){return j()}var u$1=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?t$1:q$1;useSyncExternalStoreShim_production_min.useSyncExternalStore=e.useSyncExternalStore!==void 0?e.useSyncExternalStore:u$1;shim.exports=useSyncExternalStoreShim_production_min;var shimExports=shim.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var h=reactExports,n=shimExports;function p(_,j){return _===j&&(_!==0||1/_===1/j)||_!==_&&j!==j}var q=typeof Object.is=="function"?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;withSelector_production_min.useSyncExternalStoreWithSelector=function(_,j,$,_e,et){var tt=t(null);if(tt.current===null){var nt={hasValue:!1,value:null};tt.current=nt}else nt=tt.current;tt=v(function(){function at(pt){if(!it){if(it=!0,ot=pt,pt=_e(pt),et!==void 0&&nt.hasValue){var dt=nt.value;if(et(dt,pt))return st=dt}return st=pt}if(dt=st,q(ot,pt))return dt;var ft=_e(pt);return et!==void 0&&et(dt,ft)?dt:(ot=pt,st=ft)}var it=!1,ot,st,ct=$===void 0?null:$;return[function(){return at(j())},ct===null?void 0:function(){return at(ct())}]},[j,$,_e,et]);var rt=r(_,tt[0],tt[1]);return u(function(){nt.hasValue=!0,nt.value=rt},[rt]),w(rt),rt};withSelector.exports=withSelector_production_min;var withSelectorExports=withSelector.exports;const useSyncExternalStoreExports=getDefaultExportFromCjs(withSelectorExports);var define_import_meta_env_default={BASE_URL:"/imjoy-mosaic/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const{useDebugValue}=React,{useSyncExternalStoreWithSelector}=useSyncExternalStoreExports;let didWarnAboutEqualityFn=!1;const identity=_=>_;function useStore$1(_,j=identity,$){(define_import_meta_env_default?"production":void 0)!=="production"&&$&&!didWarnAboutEqualityFn&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),didWarnAboutEqualityFn=!0);const _e=useSyncExternalStoreWithSelector(_.subscribe,_.getState,_.getServerState||_.getInitialState,j,$);return useDebugValue(_e),_e}const createImpl=_=>{(define_import_meta_env_default?"production":void 0)!=="production"&&typeof _!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const j=typeof _=="function"?createStore(_):_,$=(_e,et)=>useStore$1(j,_e,et);return Object.assign($,j),$},create=_=>createImpl,useStore=create()(_=>({title:"Imjoy Mosaic",setTitle:j=>_({title:j}),windowId2name:{},setWindowId2name:(j,$)=>_(_e=>({windowId2name:{..._e.windowId2name,[j]:$}}))})),ToolbarControls=reactExports.Children.toArray([jsxRuntimeExports.jsx(lib.ExpandButton,{}),jsxRuntimeExports.jsx(lib.RemoveButton,{})]),Window=({id:_,path:j})=>{const{windowId2name:$}=useStore();let _e=`Window ${_}`;return $[_]&&(_e=$[_]),jsxRuntimeExports.jsx(lib.MosaicWindow,{title:_e,path:j,onDragStart:()=>console.log("MosaicWindow.onDragStart"),onDragEnd:et=>console.log("MosaicWindow.onDragEnd",et),toolbarControls:ToolbarControls,children:jsxRuntimeExports.jsx("div",{className:"example-window",style:{padding:5},children:jsxRuntimeExports.jsx("div",{id:`win-${_}`,style:{height:"100%",width:"100%"}})})})},THEMES={Light:"mosaic-blueprint-theme",Dark:classNames("mosaic-blueprint-theme",DARK)},App=()=>{const[_,j]=reactExports.useState(null),[$,_e]=reactExports.useState("Dark"),[et,tt]=reactExports.useState(null),[nt,rt]=reactExports.useState(0),[at,it]=reactExports.useState(!1),[ot,st]=reactExports.useState(!1),{setWindowId2name:ct,title:pt,setTitle:dt}=useStore(),ft=React.useCallback((vt="topRight")=>{let bt=_;const mt=nt+1;if(bt===null)return j(mt),rt(mt),mt;const _t=lib.getPathToCorner(bt,lib.Corner.TOP_RIGHT),Et=lib.getNodeAtPath(bt,dropRight$1(_t)),wt=lib.getNodeAtPath(bt,_t);let St;vt==="topRight"?St=Et?lib.getOtherDirection(Et.direction):"row":St="row";let Tt,At;return St==="row"?(Tt=wt,At=mt):(Tt=mt,At=wt),bt=lib.updateTree(bt,[{path:_t,spec:{$set:{direction:St,first:Tt,second:At}}}]),j(bt),rt(mt),mt},[_,nt,j,rt]),gt=React.useCallback(async(vt=null)=>{if(et){vt||(vt=prompt("Please enter the plugin url","https://kaibu.org"));try{const bt=await et.api.loadPlugin({src:vt});await bt.run(),console.log("new plugin:",bt)}catch(bt){console.error(bt)}}else setTimeout(()=>{gt(vt)},1e3)},[et]);reactExports.useEffect(()=>{it(!0);const vt=new imjoyCore.ImJoy({imjoy_api:{}});vt.start().then(()=>{tt(vt),it(!1)})},[]),reactExports.useEffect(()=>{if(et&&(et.event_bus.on("add_window",vt=>{const bt=ft(),mt=setInterval(()=>{const _t=document.getElementById(`win-${bt}`);_t&&(_t.id=vt.window_id,console.log("Imjoy window created:",vt),ct(bt,vt.name),clearInterval(mt))},500)}),!ot)){st(!0);const vt=new URLSearchParams(window.location.search),bt=vt.get("plugin");console.log("pluginUrl:",bt),bt&&gt(bt);const mt=vt.get("title");mt&&dt(mt)}},[et,ft,ct,gt,ot,dt]);const ut=vt=>{j(vt)},lt=vt=>{console.log("Mosaic.onRelease():",vt)},ht=()=>{const vt=lib.getLeaves(_);j(lib.createBalancedTreeFromLeaves(vt))},yt=()=>jsxRuntimeExports.jsxs("div",{className:classNames(NAVBAR,DARK),children:[jsxRuntimeExports.jsx("div",{className:NAVBAR_GROUP,children:jsxRuntimeExports.jsx("div",{className:NAVBAR_HEADING,children:pt})}),jsxRuntimeExports.jsxs("div",{className:classNames(NAVBAR_GROUP,BUTTON_GROUP),children:[jsxRuntimeExports.jsxs("label",{className:classNames("theme-selection",LABEL,INLINE),children:["Theme:",jsxRuntimeExports.jsx(HTMLSelect,{value:$,onChange:vt=>_e(vt.currentTarget.value),children:React.Children.toArray(Object.keys(THEMES).map(vt=>jsxRuntimeExports.jsx("option",{children:vt})))})]}),jsxRuntimeExports.jsx("div",{className:"navbar-separator"}),jsxRuntimeExports.jsx("span",{className:"actions-label",children:"Actions:"}),jsxRuntimeExports.jsx("button",{className:classNames(BUTTON,iconClass(IconNames.GRID_VIEW)),onClick:ht,children:"Auto Arrange"}),jsxRuntimeExports.jsx("button",{className:classNames(BUTTON,iconClass(IconNames.ARROW_TOP_RIGHT)),onClick:()=>{gt(null)},children:"Add Window"})]})]});return jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsxs("div",{className:"react-mosaic-example-app",children:[yt(),jsxRuntimeExports.jsx(lib.Mosaic,{renderTile:(vt,bt)=>jsxRuntimeExports.jsx(Window,{id:vt,path:bt}),zeroStateView:jsxRuntimeExports.jsx(lib.MosaicZeroState,{}),value:_,onChange:ut,onRelease:lt,className:THEMES[$],blueprintNamespace:"bp5"}),jsxRuntimeExports.jsx(OverlaysProvider,{children:jsxRuntimeExports.jsx(Overlay2,{isOpen:at,className:"overlay2",children:jsxRuntimeExports.jsx("div",{className:"loading-animation"})})})]})})};client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(App,{})}));
